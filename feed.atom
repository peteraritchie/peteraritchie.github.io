<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>http://blog.peterritchie.com/</id>
	<title>Peter Ritchie's Blog</title>
	<link rel="self" href="http://blog.peterritchie.com/" />
	<rights>2025</rights>
	<updated>2025-05-19T16:59:03Z</updated>
	<subtitle>Peter Ritchie</subtitle>
	<entry>
		<id>http://blog.peterritchie.com/posts/things-that-caught-my-attention-last-week-may-18</id>
		<title>Things That Caught My Attention Last Week - May 18</title>
		<link href="http://blog.peterritchie.com/posts/things-that-caught-my-attention-last-week-may-18" />
		<updated>2025-05-19T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/caught-i.png" class="img-fluid" alt="caught-my-i" /&gt;&lt;/p&gt;
&lt;!-- ## Open-source --&gt;
&lt;h2 id="architecture"&gt;Architecture&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.milanjovanovic.tech/blog/cqrs-pattern-the-way-it-should-have-been-from-the-start"&gt;CQRS Pattern the Way It Should've Been From the Start&lt;/a&gt; by Milan Jovanović&lt;/p&gt;
&lt;!-- ## Presenting
 --&gt;
&lt;h2 id="net"&gt;.NET&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://blog.duendesoftware.com/posts/20250513-duende-identityserver-and-otel-metrics-traces-and-logs-in-the-net-aspire-dashboard/"&gt;Duende IdentityServer and OTel Metrics, Traces, and Logs in the .NET Aspire Dashboard&lt;/a&gt; by Khalid Abuhakmeh&lt;/p&gt;
&lt;p&gt;&lt;a href="https://medium.com/&amp;#64;davidfowl/taming-manifest-sprawl-with-aspire-1ad938379433"&gt;Taming Manifest Sprawl with Aspire | by David Fowler | May, 2025 | Medium&lt;/a&gt; by David Fowl&lt;/p&gt;
&lt;p&gt;&lt;a href="https://jeremydmiller.com/2025/05/15/wolverine-4-is-bringing-multi-tenancy-to-ef-core/"&gt;Wolverine 4 is Bringing Multi-Tenancy to EF Core&lt;/a&gt; by Jeremy Miller&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ardalis.com/ardalis-specification-v9-release/"&gt;Ardalis Specification v9 Released&lt;/a&gt; by Steve Smith&lt;/p&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/using-the-new-ai-template-to-create-a-chatbot-about-a-website/"&gt;Using the new AI template to create a chatbot about a website&lt;/a&gt; by Andrew Lock&lt;/p&gt;
&lt;!-- ## Domain Driven Design
 --&gt;
&lt;!-- ## DevOps
 ## Design

## Mobile--&gt;
&lt;h2 id="agilework-life"&gt;Agile/Work Life&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://queen-of-questions.kit.com/posts/my-team-member-is-suffering-how-can-i-help"&gt;My team member is suffering. How can I help??&lt;/a&gt; by Clare Sudbery&lt;/p&gt;
&lt;p&gt;&lt;a href="https://apievangelist.com/2025/05/12/embracing-rather-than-overcoming-team-boundaries/"&gt;Embracing Rather Than Overcoming Team Boundaries&lt;/a&gt; by Kin Lane&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.cnbc.com/2025/05/13/microsoft-is-cutting-3percent-of-workers-across-the-software-company.html"&gt;Microsoft laying off about 6,000 people, or 3% of its workforce&lt;/a&gt; by CNBC&lt;/p&gt;
&lt;!-- ## REST/APIs
 --&gt;
&lt;h2 id="azure"&gt;Azure&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/cosmosdb/build-2025-preview-transform-your-ai-apps-and-agents-with-azure-cosmos-db/"&gt;Build 2025 Preview: Transform Your AI Apps and Agents with Azure Cosmos DB&lt;/a&gt; by Azure Cosmos DB Blog&lt;/p&gt;
&lt;h2 id="software-development"&gt;Software Development&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://deviq.com/practices/code-readability"&gt;Code Readability&lt;/a&gt; by DevIQ&lt;/p&gt;
&lt;p&gt;&lt;a href="https://woodruff.dev/iterators-and-functional-combinators/"&gt;Rust Iterators and Functional Combinators&lt;/a&gt; by Chris Woody Woodruff&lt;/p&gt;
&lt;h2 id="windows"&gt;Windows&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/oldnewthing/20250514-00/?p=111178"&gt;If I mark my thread pool callback as long-running, does it still count toward the thread pool thread limit?&lt;/a&gt; by Raymond Chen&lt;/p&gt;
&lt;!-- ## Security
 --&gt;
&lt;h2 id="ai"&gt;AI&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://martinfowler.com/articles/exploring-gen-ai/software-supply-chain-attack-surface.html"&gt;Coding Assistants Threaten the Software Supply Chain&lt;/a&gt; by Jim Gumbley, Lilly Ryan&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/caught-i.png" class="img-fluid" alt="caught-my-i"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/things-that-caught-my-attention-last-week-may-11</id>
		<title>Things That Caught My Attention Last Week - May 11</title>
		<link href="http://blog.peterritchie.com/posts/things-that-caught-my-attention-last-week-may-11" />
		<updated>2025-05-11T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/caught-i.png" class="img-fluid" alt="caught-my-i" /&gt;&lt;/p&gt;
&lt;!-- ## Open-source --&gt;
&lt;h2 id="architecture"&gt;Architecture&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.milanjovanovic.tech/blog/from-anemic-models-to-behavior-driven-models-a-practical-ddd-refactor-in-csharp"&gt;From Anemic Models to Behavior-Driven Models: A Practical DDD Refactor in C#&lt;/a&gt; by Milan Jovanović&lt;/p&gt;
&lt;!-- ## Presenting
 --&gt;
&lt;h2 id="net"&gt;.NET&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-the-new-ai-chat-template/"&gt;Exploring the new AI chat template&lt;/a&gt; by Andrew Lock&lt;/p&gt;
&lt;p&gt;&lt;a href="https://medium.com/&amp;#64;davidfowl/intent-vs-mechanics-the-power-of-abstraction-in-aspire-d14a33aab6bb"&gt;Intent vs. Mechanics: The Power of Abstraction in Aspire&lt;/a&gt; by David Fowler&lt;/p&gt;
&lt;p&gt;&lt;a href="https://jeremydmiller.com/2025/05/11/managing-auto-creation-of-database-or-message-broker-resources-in-the-critter-stack-vnext/"&gt;Managing Auto Creation of Database or Message Broker Resources in the Critter Stack vNext&lt;/a&gt; by Jeremy Miller&lt;/p&gt;
&lt;h2 id="domain-driven-design"&gt;Domain Driven Design&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=rPNdlLwBnW4"&gt;What we learned about event sourcing and DDD while building a bank&lt;/a&gt; by Thomas Bøgh Fangel&lt;/p&gt;
&lt;!-- ## DevOps --&gt;
&lt;!-- ## Design

## Mobile

## Agile/Work Life --&gt;
&lt;h2 id="restapis"&gt;REST/APIs&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://leanpub.com/api-extension-patterns"&gt;Handy API Extension Patterns [Leanpub PDF/iPad/Kindle]&lt;/a&gt; by Mike Amundsen&lt;/p&gt;
&lt;p&gt;&lt;a href="https://tyk.io/blog/how-do-you-futureproof-an-enterprise-api-landscape/"&gt;How do you futureproof an enterprise API landscape?&lt;/a&gt; by Tyk API Gateway&lt;/p&gt;
&lt;p&gt;&lt;a href="https://apievangelist.com/2025/05/09/governaing-api-authentication/"&gt;Governing API Authentication&lt;/a&gt; by Kin Lane&lt;/p&gt;
&lt;p&gt;&lt;a href="https://apisyouwonthate.com/blog/use-openapi-overlays-today/"&gt;Use OpenAPI Overlays Today&lt;/a&gt; by Phil Sturgeon&lt;/p&gt;
&lt;h2 id="azure"&gt;Azure&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/azure-sdk/azure-developer-cli-azd-may-2025/"&gt;Azure Developer CLI (azd) - May 2025&lt;/a&gt; by Azure SDK Blog&lt;/p&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/cosmosdb/fabric-mirroring-for-azure-cosmos-db-public-preview-refresh-now-live-with-new-features/"&gt;Fabric Mirroring for Azure Cosmos DB: Public Preview Refresh Now Live with New Features&lt;/a&gt; by Azure Cosmos DB Blog&lt;/p&gt;
&lt;h2 id="software-development"&gt;Software Development&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://blog.nimblepros.com/blogs/pull-request-etiquette/"&gt;Pull Request Etiquette&lt;/a&gt; by Scott DePouw&lt;/p&gt;
&lt;p&gt;&lt;a href="https://woodruff.dev/traits-in-rust-interfaces-that-do-more/"&gt;Traits in Rust: Interfaces That Do More&lt;/a&gt; by Chris Woody Woodruff&lt;/p&gt;
&lt;h2 id="windows"&gt;Windows&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/oldnewthing/20250508-00/?p=111162"&gt;Why doesn't Clipboard History capture rapid changes to clipboard contents?&lt;/a&gt; by The Old New Thing&lt;/p&gt;
&lt;h2 id="security"&gt;Security&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.troyhunt.com/passkeys-for-normal-people/"&gt;Passkeys for Normal People&lt;/a&gt; by Troy Hunt&lt;/p&gt;
&lt;h2 id="ai"&gt;AI&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://ashley.dev/posts/what-even-is-vibe-coding/"&gt;What Even Is Vibe Coding?&lt;/a&gt; by ashley.dev&lt;/p&gt;
&lt;p&gt;&lt;a href="https://agilepainrelief.com/blog/is-ai-making-your-organization-fragile-or-more-resilient/"&gt;Is AI Making Your Organization Fragile or More Resilient&lt;/a&gt; by Mark Levison&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/caught-i.png" class="img-fluid" alt="caught-my-i"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/things-that-caught-my-attention-last-week-may-4</id>
		<title>Things That Caught My Attention Last Week - May 4</title>
		<link href="http://blog.peterritchie.com/posts/things-that-caught-my-attention-last-week-may-4" />
		<updated>2025-05-04T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/caught-i.png" class="img-fluid" alt="caught-my-i" /&gt;&lt;/p&gt;
&lt;!-- ## Open-source --&gt;
&lt;h2 id="architecture"&gt;Architecture&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://medium.com/javarevisited/unleashing-the-power-of-event-storming-e475be7826cc"&gt;Unleashing the Power of Event Storming&lt;/a&gt; by Noah Hsu&lt;/p&gt;
&lt;p&gt;&lt;a href="https://mamund.substack.com/p/stateless-parts-stateful-wholes"&gt;Stateless Parts, Stateful Wholes&lt;/a&gt; by Mike Amundsen&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kalele.io/vaughn-vernon-on-why-the-outbox-pattern-falls-short-and-the-smarter-alternative-for-event-driven-systems/"&gt;Vaughn Vernon on Why the Outbox Pattern Falls Short – And the Smarter Alternative for Event-Driven Systems&lt;/a&gt; by Nicole Andrade&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.milanjovanovic.tech/blog/event-driven-architecture-in-dotnet-with-rabbitmq"&gt;Event-Driven Architecture in .NET with RabbitMQ&lt;/a&gt; by Milan Jovanović&lt;/p&gt;
&lt;h2 id="presenting"&gt;Presenting&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://gamma.app/"&gt;Gamma is your AI design partner for effortless presentations, websites, social media posts, and more—so you can focus on what you do best.&lt;/a&gt; by Gamma&lt;/p&gt;
&lt;h2 id="net"&gt;.NET&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://developers.redhat.com/articles/2025/04/21/c-13-advanced-features"&gt;Some more C# 13&lt;/a&gt; by Tom Deseyn&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=2EGzAPhz2nE"&gt;Turbocharged: Writing High-Performance C# and .NET Code - Steve Gordon - NDC Porto 2024&lt;/a&gt; by Steve Gordon&lt;/p&gt;
&lt;p&gt;&lt;a href="https://dotnet.github.io/dotNext/"&gt;.NEXT 5.x&lt;/a&gt; by .NEXT&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.ploeh.dk/2025/05/05/song-recommendations-as-a-c-impureim-sandwich/"&gt;Song recommendations as a C# Impureim Sandwich&lt;/a&gt; by Mark Seemann&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.duendesoftware.com/posts/20250430-managing-openapi-specifications-with-backend-for-frontend-and-swagger-ui"&gt;Managing OpenAPI Specifications with Backend For Frontend and Swagger UI&lt;/a&gt; by Khalid Abuhakmeh and Erwin van der Valk&lt;/p&gt;
&lt;p&gt;&lt;a href="https://jeremydmiller.com/2025/04/30/huge-wolverine-3-13-release/"&gt;Huge Wolverine 3.13 Release&lt;/a&gt; by Jeremy Miller&lt;/p&gt;
&lt;h2 id="domain-driven-design"&gt;Domain Driven Design&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=4UHhaOCjMgY&amp;amp;list=WL&amp;amp;index=16"&gt;How to understand almost anything - Markus Völter - DDD Europe&lt;/a&gt; by Markus Völter&lt;/p&gt;
&lt;p&gt;&lt;a href="https://vladikk.com/2025/04/05/f1-ddd/"&gt;F1 + DDD: All Models are Wrong, Some are Dangerous&lt;/a&gt; by Vlad Khononov&lt;/p&gt;
&lt;h2 id="devops"&gt;DevOps&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/devops/introducing-azure-devops-id-token-refresh-and-terraform-task-version-5/"&gt;Introducing Azure DevOps ID Token Refresh and Terraform Task Version 5&lt;/a&gt; by Jared Holgate and Eric van Wijk&lt;/p&gt;
&lt;!-- ## Design

## Mobile

## Agile/Work Life --&gt;
&lt;h2 id="restapis"&gt;REST/APIs&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://apievangelist.com/2025/05/02/api-governance-rules-from-the-netherlands/"&gt;API Governance Rules from the Netherlands&lt;/a&gt; by API Evangelist&lt;/p&gt;
&lt;!-- ## Azure --&gt;
&lt;h2 id="software-development"&gt;Software Development&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://woodruff.dev/panic-vs-exceptions-stop-the-world-or-handle-it/"&gt;Panic! vs Exceptions: Stop the World or Handle It?&lt;/a&gt; by Chris Woody Woodruff&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.prairiedevcon.com/"&gt;Prairie Dev Con Winnipeg&lt;/a&gt; by Prairie Dev Con&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sadukie.com/2025/05/04/stir-trek-2025-recap.html"&gt;Stir Trek 2025 recap&lt;/a&gt; by Sarah &amp;quot;Sadukie&amp;quot; Dutkiewicz&lt;/p&gt;
&lt;h2 id="windows"&gt;Windows&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/oldnewthing/20250505-00/?p=111143"&gt;What were the intended uses of those icons in moricons.dll?&lt;/a&gt; by Raymond Chen&lt;/p&gt;
&lt;!-- ## Security --&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/caught-i.png" class="img-fluid" alt="caught-my-i"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/things-that-caught-my-attention-last-week-april-29</id>
		<title>Things That Caught My Attention Last Week - April 29</title>
		<link href="http://blog.peterritchie.com/posts/things-that-caught-my-attention-last-week-april-29" />
		<updated>2025-04-29T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/caught-i.png" class="img-fluid" alt="caught-my-i" /&gt;&lt;/p&gt;
&lt;!-- ## Open-source

## Architecture --&gt;
&lt;h2 id="presenting"&gt;Presenting&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://sadukie.com/2025/04/23/why-i-do-both-written-content-and-videos.html"&gt;Why I Do Both Written Content and Videos&lt;/a&gt; by Sarah &amp;quot;Sadukie&amp;quot; Dutkiewicz&lt;/p&gt;
&lt;h2 id="net"&gt;.NET&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://newsletter.techworld-with-milan.com/p/why-csharp"&gt;Why C#?&lt;/a&gt; by Dr Milan Milanović&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=6KUheTnNY3M"&gt;How Does a Domain Model Serialize Itself? IT DOES NOT!&lt;/a&gt; by Zoran on C#&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=Hxfu_KEa4uA"&gt;Why is .NET so Insanely Fast? with Stephen Toub&lt;/a&gt; by Keep Coding Podcast&lt;/p&gt;
&lt;p&gt;&lt;a href="https://khalidabuhakmeh.com/server-sent-events-in-aspnet-core-and-dotnet-10"&gt;Server-Sent Events in ASP.NET Core and .NET 10&lt;/a&gt; by Khalid Abuhakmeh&lt;/p&gt;
&lt;p&gt;&lt;a href="https://medium.com/&amp;#64;davidfowl/model-run-ship-the-new-way-to-build-distributed-apps-48d67286a665"&gt;Model. Run. Ship. The New Way to Build Distributed Apps&lt;/a&gt; by David Fowler&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.duendesoftware.com/posts/20250422-authorization-policy-tag-helper-aspnetcore-razor-view/"&gt;Authorization Policy TagHelpers for ASP.NET Core Razor Views&lt;/a&gt; by Duende Software&lt;/p&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/going-beyond-singleton-scoped-and-transient-lifetimes/"&gt;Going beyond singleton, scoped, and transient lifetimes—tenant, pooled, and drifter&lt;/a&gt; by Andrew Lock | .NET Escapades&lt;/p&gt;
&lt;h2 id="domain-driven-design"&gt;Domain Driven Design&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.milanjovanovic.tech/blog/refactoring-overgrown-bounded-contexts-in-modular-monoliths"&gt;Refactoring Overgrown Bounded Contexts in Modular Monoliths&lt;/a&gt; by Milan Jovanović&lt;/p&gt;
&lt;!--## DevOps

## Design

## Mobile
--&gt;
&lt;h2 id="agilework-life"&gt;Agile/Work Life&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://reflection.ed.ac.uk/reflectors-toolkit/reflecting-on-experience/four-f"&gt;The four F's of active reviewing&lt;/a&gt; by The University of Edinburgh&lt;/p&gt;
&lt;h2 id="restapis"&gt;REST/APIs&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://mamund.substack.com/p/the-growing-medium-for-api-ecosystems"&gt;The Growing Medium for API Ecosystems - Why shared state matters more than ever&lt;/a&gt; by Mike Amundsen&lt;/p&gt;
&lt;p&gt;&lt;a href="https://apievangelist.com/2025/04/28/no-auth-on-initial-mcp-was-not-a-bug-it-was-a-feature/"&gt;No Auth on Initial MCP Was Not A Bug, It Was A Feature&lt;/a&gt; by API Evangelist (Kin Lane)&lt;/p&gt;
&lt;h2 id="software-development"&gt;Software Development&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://woodruff.dev/rust-structs-vs-c-classes-less-is-more/"&gt;Rust Structs vs C# Classes: Less is More&lt;/a&gt; by Chris Woody Woodruff&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.neowin.net/news/jetbrains-sunsets-another-product-citing-lower-than-expected-adoption-rates/"&gt;JetBrains sunsets another product citing lower than expected adoption rates&lt;/a&gt; by Neowin&lt;/p&gt;
&lt;!-- ## Windows --&gt;
&lt;h2 id="security"&gt;Security&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.howtogeek.com/how-i-lie-to-secure-my-online-accounts/"&gt;How I Secure My Online Accounts By Telling Lies&lt;/a&gt; by How-To Geek&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.theregister.com/2025/04/22/ssl_com_validation_flaw/"&gt;Bug hunter tricked SSL.com into issuing cert for Alibaba Cloud domain in 5 steps&lt;/a&gt; by The Register&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/caught-i.png" class="img-fluid" alt="caught-my-i"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/things-that-caught-my-attention-last-week-april-22</id>
		<title>Things That Caught My Attention Last Week - April 22</title>
		<link href="http://blog.peterritchie.com/posts/things-that-caught-my-attention-last-week-april-22" />
		<updated>2025-04-22T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/caught-i.png" class="img-fluid" alt="caught-my-i" /&gt;&lt;/p&gt;
&lt;!-- ## Open-source
 --&gt;
&lt;h2 id="architecture"&gt;Architecture&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://blog.wildermuth.com/2025/03/17/build-or-adopt--stop-building-your-own-plumbing/"&gt;Build or Adopt: Stop Building Your Own Plumbing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.blog/ai-and-ml/llms/what-the-heck-is-mcp-and-why-is-everyone-talking-about-it/"&gt;What the heck is MCP and why is everyone talking about it?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="devops"&gt;DevOps&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://nuke.build/"&gt;Smart automation for DevOps teams and CI/CD pipelines&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="net"&gt;.NET&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/shouldly/shouldly"&gt;Shouldy - The way assertions should be.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/module-initializers"&gt;Module Initializers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=xcpgTVueu-A"&gt;The End of .NET Free Open-Source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=s7vSG5IFn74"&gt;Test out .NET 10 Previews in Dev Containers &amp;amp; Codespaces in Minutes!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/dotnet-10-preview-3/"&gt;.NET 10 Preview 3 is now available!&lt;/a&gt;&lt;/p&gt;
&lt;!-- ## Design

## Mobile
 --&gt;
&lt;h2 id="agilework-life"&gt;Agile/Work Life&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://ronjeffries.com/articles/019-01ff/story-points/Index.html#"&gt;Story Points Revisited&lt;/a&gt;&lt;/p&gt;
&lt;!-- ## Windows

## Security
 --&gt;
&lt;h2 id="software-development"&gt;Software Development&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://woodruff.dev/ownership-in-rust-the-most-c-ish-thing-ive-loved-and-i-mean-that-in-a-good-way/"&gt;Ownership in Rust: The Most C++-ish Thing I’ve Loved (and I Mean That in a Good Way)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.conventionalcommits.org/en/v1.0.0/"&gt;Conventional Commits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://philiplaine.com/posts/getting-forked-by-microsoft/"&gt;Getting Forked by Microsoft&lt;/a&gt;&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/caught-i.png" class="img-fluid" alt="caught-my-i"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/things-that-caught-my-attention-last-week-april-14</id>
		<title>Things That Caught My Attention Last Week - April 14</title>
		<link href="http://blog.peterritchie.com/posts/things-that-caught-my-attention-last-week-april-14" />
		<updated>2025-04-14T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/caught-i.png" class="img-fluid" alt="caught-my-i" /&gt;&lt;/p&gt;
&lt;h2 id="open-source"&gt;Open-source&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/NihalJain/opensource-contributions-tracker/?tab=readme-ov-file"&gt;OpenSource Contributions Tracker&lt;/a&gt; by Nihal Jain&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.blog/open-source/maintainers/5-github-actions-every-maintainer-needs-to-know/"&gt;5 GitHub Actions every maintainer needs to know&lt;/a&gt; by Klint Finley &amp;amp; Gwen Davis&lt;/p&gt;
&lt;h2 id="architecture"&gt;Architecture&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://theburningmonk.com/2025/04/event-versioning-strategies-for-event-driven-architectures/"&gt;Event versioning strategies for event-driven architectures&lt;/a&gt; by Yan Cui&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.ploeh.dk/2025/04/01/ports-and-fat-adapters/"&gt;Ports and fat adapters&lt;/a&gt; by Mark Seemann&lt;/p&gt;
&lt;p&gt;&lt;a href="https://apievangelist.com/2025/04/09/adopting-mcp-is-a-bad-idea/"&gt;Adopting MCP is a Bad Idea&lt;/a&gt; by Kin Lane&lt;/p&gt;
&lt;h2 id="net"&gt;.NET&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://blog.duendesoftware.com/posts/20250325-understanding-antiforgery-in-aspnetcore/"&gt;Understanding Anti-Forgery in ASP.NET Core&lt;/a&gt; by Maarten Balliauw&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/core/blob/main/release-notes%2F10.0%2Fpreview%2Fpreview3%2Fcsharp.md"&gt;C# 14 updates in .NET 10 Preview 3 - Release Notes&lt;/a&gt; by various&lt;/p&gt;
&lt;p&gt;&lt;a href="https://woodruff.dev/dotnet-new-meet-cargo-new-a-tale-of-two-clis/"&gt;dotnet new, Meet cargo new: A Tale of Two CLIs&lt;/a&gt; by Chris Woody Woodruff&lt;/p&gt;
&lt;p&gt;&lt;a href="https://youtube.com/watch?v=ta08IEQcyxU"&gt;Back to Basics: Debugging in Visual Studio | Coding Shorts 117&lt;/a&gt; by Shawn Wildermuth&lt;/p&gt;
&lt;p&gt;&lt;a href="https://medium.com/&amp;#64;davidfowl/modeling-your-environment-with-aspire-24e986752485"&gt;Modeling Your Environment with Aspire&lt;/a&gt; by David Fowler&lt;/p&gt;
&lt;!--## Design

## Mobile
--&gt;
&lt;h2 id="agilework-life"&gt;Agile/Work Life&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://samestuffdifferentday.net/2025/03/24/standup-revisited/"&gt;My New Favorite Question for the Daily Standup&lt;/a&gt; by Mike Eaton&lt;/p&gt;
&lt;h2 id="windows"&gt;Windows&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.josephguadagno.net/2025/03/27/working-with-dotnet-10-without-mucking-up-your-machine"&gt;Working with dotnet 10 Without Mucking Up Your Machine&lt;/a&gt; by Joe Guadagno&lt;/p&gt;
&lt;h2 id="security"&gt;Security&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.quad9.net/"&gt;Quad9 - A public and free DNS service for a better security and privacy&lt;/a&gt;&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/caught-i.png" class="img-fluid" alt="caught-my-i"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/announcing-commandlineextensions</id>
		<title>Announcing CommandLineExtensions, a .NET DI Compatible System.CommandLine Facade</title>
		<link href="http://blog.peterritchie.com/posts/announcing-commandlineextensions" />
		<updated>2025-04-07T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/CommandLineExtensions-example.png" class="img-fluid" alt="CommandLineExtensions" /&gt;&lt;/p&gt;
&lt;h2 id="mission-inspiration"&gt;Mission, Inspiration&lt;/h2&gt;
&lt;p&gt;The mission of CommandLineExtensions is to help make command-line argument parsing simpler while leveraging Microsoft-supported &lt;code&gt;System.CommandLine&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The inspiration for CommandLineExtensions spawns from ConsoleApplicationBuilder, which makes it easier to create console applications that utilize modern .NET patterns and practices like Dependency Injection, Configuration, etc. Console applications revolve around command-line options and arguments, and more easily integrating them with modern .NET patterns and practices is essential.&lt;/p&gt;
&lt;p&gt;ConsoleApplicationBuilder is a .NET Dependency Injection (&lt;code&gt;IServiceCollection&lt;/code&gt;) extension with a fluent interface to give console application startup a similar fluent experience as other .NET frameworks. CommandLineExtensions continues that goal by providing fluent .NET Dependency Injection interface extensions to define options and arguments for console applications.&lt;/p&gt;
&lt;h2 id="why-use-commandlineextensions"&gt;Why Use CommandLineExtensions&lt;/h2&gt;
&lt;p&gt;If what ConsoleApplicationBuilder does doesn't interest you, neither will CommandLineExtensions. Without ConsoleApplicationBuilder CommandLineExtensions is just a builder pattern facade over System.CommandLine that requires a &lt;code&gt;IServiceCollection&lt;/code&gt; implementation. System.CommandLine is an established library and provides a ton of value to .NET console application developers. A builder facade that enables support for DI might only be a subtle improvement for many. I get that; I started this because it interested me.&lt;/p&gt;
&lt;p&gt;If integrating with modern .NET practices like DI, configuration, and application settings is important to you, here are some benefits of using CommandLineExtensions to define command-line options and arguments (or &amp;quot;parameters&amp;quot;):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;simplified configuration into &amp;quot;parts&amp;quot; or &amp;quot;phases&amp;quot; as contextual guardrails to enforce constraints like type safety&lt;/li&gt;
&lt;li&gt;integration with established .NET patterns and practices&lt;/li&gt;
&lt;li&gt;multi-step, piecemeal definition of command-line parameters improving readability.&lt;/li&gt;
&lt;li&gt;Semantically independent of System.CommandLine API, allowing you to focus on the configurability important to your app&lt;/li&gt;
&lt;li&gt;fluency of the interface frees you from instantiating multiple framework objects unrelated to your app&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="simple-multi-step-piecemeal-definition-of-parameters"&gt;Simple Multi-step, Piecemeal Definition of Parameters&lt;/h3&gt;
&lt;p&gt;CommandLineExtensions provides fluent interface to configure command-line parameters in a sequence of phases or steps. A simple example of configuring the root command to take a file option and configure a handler delegate. The &lt;code&gt;WithOption&lt;/code&gt; call begins a context (phase) that configures the current strongly-typed option. Within this context, the call to &lt;code&gt;WithHandler&lt;/code&gt; is strongly-typed to the single option type of &lt;code&gt;FileInfo?&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;builder.Services.AddCommand()
    .WithDescription(&amp;quot;Sample app for System.CommandLine&amp;quot;)
    .WithOption&amp;lt;FileInfo?&amp;gt;(&amp;quot;--file&amp;quot;, &amp;quot;The file to read and display on the console.&amp;quot;)
    .WithHandler(file =&amp;gt; 
    {
        ReadFile(file!);
    });
return builder.Build&amp;lt;RootCommand&amp;gt;.Invoke(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To do same thing with only System.CommandLine is possible with an explicitly instantiated &lt;code&gt;Option&amp;lt;FileInfo?&amp;gt;&lt;/code&gt; re-used in the call to &lt;code&gt;SetHandler&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var fileOption = new Option&amp;lt;FileInfo?&amp;gt;(
    name: &amp;quot;--file&amp;quot;,
    description: &amp;quot;The file to read and display on the console.&amp;quot;);

var rootCommand = new RootCommand(&amp;quot;Sample app for System.CommandLine&amp;quot;);
rootCommand.AddOption(fileOption);

rootCommand.SetHandler((file) =&amp;gt; 
    { 
        ReadFile(file!); 
    },
    fileOption);

return await rootCommand.InvokeAsync(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The phased or stepwise approach might be more apparent when dealing with multiple commands or subcommands:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = ConsoleApplication.CreateBuilder(args);
builder.Services.AddCommand() // 👈 Start root command context
	.WithSubcommand&amp;lt;ReadCommand&amp;gt;()  // 👈 start read subcommand context
		.WithArgument&amp;lt;FileInfo&amp;gt;(&amp;quot;file&amp;quot;, &amp;quot;file path to process&amp;quot;)
		.WithSubcommandHandler(file =&amp;gt; Console.WriteLine($&amp;quot;read &amp;lt;file&amp;gt; argument = {file.Name}&amp;quot;))
	.WithSubcommand&amp;lt;WriteCommand&amp;gt;()  // 👈 start write subcommand context
		.WithArgument&amp;lt;FileInfo&amp;gt;(&amp;quot;file&amp;quot;, &amp;quot;file path to process.&amp;quot;)
		.WithArgument&amp;lt;string&amp;gt;(&amp;quot;text&amp;quot;, &amp;quot;text to write to file, quoted.&amp;quot;)
		.WithSubcommandHandler((file, text) =&amp;gt; Console.WriteLine($&amp;quot;write &amp;lt;file&amp;gt; argument = {file.Name} with text '{text}'.&amp;quot;))
	.WithHandler(() =&amp;gt; Console.WriteLine(&amp;quot;Please choose read or write subcommand.&amp;quot;));

return builder.Build&amp;lt;RootCommand&amp;gt;().Invoke(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first call to &lt;code&gt;WithSubcommandHandler&lt;/code&gt; has the context of a single parameter of type &lt;code&gt;FileInfo&lt;/code&gt; and expects a delegate that takes a single argument of type &lt;code&gt;FileInfo&lt;/code&gt;. The only thing that will compile here is a delegate with a single parameter. The second independent call to &lt;code&gt;WithSubcommandHandler&lt;/code&gt; has a different context, one with two parameters: one of type &lt;code&gt;FileInfo&lt;/code&gt; and one of type &lt;code&gt;string&lt;/code&gt;. There is no way to mix up assigning a delegate to the wrong subcommand.&lt;/p&gt;
&lt;h3 id="example-dependency-injection"&gt;Example: Dependency Injection&lt;/h3&gt;
&lt;p&gt;CommandLineExtensions can do what it does through dependency injection--building up a configuration context to the point where a command is built and the required dependencies are resolved and instantiated. Put another way: all the types you use with CommandLineExtensions are resolved via the dependency injection container. If you want to use &lt;code&gt;ILogger&amp;lt;T&amp;gt;&lt;/code&gt; in a command handler, simply include it as a constructor parameter, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class LoggingCommandHandler(ILogger&amp;lt;LoggingCommandHandler&amp;gt; logger) : ICommandHandler&amp;lt;FileInfo&amp;gt;
{
    public int Execute(FileInfo fileInfo)
    {
        Console.WriteLine(
            $&amp;quot;File {fileInfo.Name} is {fileInfo.Length} bytes in size and was created on {fileInfo.CreationTime}.&amp;quot;));
        return 0;
    }
}
//...
public class Program
{
    public int Main(string[] args)
    {
        var builder = ConsoleApplication.CreateBuilder(args);
        builder.Services.AddCommand()
            .WithDescription(&amp;quot;Dependency Injection sample&amp;quot;)
            .WithOption&amp;lt;FileInfo&amp;gt;(&amp;quot;--file&amp;quot;, &amp;quot;An option whose argument is parsed as a FileInfo&amp;quot;)
            .WithHandler&amp;lt;LoggingCommandHandler&amp;gt;();
        return builder.Build&amp;lt;RootCommand&amp;gt;().Invoke(args);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A similar&lt;super&gt;*&lt;/super&gt; thing in System.CommandLine would require code like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Program
{
    public int Main(string[] args)
    {
        var fileOption = new Option&amp;lt;FileInfo?&amp;gt;(
            name: &amp;quot;--file&amp;quot;,
            description: &amp;quot;An option whose argument is parsed as a FileInfo&amp;quot;);

        var rootCommand = new RootCommand(&amp;quot;Dependency Injection sample&amp;quot;);
        rootCommand.Add(fileOption);

        rootCommand.SetHandler((fileOptionValue, logger) =&amp;gt;
            {
                DoRootCommand(fileOptionValue!, logger);
            },
            fileOption, new MyCustomBinder());

        rootCommand.Invoke(args);

        return 0;
    }
    static void DoRootCommand(FileInfo aFile, ILogger logger)
    {
        Console.WriteLine($&amp;quot;File = {aFile?.FullName}&amp;quot;);
        logger.LogCritical(&amp;quot;Test message&amp;quot;);
    }
}

public class MyCustomBinder : BinderBase&amp;lt;ILogger&amp;gt;
{
    protected override ILogger GetBoundValue(
        BindingContext bindingContext) =&amp;gt; GetLogger(bindingContext);

    ILogger GetLogger(BindingContext bindingContext)
    {
        using ILoggerFactory loggerFactory = LoggerFactory.Create(
            builder =&amp;gt; builder.AddConsole());
        ILogger logger = loggerFactory.CreateLogger(&amp;quot;LoggerCategory&amp;quot;);
        return logger;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;*: &lt;code&gt;ILogger&amp;lt;T&amp;gt;&lt;/code&gt; injection is accomplished, but without using Microsoft.Extensions.DependencyInjection.&lt;/p&gt;
&lt;h2 id="caveats"&gt;Caveats&lt;/h2&gt;
&lt;p&gt;This is an MVP to gauge interest and to get feedback. It's functional, but minimal in a few ways.&lt;/p&gt;
&lt;h3 id="limited-optionsarguments"&gt;Limited Options/Arguments&lt;/h3&gt;
&lt;p&gt;Parameters are limited to two per command. Two is much lower than the System.CommandLine's limit of eight. Support for more than two will be added in the near future.&lt;/p&gt;
&lt;h3 id="default-value-factories"&gt;Default Value Factories&lt;/h3&gt;
&lt;p&gt;Default value factories are not supported. System.CommandLine supports default values for options via a factory method, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var fileOption = new Option&amp;lt;FileInfo?&amp;gt;(
    name: &amp;quot;--file&amp;quot;,
    description: &amp;quot;An option whose argument is parsed as a FileInfo&amp;quot;);
fileOption.SetDefaultValueFactory(() =&amp;gt; $&amp;quot;{DateTime.Now:MMMM}&amp;quot;); // 👈 delegate to create a new value
var rootCommand = new RootCommand(&amp;quot;Do something with a file.&amp;quot;);
rootCommand.Add(fileOption);

rootCommand.SetHandler(fileOptionValue =&amp;gt;
    {
        Console.WriteLine($&amp;quot;Received {fileOptionValue} for file name.&amp;quot;);
    },
    fileOption);

return rootCommand.Invoke(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Default values for options &lt;em&gt;are&lt;/em&gt; supported.  For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = ConsoleApplication.CreateBuilder(args);
builder.Services.AddCommand()
    .WithOption&amp;lt;FileInfo?&amp;gt;(&amp;quot;--file&amp;quot;, &amp;quot;An option whose argument is parsed as a FileInfo&amp;quot;)
    .WithDefault($&amp;quot;{DateTime.Now:MMMM}&amp;quot;) // 👈 create default value here
    .WithHandler(fileOptionValue =&amp;gt;
        {
            Console.WriteLine($&amp;quot;Received {fileOptionValue} for file name.&amp;quot;);
        });
return builder.Build&amp;lt;RootCommand&amp;gt;.Invoke(args);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The vision is that CommandLineExtensions be very loosely coupled to System.CommandLine--in most cases, it is coupled only to &lt;em&gt;concepts&lt;/em&gt; (like &lt;em&gt;by name&lt;/em&gt;--sometimes referred to as Connascence of Name). Toward that vision, the CommandLineExtensions fluent interface doesn't use System.CommandLine types directly, so there is no way to use pre-defined types like closed-generic types implementing &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;. I've considered that, and if you feel that's important, please thumb up this issue: &lt;a href="https://github.com/peteraritchie/ConsoleApplicationBuilder/issues/13"&gt;&lt;code&gt;Consider supporting Option&amp;lt;T&amp;gt;-derived types.&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="getting-started"&gt;Getting Started&lt;/h2&gt;
&lt;p&gt;Getting started with CommandLineExtensions is very easy. It begins with either creating a console application with ConsoleApplicationBuilder dotnet new template or adding the ConsoleApplicationBuilder NuGet package to an existing console application. (For more information, please see &lt;a href="https://blog.peterritchie.com/posts/announcing-consoleapplicationbuilder"&gt;Announcing ConsoleApplicationBuilder, DI in console applications, simply&lt;/a&gt;.) Then add the &lt;a href="https://www.nuget.org/packages/PRI.CommandLineExtensions"&gt;PRI.CommandLineExtensions&lt;/a&gt; NuGet package.&lt;/p&gt;
&lt;p&gt;Configuring command-line parameters starts by adding a command; if you don't have a &amp;quot;command,&amp;quot; the implied command is a &lt;em&gt;root command&lt;/em&gt; added with the bare &lt;code&gt;AddCommand()&lt;/code&gt; extension method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = ConsoleApplication.CreateBuilder(args);
builder.Services.AddCommand() // 👈 step 1, configure a command
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, you can start adding options (named parameters) or arguments (unnamed parameters). For example, if you want to accept a required file name on the command-line with a command-line option of &lt;code&gt;--file&lt;/code&gt;, you could do this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = ConsoleApplication.CreateBuilder(args);
builder.Services.AddCommand()
    .WithRequiredOption&amp;lt;FileInfo&amp;gt;(&amp;quot;--file&amp;quot;, &amp;quot;file path to process&amp;quot;) // 👈 step 2, add an option
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, you need to configure what you want to process the parameter value with--a command handler:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = ConsoleApplication.CreateBuilder(args);
builder.Services.AddCommand()
    .WithRequiredOption&amp;lt;FileInfo&amp;gt;(&amp;quot;--file&amp;quot;, &amp;quot;file path to process&amp;quot;)
    .WithHandler(fileInfo =&amp;gt; // 👈 step 3, configure the handler, accepting the parameter value
        Console.WriteLine(
            $&amp;quot;File {fileInfo.Name} is {fileInfo.Length} bytes in size and was created on {fileInfo.CreationTime}.&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Configuring a handler completes the configuration of that command.&lt;/p&gt;
&lt;p&gt;And finally, you build or resolve the command and execute it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var builder = ConsoleApplication.CreateBuilder(args);
builder.Services.AddCommand()
    .WithRequiredOption&amp;lt;FileInfo&amp;gt;(&amp;quot;--file&amp;quot;, &amp;quot;file path to process&amp;quot;)
    .WithHandler(fileInfo =&amp;gt;
        Console.WriteLine(
            $&amp;quot;File {fileInfo.Name} is {fileInfo.Length} bytes in size and was created on {fileInfo.CreationTime}.&amp;quot;));
return builder.Build&amp;lt;RootCommand&amp;gt;().Invoke(args); // 👈 step 4, invoke the handler with the command-line arguments
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;CommandLineExtensions creates a fluent interface for System.CommandLine, offering a simpler way to define and support command-line options and arguments. CommandLineExtensions doesn't support all the features of System.CommandLine but provides support for defining command-line options and arguments for all but very complex scenarios.&lt;/p&gt;
&lt;p&gt;For more information and examples, please see &lt;a href="https://github.com/peteraritchie/ConsoleApplicationBuilder/blob/main/src/CommandLineExtensions/README.md"&gt;CommandLineExtensions README.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;For support, please see &lt;a href="https://github.com/peteraritchie/ConsoleApplicationBuilder/issues"&gt;ConsoleApplicationBuilder GitHub issues&lt;/a&gt;&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/CommandLineExtensions-example.png" class="img-fluid" alt="CommandLineExtensions"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/announcing-consoleapplicationbuilder</id>
		<title>Announcing ConsoleApplicationBuilder, DI in console applications, simply</title>
		<link href="http://blog.peterritchie.com/posts/announcing-consoleapplicationbuilder" />
		<updated>2025-01-17T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/announcing-ConsoleApplicationBuilder.png" class="img-fluid" alt="Configurable Console Application" /&gt;&lt;/p&gt;
&lt;p&gt;A recent interaction reminded me that using things like &lt;code&gt;IServiceCollection&lt;/code&gt; to get dependency injection or &lt;code&gt;ConfigurationManager&lt;/code&gt; to use appsettings.json and &lt;code&gt;IOptions&amp;lt;T&amp;gt;&lt;/code&gt; in a .NET console application is a lot of work. You can use things like &lt;a href="https://learn.microsoft.com/en-us/dotnet/core/extensions/workers"&gt;console worker project&lt;/a&gt;, but if you're implementing a simple console application, a background process seems over the top and unnatural.&lt;/p&gt;
&lt;p&gt;I've added DI and configuration to console applications in the past, but it has always been troublesome and problematic. I had considered just documenting that process but thought the amount of work to simply create a NuGet package to do it for me seemed like it was about the same amount of work. A couple of weeks ago I started creating &lt;code&gt;ConsoleApplicationBuilder&lt;/code&gt;—a type that implements similar functionality to &lt;code&gt;WebApplicationBuilder&lt;/code&gt; and &lt;code&gt;HostApplicationBuilder&lt;/code&gt; (that &lt;code&gt;WebApplicationBuilder&lt;/code&gt; leverages). This post announces the result of that effort.&lt;/p&gt;
&lt;p&gt;TL;DR: &lt;code&gt;ConsoleApplicationBuilder&lt;/code&gt; and the associated &lt;code&gt;dotnet new&lt;/code&gt; project template enable the use of DI in console applications simply and succinctly:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;class Program(ILogger&amp;lt;Program&amp;gt; logger)
{
    static void Main(string[] args)
    {
        var builder = ConsoleApplication.CreateBuilder(args);
        var program = builder.Build&amp;lt;Program&amp;gt;();
        program.Run();
    }

    private void Run()
    {
        logger.LogInformation(&amp;quot;Hello, World!&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ConsoleApplicationBuilder&lt;/code&gt; is open-source and available on &lt;a href="https://github.com/peteraritchie/ConsoleApplicationBuilder"&gt;GitHub&lt;/a&gt;; you can find similar details there.&lt;/p&gt;
&lt;p&gt;What prompted my latest foray into DI in a non-background console application was to inject a configured &lt;code&gt;HttpClient&lt;/code&gt; into the application. &lt;code&gt;ConsoleApplicationBuilder&lt;/code&gt; supports this easily and naturally:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;class Program(ILogger&amp;lt;Program&amp;gt; logger, HttpClient httpClient)
{
    static async Task Main(string[] args)
    {
        var builder = ConsoleApplication.CreateBuilder(args);
        builder.Services.AddHttpClient&amp;lt;Program&amp;gt;(httpClient =&amp;gt;
        {
            httpClient.BaseAddress = new Uri(&amp;quot;https://jsonplaceholder.typicode.com&amp;quot;);
        });
        var program = builder.Build&amp;lt;Program&amp;gt;();
        await program.Run();
    }

    private async Task Run()
    {
        logger.LogInformation(&amp;quot;Hello, World!&amp;quot;);
        logger.LogInformation(await httpClient.GetStringAsync(&amp;quot;todos/3&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="dotnet-new-project-template"&gt;&lt;code&gt;dotnet new&lt;/code&gt; Project Template&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;dotnet new consoleapp&lt;/code&gt; project template supports appsettings out of the box and is installed like other &lt;code&gt;dotnet new&lt;/code&gt; project templates:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet new install PRI.ConsoleApplicationBuilder.Templates
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And to create a new console application that supports DI, Configuration, appsettings, etc., is as simple as:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;dotnet new consoleapp -o Peter.ConsoleApp
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="consoleapplicationbuilder-without-dotnet-new-consoleapp-project-template"&gt;&lt;code&gt;ConsoleApplicationBuilder&lt;/code&gt; Without &lt;code&gt;dotnet new consoleapp&lt;/code&gt; Project Template&lt;/h2&gt;
&lt;p&gt;When I implemented the &lt;code&gt;dotnet new consoleapp&lt;/code&gt; project template, I wanted to make the created &lt;code&gt;Program&lt;/code&gt; class as simple as possible, so I chose to re-use the Program class and build an instance of that class to inject services like &lt;code&gt;ILogger&amp;lt;Program&amp;gt;&lt;/code&gt;. However, you don't need to use the template to use &lt;code&gt;ConsoleApplicationBuilder&lt;/code&gt;, and you don't need to re-use &lt;code&gt;Program&lt;/code&gt; as the type that it will build. You can add a reference to the &lt;code&gt;PRI.ConsoleApplicationBuilder&lt;/code&gt; NuGet package and build a different type. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;class Program
{
    static async Task Main(string[] args)
    {
        var builder = ConsoleApplication.CreateBuilder(args);
        builder.Services.AddHttpClient&amp;lt;ToDoAdapter&amp;gt;(httpClient =&amp;gt;
        {
	        httpClient.BaseAddress = new Uri(&amp;quot;https://jsonplaceholder.typicode.com&amp;quot;);
        });
        var adapter = builder.Build&amp;lt;ToDoAdapter&amp;gt;();
		var todoText = await adapter.GetToDo(1);
	}
}

internal sealed class ToDoAdapter(ILogger&amp;lt;ToDoAdapter&amp;gt; logger, HttpClient httpClient)
{
	public async Task&amp;lt;string&amp;gt; GetToDo(int id)
	{
		if(logger.IsEnabled(LogLevel.Information))
		{
			logger.LogInformation(&amp;quot;Getting todo with id {Id}&amp;quot;, id);
		}
		var response = await httpClient.GetAsync($&amp;quot;todos/{id}&amp;quot;);
		response.EnsureSuccessStatusCode();
		string responseText = await response.Content.ReadAsStringAsync();
		if (logger.IsEnabled(LogLevel.Information))
		{
			logger.LogInformation(&amp;quot;Got response {ResponseText}&amp;quot;, responseText);
		}
		return responseText;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, instead of building a &lt;code&gt;Program&lt;/code&gt; instance, we're building a &lt;code&gt;ToDoAdapter&lt;/code&gt; instance that is injected with a configured logger and an specific HTTP client. Be sure to also add a reference to &lt;code&gt;Microsoft.Extensions.Http&lt;/code&gt; if you want to use that code.&lt;/p&gt;
&lt;p&gt;So, as you can see, &lt;code&gt;ConsoleApplicationBuilder&lt;/code&gt; is very flexible.&lt;/p&gt;
&lt;h2 id="feedback"&gt;Feedback&lt;/h2&gt;
&lt;p&gt;I'd love to hear your feedback, good or bad. I've modeled &lt;code&gt;ConsoleApplicationBuilder&lt;/code&gt; as closely as possible to &lt;code&gt;WebApplicationBuilder&lt;/code&gt; and &lt;code&gt;HostApplicationBuilder&lt;/code&gt; so it follows their conventions, and usage should feel natural. But I'm open to suggestions on how to improve it. You can log questions and issues on &lt;a href="https://github.com/peteraritchie/ConsoleApplicationBuilder/issues"&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/announcing-ConsoleApplicationBuilder.png" class="img-fluid" alt="Configurable Console Application"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/working-with-dto-auto-translators--mapperly</id>
		<title>Working With DTO Auto Translators -- Mapperly</title>
		<link href="http://blog.peterritchie.com/posts/working-with-dto-auto-translators--mapperly" />
		<updated>2024-11-07T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/mapping-translation.png" class="img-fluid" alt="Complicated translation" /&gt;&lt;/p&gt;
&lt;!-- Mapping/Translation series intro boilerplate --&gt;
&lt;p&gt;Modern software applications heavily rely on external services, making data transfer a crucial aspect of application functionality. Invariably, data transfer involves translating an internal representation of information to data compatible with a particular communication channel. High-level programming languages empower programmers to model abstractions in high-level types independent of lower-level implementation details. This internal representation of data is sometimes called &lt;em&gt;abstract syntax&lt;/em&gt;, which is purposely devoid of the specifics (&lt;em&gt;concrete syntax&lt;/em&gt;) required by the channel and, or the receiver. Translation from one syntax to another must first map source data elements to target data elements. That mapping includes the necessary translation method/function.&lt;/p&gt;
&lt;!-- Data Transfer Object boilerplate pull quote/box copy --&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Data Transfer Objects&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Defining concrete syntax in high-level languages is so essential that a design pattern is devoted to it. The Data Transfer Object&lt;sup&gt;[&lt;a href="https://amzn.to/3SR8c73"&gt;ppoe&lt;/a&gt;]&lt;/sup&gt; design pattern describes declaring high-level types to describe aspects of concrete syntax.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;This installment details the mapping and translation of Data Transfer Objects with a package named &lt;a href="https://github.com/riok/mapperly"&gt;&lt;code&gt;Mapperly&lt;/code&gt;&lt;/a&gt; (&lt;a href="https://www.nuget.org/packages/Riok.Mapperly/"&gt;Riok.Mapperly&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Mapperly accomplishes translation by being a .NET Source Generator, meaning the translation code is generated and exists when your application is compiled. The translation code, therefore, does not need to jump through a bunch of hoops by evaluating expressions and dynamically generating types and methods. Being a Source Generator makes Mapperly pleasantly different from other mappers like AutoMapper and Mapster. You have to declare the intent to translate from one type to another by declaring a partial method (in a partial class decorated with the &lt;code&gt;MapperAttribute&lt;/code&gt;) that tells Mapperly what the source and destination types are (the method that returns the &lt;em&gt;destination&lt;/em&gt; type and accepts the &lt;em&gt;source&lt;/em&gt; type as an argument.) The name of the class method is up to you. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Mapper]
public partial class AccountTranslator
{
	public partial AccountDto AccountToAccountDto(Account account);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mapperly determines how to translate each property based on their names and types (the default &lt;em&gt;convention&lt;/em&gt;). In our simple case, it would generate a method similar to:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;{
    public partial class AccountTranslator
    {
        [global::System.CodeDom.Compiler.GeneratedCode(&amp;quot;Riok.Mapperly&amp;quot;, &amp;quot;4.1.0.0&amp;quot;)]
        public partial global::MapperlyTests.Application.AccountDto AccountToAccountDto(global::MapperlyTests.Domain.Account account)
        {
            var target = new global::MapperlyTests.Application.AccountDto();
            target.Id = account.Id;
            target.Name = account.Name;
            target.CreationDate = account.CreationDate;
            return target;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mapperly supports immutable record types, so if you wanted to use &lt;code&gt;record&lt;/code&gt; with &lt;code&gt;AccountDto&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public record AccountDto(Guid Id, DateOnly CreationDate, string Name);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And with those immutable record types Mapperly will generate code that passes arguments to the constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;        [global::System.CodeDom.Compiler.GeneratedCode(&amp;quot;Riok.Mapperly&amp;quot;, &amp;quot;4.1.0.0&amp;quot;)]
        public partial global::MapperlyTests.Application.AccountDto AccountToAccountDto(global::MapperlyTests.Domain.Account account)
        {
            var target = new global::MapperlyTests.Application.AccountDto(account.Id, account.CreationDate, account.Name);
            return target;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Say goodbye to &lt;code&gt;ConstructUsing&lt;/code&gt; (as well as &lt;code&gt;ForMember&lt;/code&gt;, et al.)&lt;/p&gt;
&lt;h2 id="mapping-by-convention"&gt;Mapping by Convention&lt;/h2&gt;
&lt;p&gt;The raison d'etre of mapping/translation frameworks is to make translating one data type to another as simple as possible. A key feature of these frameworks is to map by convention, which automatically maps fields or properties based on criteria like name and data type. As we can see from the generated code above, Mapperly, by convention, figures out the source and target properties to translate. What's nice about Mapperly is that you can see the results of applying that convention by looking at the generated code (Ctrl-click the &lt;code&gt;partial&lt;/code&gt; method name to go to the generated code.)&lt;/p&gt;
&lt;h2 id="custom-mapping"&gt;Custom Mapping&lt;/h2&gt;
&lt;p&gt;When we start (greenfield) development, our DTOs are usually closely aligned with our domain objects, so by-convention mapping is our friend. However, an important reason for having two abstractions is that they can evolve independently. Eventually, as we gain a better understanding of the domain or clients of the communication channel, we will need to make changes that cause our DTO and Domain Objects to diverge. We can manage that divergence by extending the by-convention mapping to include custom mapping on a per-property basis. Mapperly supports this through members of the &lt;code&gt;Mapper&lt;/code&gt;-decorated class.&lt;/p&gt;
&lt;p&gt;For example, we've gained a better understanding of the domain, and an Account doesn't necessarily have a &amp;quot;name&amp;quot; but has an associated account holder with a given and family name. That understanding may make its way into the domain like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Account(Guid id, DateOnly creationDate, string accountHolderGivenName, string accountHolderFamilyName)
{
	public Guid Id { get; } = id;
	public string AccountHolderGivenName { get; private set; } = accountHolderGivenName;
	public string AccountHolderFamilyName { get; private set; } = accountHolderFamilyName;
	public DateOnly CreationDate { get; } = creationDate;

	public void ChangeName(string accountHolderGivenName, string accountHolderFamilyName)
	{
		AccountHolderGivenName = accountHolderGivenName;
		AccountHolderFamilyName = accountHolderFamilyName;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Receivers of our &lt;code&gt;AccountDto&lt;/code&gt; might be unable to accommodate that change immediately, so we may deal with that by mapping properties differently. Instead of including &lt;code&gt;FamilyName&lt;/code&gt; and &lt;code&gt;GivenName&lt;/code&gt; in this version of &lt;code&gt;AccountDto&lt;/code&gt;, we may concatenate the given and family name and assign it to &lt;code&gt;AccountDto.Name&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can configure this type of two properties to one property conversion with the &lt;code&gt;MapPropertyFromSource&lt;/code&gt; attribute. More than just the name of the two properties is needed for Mapperly to automatically figure out what to do (concatenate, concatenate with delimiter, etc.). So, we use &lt;code&gt;MapPropertyFromSource&lt;/code&gt; to point to a method that takes the source type and returns an instance of a type assignable to the destination property.  In this example, a &lt;code&gt;MapGivenFamilyNames&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Mapper]
public partial class AccountTranslator
	: IAccountTranslator
{
	[MapPropertyFromSource(target: nameof(AccountDto.Name), Use = nameof(MapGivenFamilyNames))]
	public partial AccountDto AccountToAccountDto(Account account);
	private string MapGivenFamilyNames(Account account)
	{
		return account.AccountHolderGivenName + ' ' + account.AccountHolderFamilyName;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mapperly supports arrays of strings for &lt;code&gt;target&lt;/code&gt; so you can map to nested properties of properties.&lt;/p&gt;
&lt;p&gt;Mapperly also supports property-to-property mapping of properties that a simple matching strategy wouldn't match.  Given the same client application constraints and the domain understanding uncovered that the &lt;code&gt;Name&lt;/code&gt; property doesn't fit in the ubiquitous language but &lt;code&gt;FullName&lt;/code&gt; does, we would use &lt;code&gt;MapPropertyAttribute&lt;/code&gt; to tell Mapperly how to assign the &lt;code&gt;AccountDto.Name&lt;/code&gt; property:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Mapper]
public partial class AccountTranslator
	: IAccountTranslator
{
	[MapProperty(source: nameof(AccountDto.Name), target: nameof(Account.FullName))]
	public partial AccountDto AccountToAccountDto(Account account);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;NOTE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;The constructor for &lt;code&gt;MapPropertyFromSourceAttribute&lt;/code&gt; has only one parameter, the &lt;code&gt;target&lt;/code&gt;.  The constructor for &lt;code&gt;MapPropertyAttribute&lt;/code&gt; has two, the &lt;code&gt;source&lt;/code&gt; and the &lt;code&gt;target&lt;/code&gt;, so it &lt;em&gt;may look like&lt;/em&gt; the parameters are in a different order. C#'s &lt;em&gt;named arguments&lt;/em&gt; shines here to clarify intent.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Technically, attributes like &lt;code&gt;MapPropertyFromSourceAttribute&lt;/code&gt; and &lt;code&gt;MapPropertyAttribute&lt;/code&gt; work with string names of classes and members. Use the &lt;code&gt;name of&lt;/code&gt; expression so that identifiers get used at compile-time, as seen in the above example.&lt;/p&gt;
&lt;h2 id="but-wait-theres-more"&gt;But Wait, There's More&lt;/h2&gt;
&lt;p&gt;A benefit of being a Source Generator is that Mapperly can generate compiler/analyzer warnings when not all properties are mapped from or to.  If you're following along and you updated &lt;code&gt;Account&lt;/code&gt;, renaming &lt;code&gt;Name&lt;/code&gt; to &lt;code&gt;FullName&lt;/code&gt;, you would have noticed RMG020 and RMG012 warnings:&lt;/p&gt;
&lt;p&gt;&lt;img src="../assets/mapperly-unmapped-member-warning.png" class="img-fluid" alt="RMG020 and RMG012 warnings" /&gt;&lt;/p&gt;
&lt;h2 id="dependency-injections-with-mapperly"&gt;Dependency Injections with Mapperly&lt;/h2&gt;
&lt;p&gt;Other mappers have initialization and startup requirements making their use in Dependency Injection more than just registering an implementation of an interface (&lt;code&gt;services.AddScoped&amp;lt;ITheInterface, TheImplementation&amp;gt;();&lt;/code&gt;) and require an &lt;code&gt;Add{Technology}()&lt;/code&gt; method call (like &lt;code&gt;AddMapster&lt;/code&gt; or &lt;code&gt;AddAutoMapper&lt;/code&gt;.) Since Mapperly generates the translation code at compilation, you only have to register the translating type (e.g., &lt;code&gt;services.AddScoped&amp;lt;AccountTranslator&amp;gt;()&lt;/code&gt;) and declare the dependency in the constructors of types that need to invoke translators (e.g., &lt;code&gt;public class AccountService(AccountTranslator accountTranslator){/*...*/}&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;If you're interface-obsessed when it comes to Dependency Injection, you're free to create an interface to use and configure your services appropriately, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IAccountTranslator
{
	public AccountDto AccountToAccountDto(Account account);
}
//...
[Mapper]
public partial class AccountTranslator
	: IAccountTranslator
{
	public partial AccountDto AccountToAccountDto(Account account);
}
//...
services.AddScoped&amp;lt;IAccountTranslator, AccountTranslator&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then declare the dependency in the constructors of types that need to invoke translators (e.g., &lt;code&gt;public class AccountService(IAccountTranslator accountTranslator){/*...*/}&lt;/code&gt;.)&lt;/p&gt;
&lt;h2 id="where-does-mapping-and-translation-occur"&gt;Where Does Mapping and Translation Occur?&lt;/h2&gt;
&lt;p&gt;Data transfer can occur in different layers. Data transfer triggers a website or API (presentation layer); the application layer requests external services via an infrastructure layer to transfer data to and from. I'm often asked where that mapping and translation source code should exist and in which project in the solution. It's important to remember that we're dealing with multiple layers. The presentation layer is typically where the process entry point is, so initialization (DI container configuration) occurs here. That initialization depends at least indirectly on the translation code to configure services that perform the translation.&lt;/p&gt;
&lt;p&gt;Translation of web/API models exist in the presentation layer because that's where &lt;em&gt;that&lt;/em&gt; data transfer occurs. It can get complex when more layers are in their own project or are their own artifact. I recommend that DTOs live in the project where the data transfer occurs because they should be viewed as an implementation detail of the facade/adapter performing the data transfer. This typically means that the translation codes lives along side the DTOs because you want to keep implementation details encapsulated. The translation should be made available through an interface that is configured by your Dependency Injection container. I'll leave the complexity of doing that in the context of project-scoped layers for another post.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;NOTE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;Regardless of whether you have multiple presentation layers or an independent application layer, translation logic &lt;em&gt;should not&lt;/em&gt; be a responsibility in the Domain layer.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/mapping-translation.png" class="img-fluid" alt="Complicated translation"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/naming-things--generic-actions</id>
		<title>Naming things: Actions</title>
		<link href="http://blog.peterritchie.com/posts/naming-things--generic-actions" />
		<updated>2024-10-24T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/overwhelming-possibilities.png" class="img-fluid" alt="Overwhelming Possibilities" /&gt;&lt;/p&gt;
&lt;p&gt;A few years ago, I decided to look into &lt;em&gt;why&lt;/em&gt; naming is hard. That spawned a conference talk that I've done several times. Part of what I present in that talk is my observations of working with many teams regarding establishing names for generic actions applicable in their unique domain.&lt;/p&gt;
&lt;h2 id="actions-activities-operations-events-occurrences-oh-my"&gt;Actions, Activities, Operations, Events, Occurrences, Oh My&lt;/h2&gt;
&lt;p&gt;Generic actions have many synonyms. Without considering different words to mean the same thing, the names of things in the code related to generic actions added a noticeable cognitive load to the initial understanding of the domain. Let's look at what I mean by &lt;em&gt;generic actions&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In a domain, things &lt;em&gt;happen&lt;/em&gt; to domain objects. Many of these actions can be considered &amp;quot;updates,&amp;quot; but it's more fine-grained. For example, here's a table of some verbs that could mean some sort of &lt;em&gt;update&lt;/em&gt; in most domains:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;Add     Create   Generate  Build   Construct  Initialize  Make    Establish
Update  Change   Modify    Mutate  Alter      Revise      Adjust  Transform
Delete  Destroy  Remove    Erase   Move       Release     Pull    Withdraw
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It's extremely unlikely that there are 24 distinct mutating actions in any domain. Most domains work on a CRUD model where, besides Read, there are &lt;code&gt;Create&lt;/code&gt;, &lt;code&gt;Update&lt;/code&gt;, and &lt;code&gt;Delete&lt;/code&gt;. Unfortunately, three mutating actions are typically too coarse-grained and can be unrepresentative of the domain language.&lt;/p&gt;
&lt;p&gt;Spending a short time creating a happy medium is valuable: making a brief list of the terms used for the generic domain actions. The list should be imperative verbs that can be (or are) transitive (that is, they can refer to an object. e.g., &amp;quot;arrive&amp;quot; is a verb that cannot be transitive).&lt;/p&gt;
&lt;p&gt;Once there is agreement on the generic actions that apply to the domain, establishing a similar list of events further increases value. That list should be the action verbs in past participle form. For example, if &amp;quot;create&amp;quot; is an action in the domain, then the event that describes it would be the past participle form of &amp;quot;create&amp;quot;: &amp;quot;created.&amp;quot;&lt;/p&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;p&gt;Each domain is unique, so make sure these terms work for yours.&lt;/p&gt;
&lt;h3 id="actions"&gt;Actions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Create&lt;/code&gt;&lt;/strong&gt; - to bring something into existence. Contrast with Add. See also &lt;code&gt;Destroy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Add&lt;/code&gt;&lt;/strong&gt; - to add something (already created) to a container or collection. See also &lt;code&gt;Remove&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Update&lt;/code&gt;&lt;/strong&gt; - to change the value of one or properties of an object. Contrast with &lt;code&gt;Change&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Change&lt;/code&gt;&lt;/strong&gt; - to replace an entire instance with another instance.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Delete&lt;/code&gt;&lt;/strong&gt; - to remove access to something in some context. Contrast with &lt;code&gt;Destroy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Destroy&lt;/code&gt;&lt;/strong&gt; - to eliminate something from existence, the opposite of Create. Contrast with &lt;code&gt;Delete&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Remove&lt;/code&gt;&lt;/strong&gt; - to remove something from a container or collection, the opposite of Add. Contrast with &lt;code&gt;Delete&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Modify&lt;/code&gt;&lt;/strong&gt; - to modify the structure or schema of something. Contrast with &lt;code&gt;Update&lt;/code&gt; and &lt;code&gt;Change&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This list should be a stretch for most domains. Many domains don't have a concept of &lt;em&gt;modifying&lt;/em&gt; schema or &lt;em&gt;changing&lt;/em&gt; instances. Further still, I have found that most domains either &lt;code&gt;Delete&lt;/code&gt; or &lt;code&gt;Destroy&lt;/code&gt; data. This leaves &lt;code&gt;Create&lt;/code&gt;, &lt;code&gt;Delete&lt;/code&gt;, &lt;code&gt;Add&lt;/code&gt;, &lt;code&gt;Remove&lt;/code&gt;, and &lt;code&gt;Update&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Remember that this example list is designed to be generic--actions not likely to be domain-specific. In your ubiquitous language, you will still have other terms to refer to domain-specific actions. e.g., you may &lt;code&gt;Correct&lt;/code&gt; an Address in the domain to signify an &lt;code&gt;Update&lt;/code&gt; or &lt;code&gt;Change&lt;/code&gt; to an Address to differentiate it from a &lt;code&gt;Move&lt;/code&gt; concept. Or a domain might have a &lt;code&gt;Restore&lt;/code&gt; behavior as a specialized type of &lt;code&gt;Update&lt;/code&gt; or &lt;code&gt;Change&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I recommend establishing a similar list of event names that is effectively the same list of verbs for the actions but in past participle form:&lt;/p&gt;
&lt;h3 id="events"&gt;Events&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Created&lt;/code&gt;&lt;/strong&gt; - something was brought into existence. Contrast with &lt;code&gt;Added&lt;/code&gt;. See also &lt;code&gt;Destroyed&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Added&lt;/code&gt;&lt;/strong&gt; - something (already created) was added to a container or collection. See also &lt;code&gt;Removed&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Updated&lt;/code&gt;&lt;/strong&gt; - the value of one or properties of an object was changed. Contrast with &lt;code&gt;Changed&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Changed&lt;/code&gt;&lt;/strong&gt; - an entire instance was replaced with another instance.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Deleted&lt;/code&gt;&lt;/strong&gt; - access to something was removed in some context. Contrast with &lt;code&gt;Destroyed&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Destroyed&lt;/code&gt;&lt;/strong&gt; - something was eliminated from existence, the opposite of &lt;code&gt;Created&lt;/code&gt;. Contrast with &lt;code&gt;Deleted&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Removed&lt;/code&gt;&lt;/strong&gt; - something was removed from a container or collection, the opposite of &lt;code&gt;Added&lt;/code&gt;. Contrast with &lt;code&gt;Deleted&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Modified&lt;/code&gt;&lt;/strong&gt; - the structure or schema of something was modified. Contrast with &lt;code&gt;Updated&lt;/code&gt; and &lt;code&gt;Changed&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This list of events could be similarly optimized as &lt;code&gt;Created&lt;/code&gt;, &lt;code&gt;Deleted&lt;/code&gt;, &lt;code&gt;Added&lt;/code&gt;, &lt;code&gt;Removed&lt;/code&gt;, and &lt;code&gt;Updated&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;My experience has been that establishing and communicating lists like these work well in avoiding ambiguity and establishing clarity. Most domains are complex, but clarifying the names of generic actions can make a noticeable difference in understandability and approachability. I've even found that this level of attention to naming makes the code base more agile.&lt;/p&gt;
&lt;p&gt;In the comments, I'd love to hear what generic actions apply to your domain if these don't apply.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/overwhelming-possibilities.png" class="img-fluid" alt="Overwhelming Possibilities"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/avoiding-identity-obsession-in-dotnet-with-entity-framework-core</id>
		<title>Avoiding Identity Obsession in .NET with Entity Framework Core</title>
		<link href="http://blog.peterritchie.com/posts/avoiding-identity-obsession-in-dotnet-with-entity-framework-core" />
		<updated>2024-10-01T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/technological-layers.png" class="img-fluid" alt="Complicated translation" /&gt;&lt;/p&gt;
&lt;p&gt;In a &lt;a href="identity-obsession-and-domain-driven-design"&gt;previous post&lt;/a&gt;, I introduced Identity Obsession. Identity Obsession can introduce race conditions relating to consistency with Domain Entities and other complexity. In that post, I point out that most entities have an inherent (implicit) local identity and that any additional global Identifiers are due to persistence (RDBMS) implementation details. I recommended that Identifiers be something in your persistence layer rather than your Domain layer. I won't rehash that post more than that here, but you may want to read that first.&lt;/p&gt;
&lt;p&gt;It can be perceived as &lt;em&gt;easy for me to say&lt;/em&gt; when it comes to design constraints of Aggregates and Entities when implementing the persistence layer. This perception is probably most apparent with technologies like Entity Framework Core (EF) and that Entity Framework's support for Domain-Driven Design has been an afterthought. When dealing with external sources and targets of data, the Data Transfer Object pattern is recommended. Technically, EF supports persistence via DTOs.&lt;/p&gt;
&lt;p&gt;Entity Framework can rarely do what it does out-of-the-box, provided classes are designed with a Domain-Driven Design mindset. Impedance Mismatch rears its ugly head resulting in translating data to/from the limited data types that databases tend to have (see &lt;code&gt;HasConversion&lt;/code&gt;, &lt;code&gt;HasKey&lt;/code&gt;, et al.) Despite best practices that recommend that Entities be implemented as POCOs and relational mapping be configured with fluent builders—outside of the Domain Layer—the needs and constraints of databases can easily leak into the design and evolution of Domain Objects.&lt;/p&gt;
&lt;p&gt;In this post, I will provide an example of configuring Entity Framework to work with Domain Objects that don't suffer from Identity Obsession. The scenario (or use-case) I'll show with this Domain Object is onboarding a Client to the point they will have a Domain Identifier assigned. The Domain I introduced in my previous post involved SSNs; we can presume the Social Security Administration would be the Domain context. I'm sure none of my readers work in this context, but I believe it to be understandable by many people, making it a good example of Domain Identity. For my Canadian friends, replace &amp;quot;SSN&amp;quot; with &amp;quot;SIN&amp;quot; and &amp;quot;Social Security Administration&amp;quot; with &amp;quot;Service Canada.&amp;quot;&lt;/p&gt;
&lt;p&gt;Entity Framework is a persistence/infrastructure implementation detail, and the Repository Pattern is used to isolate those details from the Domain. I gave an example repository in my previous post; for this example, I've expanded it to support asynchronous and the Result Pattern:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IClientRepository
{
    Task&amp;lt;Result&amp;lt;Client&amp;gt;&amp;gt; FindBySsnAsync(Ssn ssn, CancellationToken cancellationToken);
    Task&amp;lt;Result&amp;gt; SaveAsync(Client client, CancellationToken cancellationToken);
    Task&amp;lt;Result&amp;lt;Ssn&amp;gt;&amp;gt; AddAsync(Client client, CancellationToken cancellationToken);
	Task&amp;lt;Result&amp;lt;IEnumerable&amp;lt;Client&amp;gt;&amp;gt;&amp;gt; FindClientsAsync(CancellationToken cancellationToken);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This Repository provides the ability to find a Client by SSN (&lt;code&gt;FindBySsnAsync&lt;/code&gt;), save a &lt;code&gt;Client&lt;/code&gt; after being updated (&lt;code&gt;SaveAsync&lt;/code&gt;), and add a new &lt;code&gt;Client&lt;/code&gt; by allocating a new SSN (&lt;code&gt;AddAsync&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;Elements within a container naturally have container Identity. The container understands how to identify individual elements based on an identifier. Contained elements, therefore, do not also have to take on that burden. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Client(string givenName, string familyName)
    : Person(givenName, familyName)
{
    public void ChangeName(string givenName, string familyName)
    {
        GivenName = givenName;
        FamilyName = familyName;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I've expanded &lt;code&gt;Client&lt;/code&gt; to support an update scenario (&lt;code&gt;ChangeName&lt;/code&gt;) so that there is Domain behavior.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Quote&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&amp;quot;All models are wrong, but some are useful&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The use-case of working with a Domain Object (&lt;code&gt;Client&lt;/code&gt;) before needing an SSN to be persisted might follow a sequence like this:&lt;/p&gt;
&lt;p&gt;&lt;img src="../assets/onboarding-client-use-case.png" class="img-fluid" alt="sequence" /&gt;&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;Client&lt;/code&gt; instance exists for a time before a Domain Identifier is allocated for it. However, our database requires an SSN for each client record. So, we need to configure Entity Framework to accommodate that detail and include a primary key. We do that through an &lt;code&gt;IEntityTypeConfiguration&amp;lt;T&amp;gt;&lt;/code&gt; implementation like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class ClientEntityTypeConfiguration : IEntityTypeConfiguration&amp;lt;Client&amp;gt;
{
    public void Configure(EntityTypeBuilder&amp;lt;Client&amp;gt; builder)
    {
        // Create a string &amp;quot;Id&amp;quot; Shadow Property to hold GUID values
        builder.Property&amp;lt;string&amp;gt;(ColumnNames.Id)
            .HasColumnType(&amp;quot;varchar(36)&amp;quot;)
            .HasMaxLength(36);
        builder.HasKey(ColumnNames.Id);

        // Create a string &amp;quot;Ssn&amp;quot; Shadow Property that uses the type Sss,
        // with conversion
        builder.Property&amp;lt;Ssn&amp;gt;(ColumnNames.Ssn)
            .HasColumnType(&amp;quot;varchar(11)&amp;quot;)
            .HasMaxLength(11)
            .HasConversion(ssn =&amp;gt; ssn.ToString(), value =&amp;gt; Ssn.Parse(value))
            .IsRequired();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As with any &lt;code&gt;IEntityTypeConfiguration&amp;lt;T&amp;gt;&lt;/code&gt; implementation, we're configuring the primary key and other properties with property-specific requirements. This implementation may differ from other implementations because we're configuring &lt;em&gt;shadow properties&lt;/em&gt; for our identifiers. The &lt;code&gt;DbContext&lt;/code&gt; implementation will be responsible for the persistence concern of generating the primary key value, and the repository will be responsible for the Domain concern of generating the Domain Identifier (SSN).&lt;/p&gt;
&lt;p&gt;Let's look at that &lt;code&gt;DbContext&lt;/code&gt; implementation (I'm using SQLite for this implementation):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DatabaseContext : DbContext
{
	protected override void OnModelCreating(ModelBuilder modelBuilder)
	{
		modelBuilder.ApplyConfiguration(new ClientEntityTypeConfiguration());

		base.OnModelCreating(modelBuilder);
	}

	public async Task&amp;lt;Result&amp;lt;Client&amp;gt;&amp;gt; GetClientBySsnAsync(Ssn ssn, CancellationToken cancellationToken)
	{
		var client = await Clients
			.SingleOrDefaultAsync(c =&amp;gt; EF.Property&amp;lt;Ssn&amp;gt;(c, ColumnNames.Ssn) == ssn, cancellationToken);

		return client ?? Result&amp;lt;Client&amp;gt;.NotFound();
	}

	public async Task&amp;lt;Result&amp;lt;Client&amp;gt;&amp;gt; GetClientByIdAsync(Guid id, CancellationToken cancellationToken)
	{
		var client = await Clients
			.SingleOrDefaultAsync(c =&amp;gt; EF.Property&amp;lt;string&amp;gt;(c, ColumnNames.Id) == id.ToString(), cancellationToken);

		return client ?? Result&amp;lt;Client&amp;gt;.NotFound();
	}

	public Result&amp;lt;Ssn&amp;gt; GetClientSsn(Client client)
	{
		var entry = Entry(client);
		var currentValue = entry.Property(ColumnNames.Ssn).CurrentValue as Ssn;

		return currentValue ?? Result&amp;lt;Ssn&amp;gt;.NotFound();
	}

	public async Task AddClientAsync(Client client, Ssn ssn, CancellationToken cancellationToken)
	{
		var entry = Entry(client);
		entry.Property(ColumnNames.Ssn).CurrentValue = ssn;
		entry.Property(ColumnNames.Id).CurrentValue = Guid.NewGuid().ToString();
		await AddAsync(client, cancellationToken);

		await SaveChangesAsync(cancellationToken);
	}
	public DbSet&amp;lt;Client&amp;gt; Clients { get; set; }

	protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
	{
		optionsBuilder.UseSqlite($&amp;quot;Data Source={DataSourcePath}&amp;quot;);
	}

	public static string DataSourcePath {
		get
		{
			var localAppDataPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
			return Path.Join(localAppDataPath, &amp;quot;clients.db&amp;quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notable is &lt;code&gt;AddClientAsync&lt;/code&gt;, where it accepts an &lt;code&gt;Ssn&lt;/code&gt; value, sets the shadow property value for that database column, and generates the primary key by calling &lt;code&gt;Guid.NewGuid()&lt;/code&gt;. &lt;code&gt;DatabaseContext&lt;/code&gt; encapsulates the implementation detail of shadow properties. I've chosen to generate a&lt;code&gt;Guid&lt;/code&gt; in code rather than by the database for clarity. As a database concern, it could go either way. Also notable is the method &lt;code&gt;GetClientSsn&lt;/code&gt;, which shows how an SSN can be obtained outside the Domain (e.g., for Presentation concerns.)&lt;/p&gt;
&lt;p&gt;Next, let's look at an implementation of &lt;code&gt;IClientRepository&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class ClientRepository(DatabaseContext dbContext, ISsnRegistry ssnRegistry) : IClientRepository
{
	private readonly DatabaseContext dbContext = dbContext;
	private readonly ISsnRegistry ssnRegistry = ssnRegistry;

	public Task&amp;lt;Result&amp;lt;IEnumerable&amp;lt;Client&amp;gt;&amp;gt;&amp;gt; FindClientsAsync(CancellationToken _)
	{
		Result&amp;lt;IEnumerable&amp;lt;Client&amp;gt;&amp;gt; result = dbContext.Clients;
		return Task.FromResult(result);
	}

	public Task&amp;lt;Result&amp;lt;Client&amp;gt;&amp;gt; FindBySsnAsync(Ssn ssn, CancellationToken cancellationToken)
	{
		return dbContext.GetClientBySsnAsync(ssn, cancellationToken);
	}

	public async Task&amp;lt;Result&amp;lt;Ssn&amp;gt;&amp;gt; AddAsync(Client client, CancellationToken cancellationToken)
	{
		var reservationResult = ssnRegistry.Reserve();
		if (reservationResult.IsError()) return Result&amp;lt;Ssn&amp;gt;.Error();

		using var ssnReservation = reservationResult.Value;
		Ssn newSsn = new(ssnReservation.Value);
		await dbContext.AddClientAsync(client, newSsn, cancellationToken);
		await dbContext.SaveChangesAsync(cancellationToken);
		ssnReservation.Commit();
		return newSsn;
	}

	public async Task&amp;lt;Result&amp;gt; SaveAsync(Client client, CancellationToken cancellationToken)
	{
		var entry = dbContext.Entry(client);
		switch (entry.State)
		{
			case EntityState.Detached:
				{
					var addResult = await AddAsync(client, cancellationToken);
					return addResult.IsSuccess
						? Result.Success()
						: Result.CriticalError(addResult.Errors.ToArray());
				}
			case EntityState.Modified:
				await dbContext.SaveChangesAsync(cancellationToken);
				return Result.Success();
			default:
				return Result.Success();
		}
	}

	public Result&amp;lt;Ssn&amp;gt; GetClientSsn(Client client)
	{
		return dbContext.GetClientSsn(client);
	}

	public Task&amp;lt;Result&amp;lt;Client&amp;gt;&amp;gt; FindByIdAsync(Guid id, CancellationToken cancellationToken)
	{
		return dbContext.GetClientByIdAsync(id, cancellationToken);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since the primary key and the SSN storage is a Persistence concern, the &lt;code&gt;DbContext&lt;/code&gt; implementation is where the logic to work with Shadow Properties lives.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SaveAsync&lt;/code&gt; and &lt;code&gt;FindBySsnAsync&lt;/code&gt; simply encapsulate &lt;code&gt;DbContext.SaveChangesAsync&lt;/code&gt; and &lt;code&gt;DatabaseContext.GetClientBySsnAsync&lt;/code&gt; respectively. &lt;code&gt;FindClientsAsync&lt;/code&gt; finds all the client instances (typically, this would have a filter, which I've omitted for clarity.) SSN allocation is outside the scope of this post. But, because SSN allocation is a Domain concern, I'll show where it might fit in an orchestration with &lt;code&gt;DatabaseContext&lt;/code&gt; within &lt;code&gt;AddAsync&lt;/code&gt; (using a fictitious &lt;code&gt;ISsnRegistry&lt;/code&gt; object that manages generating/reserving then committing an SSN value--completing/committing the reserved value if it is successfully persisted to the database.) I've included &lt;code&gt;GetClientSsn&lt;/code&gt; as an example of how an SSN can be obtained outside the Domain (e.g., for Presentation concerns.) Also, I've included &lt;code&gt;FindByIdAsync&lt;/code&gt; as an example of how we can find a &lt;code&gt;Client&lt;/code&gt; instance based on a primary key value.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Caveat&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;Storing SSNs in a database is frowned upon. This example is for clarity, the value should be hashed or encrypted before storing in the database. Look ups based on last-four &amp;amp; name are beyond the scope of this post&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;Entity Framework makes mapping Entity properties to columns in a relational database easy. But don't let that ease of use let Persistence concerns leak into your Domain. With a clear understanding of what Domain concerns are, what Persistence concerns are, and what Presentation concerns are Entity Framework can easily be leveraged to support loosely coupling the Persistence concerns from Entities.&lt;/p&gt;
&lt;p&gt;The code from this post can be found in &lt;a href="https://github.com/peteraritchie/IdentityObsession"&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/technological-layers.png" class="img-fluid" alt="Complicated translation"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/identity-obsession-and-domain-driven-design</id>
		<title>Identity Obsession and Domain-Driven Design</title>
		<link href="http://blog.peterritchie.com/posts/identity-obsession-and-domain-driven-design" />
		<updated>2024-09-26T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/mind-map.png" class="img-fluid" alt="Complicated translation" /&gt;&lt;/p&gt;
&lt;p&gt;Domain-Driven Design builds on established ontological concepts like Identity, Entities, and characteristics. Entities in either context are constructs with &lt;em&gt;Identity&lt;/em&gt;. Entities are recognizable instances of higher-level classifications. Entities are recognized not just by their characteristics or qualities. Ontologically, an Entity's Identity can be numerical &lt;em&gt;or&lt;/em&gt; philosophical. In software, explicit Identity is always implemented &lt;em&gt;numerically&lt;/em&gt; (that is, an Identifier that is compared by value.) In either context, Identity can be &lt;em&gt;implicit&lt;/em&gt; or &lt;em&gt;explicit&lt;/em&gt;, too often explicit in software.&lt;/p&gt;
&lt;p&gt;Domain-Driven Design categorizes Identity as either &lt;em&gt;global&lt;/em&gt; or &lt;em&gt;local&lt;/em&gt;. I have found that too often, only global Identity is implemented or recognized—which may be due to the explicitness of global Identity. I have also observed the over-use of Identity (explicit and global.) I'm calling this phenomenon &amp;quot;Identity Obsession,&amp;quot; I'll explain it by comparing it to what helped inspire it: Primitive Obsession.&lt;/p&gt;
&lt;p&gt;There's a code smell called Primitive Obsession&lt;sup&gt;[&lt;a href="https://amzn.to/3Y05vTq"&gt;Refactoring&lt;/a&gt;]&lt;/sup&gt;, where domain-specific concepts are implemented in object-oriented languages as primitive (or built-in) types instead of custom types. Domain concepts are domain concepts because they are unique to a domain, so it's unlikely they would be on parity with anything in another, independent, domain; especially a technical concept like an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;. Primitive Obsession exists to help recognize that a custom type is necessary embody unique constraints over and above any implementation details of a primitive type.&lt;/p&gt;
&lt;p&gt;Like Primitive Obsession, &lt;em&gt;Identity Obsession&lt;/em&gt; occurs due to the influence of implementation details. In the case of Identity Obsession, those implementation details are typically &lt;em&gt;the possibility&lt;/em&gt; of an RDBMS being involved.&lt;/p&gt;
&lt;p&gt;But first, let's align on &lt;em&gt;Identity&lt;/em&gt; in Domain-Driven Design. Something has an Identity when you can differentiate it from something beyond its qualities or attributes. The obsession is that &lt;em&gt;implemented&lt;/em&gt; Domain Objects are given a globally unique Identifier (as opposed to locally unique) that habitually manifests as an &lt;code&gt;Id&lt;/code&gt; property on the Domain Object's implementation. It's not uncommon for me to see &lt;em&gt;modeled&lt;/em&gt; Domain Objects (i.e., abstract concepts) given a globally unique Identifier attribute—that is, modeled to include a value with unique characteristics (auto-incrementing or universally unique) at a time when implementation details are yet to be considered.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Identity Obsession&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;All Entities are modeled with an Identifier and all implemented Entities have a public &lt;code&gt;Id&lt;/code&gt; property whether they are necessary or not&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;It's important to remember that one, Domain Objects can be differentiated from one another by more than an assignable property, and two, Domain Objects may have more than one Identity. Arguably, not all Identities are that of the &lt;em&gt;Domain Object&lt;/em&gt; (and others are the Identity of a DTO or the database row), but that's another symptom of the obsession. Let's look at a Domain Identity.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Note&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;An Entity doesn't need to differentiate itself from another instance of an Entity, it knows who it is&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;In many domains, an Entity called &amp;quot;Account&amp;quot; exists. Abstractly, it has a Domain-specific Identity used within the domain to identify one physical account from another. The type and value of that Identifier depends on the domain—typically, it's textual and has format/structure rules. Social Security Numbers, for example, have a textual structure of &lt;code&gt;123-45-6789&lt;/code&gt; (&amp;quot;textual&amp;quot;, not &amp;quot;string&amp;quot; to avoid Primitive Obsession).&lt;/p&gt;
&lt;p&gt;A Domain-specific Identity is a part of the Domain whether there are technical implementations related to that Domain or not. Upon recognition or observance of that Identity, it becomes part of the Ubiquitous Language and independent of implementation details and constraints. The Identifier of the Domain Identity is sometimes not used as the implemented Identifier. That Identifier value has unique characteristics in technical solutions within the Domain, but that doesn't mean that the Domain Identifier is also the technical solution's unique Identifier. When implementing storage, there are many reasons why I don't want the Domain Identifier to be the &lt;em&gt;primary key&lt;/em&gt; and I would choose another value and probably a different primitive type for the implementation, like a UUID/GUID. Similarly, when implementing an API, I may not want to use an SSN within a URI or the primary key from the storage implementation. In this case, there are three &lt;em&gt;concrete Identifiers&lt;/em&gt; for the one abstract concept.&lt;/p&gt;
&lt;p&gt;Both Entities and Value Objects can have Identity. As Domain-Driven Design practitioners, it's ingrained in us that an Entity has Identity and that often manifests as an &lt;code&gt;Id&lt;/code&gt; property on an Entity implementation. But it shouldn't be that way. As a &lt;em&gt;global&lt;/em&gt; Identity, it should not be managed by the Entity to which it is assigned. The Identity is meaningless within the implementation class of an Entity. Identity is a higher-level concept from the concept it applies to. Something needs to manifest an &lt;em&gt;Identifier&lt;/em&gt; and an Entity must be consistent upon creation, so the Entity itself cannot be responsible for creating its own Identifier. The &lt;em&gt;Identifier&lt;/em&gt; is in fact an implementation detail. Management of that Identifier is typically the responsibility of a service, often a Repository service since that's when global Identity is required.&lt;/p&gt;
&lt;p&gt;An Entity that requires an Identifier upon creation (and to thus be always consistent) in an object oriented language needs that Identifier to be passed in during construction or calculated within the Entity during construction. In the first scenario, instantiation of an Entity is now coupled to something responsible for the generation of Identifiers.  In the second scenario the Entity implementation has taken on too much responsibility. At best case it implements an algorithm for generating a globally unique Identifier.  At worst case it has to take on responsibility of the Identity semantics, like rules, validation, etc. Let's look at a naive example of an Entity that uses an SSN as an Identifier;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Client : Person
{
    public Client(string givenName, string familyName, Ssn ssn)
        : base(givenName, familyName)
    {
        Ssn = ssn;
    }
    public Client(string givenName, string familyName, ISsnGenerator ssnGenerator)
        : base(givenName, familyName)
    {
        Ssn = ssnGenerator.Generate();
    }

    public Ssn Ssn { get; }
}
//...
public interface IClientRepository
{
    void Save(Client client);
    Result&amp;lt;Client&amp;gt; FindBySsn(Ssn ssn);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Constructing a &lt;code&gt;Client&lt;/code&gt; instance is problematic with either of these constructors. One problem is the life of an SSN. What if an instantiation of a Client doesn't need to be persisted or is destroyed before it gets persisted? SSNs are a limited resource and need to be accounted for. We can't reserve one by generating it and not release it if it never gets used. We &lt;em&gt;could&lt;/em&gt; expand on this to include something silly like an &lt;code&gt;ISsnManager&lt;/code&gt; but now &lt;code&gt;Client&lt;/code&gt; needs to understand when it does or does not get persisted. This can't accommodate exceptional situations where a &lt;code&gt;Client&lt;/code&gt; instance is destroyed without warning. This implemented behavior is equivalent of a domain that allows residents of the USA to create and assign their own SSNs. Can you imagine the problems this would create? One may say that this is unique to SSNs and you wouldn't have this problem with &lt;code&gt;Guid&lt;/code&gt;s. This is a naive point of view due to a perception that it's safe to throw away GUID values due to an implementation detail. There are multiple race conditions between when an new &lt;code&gt;Client&lt;/code&gt; exists and when they are persisted to the system. Because of that reality, and that Repositories aren't Factories, the only solution is the &lt;code&gt;Client&lt;/code&gt; class not to have an SSN property:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Client(string givenName, string familyName)
    : Person(givenName, familyName);
//...
public interface IClientRepository
{
    Result&amp;lt;Ssn&amp;gt; Save(Client client);
    Result&amp;lt;Client&amp;gt; FindBySsn(Ssn ssn);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this implementation, SSN generation is deferred until a &lt;code&gt;Client&lt;/code&gt; is persisted in the system. If the destruction of a &lt;code&gt;Client&lt;/code&gt; occurs before being persisted, the system generates no SSN, and the release of the SSN is no longer an issue. The implementation of SSN generation and persistence still needs to account for failure, but that can handled &lt;em&gt;transactionally&lt;/em&gt; and that responsibility can live where it belongs, outside of the Domain. SSN generation is still a domain concept, but how an allocated value is transactionally assigned is an implementation detail of the chosen infrastructure.&lt;/p&gt;
&lt;p&gt;This implement doesn't impose SSN be a primary key, this implementation simply recognizes SSN as a Domain Identifier. Implementation details within the infrastructure are free to use another Identifier for a primary key—if that applies at all in the chosen infrastructure.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Note&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;Nested objects implicitly have Identifiers that are field or property names.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="implicit-local-domain-identifiers"&gt;Implicit Local Domain Identifiers&lt;/h2&gt;
&lt;p&gt;Another aspect of Identity Obsession is the failure to recognize implicit local Identity, which is most common with Aggregates. The idea behind Aggregates is that it is a group of Domain Objects considered a unit with unit-wide consistency requirements. Similar to our Client SSN example, because an Aggregate is a consistency boundary, operations on the Aggregate become part of a &lt;em&gt;transaction&lt;/em&gt;. Entities composed within an Aggregate are implementation details accessible only through the interface provided by the Aggregate. Those Entities are owned by the Aggregate, meaning the Aggregate controls their lifecycle, including their construction and assignment of an Identifier. The transaction race conditions also arise with Aggregates: global Identifiers are meaningless until the Aggregate is persisted. That is, an Entity with global Identity made available as a property of an Aggregate is problematic due to those race conditions I mentioned earlier. You can't reliably realize global Identity until the Aggregate is persisted, but the Aggregate still needs to differentiate all the Domain Objects it owns. This means owned Domain Objects have &lt;em&gt;local Identity&lt;/em&gt;.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Note&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;Because the Entities within an Aggregate are an implementation detail, Entities within the Aggregate have Identity local to the Aggregate&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The Aggregate still needs to differentiate the objects it owns, properties, fields, or indexes are &lt;em&gt;implicitly&lt;/em&gt; the Identifiers of Entities assigned to them, &lt;em&gt;local&lt;/em&gt; to the Aggregate. Imagine the quintessential e-commerce Domain that has order and order line Domain Objects. In this domain, order lines have no meaning outside of an order. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void CreateDeveloperToolsOrder(IOrderRepository repository)
{
    var order = new Order();
    order.AddItem(&amp;quot;Visual Studio 2022&amp;quot;, 667.00m);
    order.AddItem(&amp;quot;ReSharper&amp;quot;, 1, 139.00m);
    order.AddItem(&amp;quot;NDepend&amp;quot;, 1, 492.00m);
    order.AddItem(&amp;quot;LINQPad&amp;quot;, 1, 65.00m);
    var firstItem = order.OrderLines.ElementAt(0);
    order.RemoveItem(0);
    var orderNumber = repository.Save(order);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--|Note|
|:-:|
|Entities owned by an Aggregate must appear like Value Objects within the interface of the Aggregate|--&gt;
&lt;p&gt;The resulting &lt;code&gt;Order&lt;/code&gt; instance comprises three &lt;code&gt;OrderLine&lt;/code&gt; Entities. &lt;code&gt;OrderLine&lt;/code&gt; Identity is the index of that instance in the &lt;code&gt;OrderLines&lt;/code&gt; collection—a local identity. Until the call to &lt;code&gt;RemoveItem&lt;/code&gt;, the Identity of the &lt;code&gt;Visual Studio Professional 2022&lt;/code&gt; order line was &lt;code&gt;0&lt;/code&gt;. Since &lt;code&gt;Visual Studio Professional 2022&lt;/code&gt; was removed before &lt;code&gt;Save&lt;/code&gt; was invoked, the local Identifier of &lt;code&gt;0&lt;/code&gt; was the only Identifier that was ever required of it. Since order item Identity is local to an order, &lt;code&gt;OrderItem&lt;/code&gt; implements no Identity:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public record OrderLine(string ProductName, float Quantity, decimal Price)
{
    public float Quantity { get; private set; } = Quantity;
    public decimal Price { get; private set; } = Price;
    public string ProductName { get; private set; } = ProductName;

    public void ChangePrice(decimal price)
    {
        Price = price;
    }
    public void ChangeQuantity(float quantity)
    {
        Quantity = quantity;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Note&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;Global Identifiers required only for persistence should be an implementation detail of the Repository, not the Entity.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="recognizing-identity-obsession"&gt;Recognizing Identity Obsession&lt;/h2&gt;
&lt;h3 id="domain-objects-described-with-an-id-characteristic-or-attribute"&gt;Domain Objects Described With an “ID” Characteristic or Attribute&lt;/h3&gt;
&lt;p&gt;I have found it rare that Domain Identity manifests as a concept named &amp;quot;ID.&amp;quot; For example, an &lt;em&gt;account&lt;/em&gt; typically has an Account Number Identifier, not an &amp;quot;ID&amp;quot; in banking. The Account Number &lt;em&gt;is&lt;/em&gt; an &amp;quot;ID&amp;quot;, but the Domain does not use that term (and should not be part of the Ubiquitous Language.) If you run across descriptions of Domain Objects that use the term &amp;quot;ID&amp;quot; or &amp;quot;Id&amp;quot; you can avoid or remedy Identity Obsession by asking the Domain experts questions to get clarity.&lt;/p&gt;
&lt;h3 id="entities-implemented-with-an-id-property"&gt;Entities implemented with an &lt;code&gt;Id&lt;/code&gt; property&lt;/h3&gt;
&lt;p&gt;Entity implementations may include an &lt;code&gt;Id&lt;/code&gt; property if descriptions of the underlying Domain Object include an &amp;quot;ID&amp;quot; characteristic or attribute. If the underlying Domain Object description does not include an &amp;quot;ID&amp;quot; attribute and the Entity implementation has an &lt;code&gt;Id&lt;/code&gt; property, you've probably discovered Identity Obsession. The Entity implementation should mirror the Domain Object's Identity terminology. If it's unclear, asking questions of the Domain experts will result in clarity.&lt;/p&gt;
&lt;h2 id="take-aways"&gt;Take Aways&lt;/h2&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Take Away&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;Isolate Identity and Identifiers from Entities&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Identity Obsession is the compulsion that every Domain Entity is described and implemented with a global Identifier. Global Identifiers are too frequently an implementation detail relating to a relational database. You can improve the implementation and gain deeper insight into the Domain by classifying Identities and treating them as independent Domain concepts. Identity as a separate domain concept enables you to isolate Identity and Identifiers from Entities so that an Entity is standalone and not complicated by the constraints of Identity.&lt;/p&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wiki.c2.com/?PrimitiveObsession"&gt;Primitive Obsession&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://amzn.to/3Y05vTq"&gt;Refactoring: Improving the Design of Existing Code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/mind-map.png" class="img-fluid" alt="Complicated translation"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/working-with-dto-auto-translators--mapster</id>
		<title>Working With DTO Auto Translators -- Mapster</title>
		<link href="http://blog.peterritchie.com/posts/working-with-dto-auto-translators--mapster" />
		<updated>2024-08-26T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/mapping-translation.png" class="img-fluid" alt="Complicated translation" /&gt;&lt;/p&gt;
&lt;!-- Mapping/Translation series intro boilerplate --&gt;
&lt;p&gt;Modern software applications heavily rely on external services, making data transfer a crucial aspect of application functionality. Invariably, data transfer involves translating an internal representation of information to data compatible with a particular communication channel. High-level programming languages empower programmers to model abstractions in high-level types independent of lower-level implementation details. This internal representation of data is sometimes called &lt;em&gt;abstract syntax&lt;/em&gt;, which is purposely devoid of the specifics (&lt;em&gt;concrete syntax&lt;/em&gt;) required by the channel and, or the receiver. Translation from one syntax to another must first map source data elements to target data elements. That mapping includes the necessary conversion method.&lt;/p&gt;
&lt;!-- Data Transfer Object boilerplate pull quote/box copy --&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Data Transfer Objects&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Defining concrete syntax in high-level languages is so essential that a design pattern is devoted to it. The Data Transfer Object&lt;sup&gt;[&lt;a href="https://amzn.to/3SR8c73"&gt;ppoe&lt;/a&gt;]&lt;/sup&gt; design pattern describes declaring high-level types to describe aspects of concrete syntax.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;This installment details the mapping and translation of Data Transfer Objects with a package named &lt;a href="https://github.com/MapsterMapper/Mapster"&gt;Mapster&lt;/a&gt; (&lt;a href="https://www.nuget.org/packages/Mapster.DependencyInjection"&gt;&lt;code&gt;Mapster.DependencyInjection&lt;/code&gt;&lt;/a&gt;).&lt;/p&gt;
&lt;h2 id="translation"&gt;Translation&lt;/h2&gt;
&lt;p&gt;Mapster makes translation available in several ways. Because this post details a solution with dependency injection, I'll be focusing on injecting an &lt;code&gt;IMapper&lt;/code&gt; (&lt;code&gt;MapsterMapper.IMapper&lt;/code&gt;) object where translation is required rather than the generated &lt;code&gt;TDestination Adapt&amp;lt;TSource, TDestination&amp;gt;(this TSource source)&lt;/code&gt; methods.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Opinion&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;I don't like thinking of this type of translation as an adaptation (i.e., as an Adapter Pattern implementation) because this isn't adapting one interface to another; it's raw data translation. As &amp;quot;&lt;code&gt;Adapt&lt;/code&gt;&amp;quot; alludes to mapping and translation being two different actions, I don't like the method that performs translation being named &amp;quot;&lt;code&gt;Map&lt;/code&gt;.&amp;quot; But &lt;a href="https://bit.ly/naming-things-repo"&gt;Naming is Hard&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Mapster generates classes with &lt;code&gt;Adapt&lt;/code&gt; methods at compile-time, so they're as fast as coding them by hand. The above method of invoking &lt;code&gt;Adapt&lt;/code&gt; doesn't generate code you can browse to in the IDE, but it's still pre-generated.&lt;/p&gt;
&lt;p&gt;Given a domain object of &lt;code&gt;Account&lt;/code&gt; and a Data Transfer Object &lt;code&gt;AccountDto&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Account(Guid id, DateOnly creationDate, string name)
{
	public Guid Id { get; } = id;
	public string Name { get; private set; } = name;
	public DateOnly CreationDate { get; } = creationDate;

	public void ChangeName(string name)
	{
		Name = name;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class AccountDto
{
	public Guid Id { get; set; }
	public string Name { get; set; }
	public DateOnly CreationDate { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mapster generates code to translate to/from &lt;code&gt;Account&lt;/code&gt;/&lt;code&gt;AccountDto&lt;/code&gt; so that you just need to inject an &lt;code&gt;IMapper&lt;/code&gt; and invoke the &lt;code&gt;IMapper.Map&amp;lt;TSource, TDestination&amp;gt;&lt;/code&gt; method. &lt;code&gt;AddMapster(this IServiceCollection serviceCollection)&lt;/code&gt; is used to add &lt;code&gt;IMapper&lt;/code&gt; to services.&lt;/p&gt;
&lt;h2 id="mapping-by-convention"&gt;Mapping by Convention&lt;/h2&gt;
&lt;p&gt;The raison d'etre of mapping/translation frameworks is to make translating one data type to another as simple as possible. A key feature of these frameworks is to map by convention, which automatically maps fields or properties based on criteria like name and data type. Mapster does an excellent job of mapping by convention. In the above example, you don't have to tell Mapster anything. It knows that &lt;code&gt;Account.Id&lt;/code&gt; maps to &lt;code&gt;AccountDto.Id&lt;/code&gt;, and &lt;code&gt;Account.Name&lt;/code&gt; maps to &lt;code&gt;AccountDto.Name&lt;/code&gt;, and &lt;code&gt;Account.CreationDate&lt;/code&gt; maps to &lt;code&gt;AccountDto.CreationDate&lt;/code&gt; because the properties have the same name and type.&lt;/p&gt;
&lt;p&gt;Explicit mapping isn't necessary. Simply injecting an &lt;code&gt;IMapper&lt;/code&gt; instance and invoking &lt;code&gt;IMapper.Map&amp;lt;TSource, TDestination&amp;gt;&lt;/code&gt; is enough to map th two type's properties by convention&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class CreateAccountCommandHandler(IMapper mapper, INotificationService notificationService)
	: IRequestHandler&amp;lt;CreateAccountCommand&amp;gt;
{
	private readonly IMapper mapper = mapper;

	public async Task Handle(CreateAccountCommand request, CancellationToken cancellationToken)
	{
		Guid accountId = Guid.NewGuid();
		Account account = CreateAccount(accountId);

		var dto = mapper.Map&amp;lt;Account, AccountDto&amp;gt;(account);

		await notificationService.PublishAsync(new AccountCreated(dto), cancellationToken);
	}
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="custom-mapping"&gt;Custom Mapping&lt;/h2&gt;
&lt;p&gt;When we start (greenfield) development, our DTOs are usually closely aligned with our domain objects, so by-convention mapping is our friend. However, an important reason for having two abstractions is that they can evolve independently. Eventually, as we gain a better understanding of the domain or clients of the communication channel, we will need to make changes that cause our DTO and Domain Objects to diverge. We can manage that divergence by extending the by-convention mapping to include custom mapping. Mapster supports this through what it calls registers or via &lt;code&gt;Register&lt;/code&gt; methods. Mapster can be told to scan for Register methods and perform custom mapping automatically.&lt;/p&gt;
&lt;p&gt;For example, we've gained a better understanding of the domain, and an Account doesn't necessarily have a &amp;quot;name&amp;quot; but has an associated account holder with a given and family name. That understanding may make its way into the domain like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Account(Guid id, DateOnly creationDate, string accountHolderGivenName, string accountHolderFamilyName)
{
	public Guid Id { get; } = id;
	public string AccountHolderGivenName { get; private set; } = accountHolderGivenName;
	public string AccountHolderFamilyName { get; private set; } = accountHolderFamilyName;
	public DateOnly CreationDate { get; } = creationDate;

	public void ChangeName(string accountHolderGivenName, string accountHolderFamilyName)
	{
		AccountHolderGivenName = accountHolderGivenName;
		AccountHolderFamilyName = accountHolderFamilyName;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Receivers of our &lt;code&gt;AccountDto&lt;/code&gt; might be unable to accommodate that change immediately, so we may deal with that by mapping properties differently. Instead of including FamilyName and GivenName in AccountDto, we may concatenate the given and family name and assign it to &lt;code&gt;AccountDto.Name&lt;/code&gt;. (A Strategy Pattern implementation that deals with whether a given name appears before a family name for a particular culture/customer is a topic for another time.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class MappingRegister : IRegister
{
	public void Register(TypeAdapterConfig config)
	{
		config.NewConfig&amp;lt;Account, AccountDto&amp;gt;()
			.Map(dest =&amp;gt; dest.Name, src=&amp;gt; $&amp;quot;{src.AccountHolderGivenName} {src.AccountHolderFamilyName}&amp;quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;During startup/service configuration, Mapster can be to told to scan for implementations of &lt;code&gt;IRegister&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;	TypeAdapterConfig.GlobalSettings.Scan(Assembly.GetExecutingAssembly());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="where-does-mapping-and-translation-occur"&gt;Where Does Mapping and Translation Occur?&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Data transfer can occur in different layers. Data transfer triggers a website or API (presentation layer); the application layer requests external services via an infrastructure layer to transfer data to and from. I'm often asked where that mapping and translation source code should exist and in which project in the solution. It's important to remember that we're dealing with multiple layers. While a presentation layer is the most common layer for initialization (DI container configuration), the translation method must be visible in the layer where the data transfer occurs.&lt;/p&gt;
&lt;p&gt;Translation of web/API models can exist in the presentation layer because that's where &lt;em&gt;that&lt;/em&gt; data transfer occurs. However, invoking a service from the application layer can mean the translation method can't live in the presentation layer because the application layer cannot take a direct dependency on the presentation layer (it is the other way around.)&lt;/p&gt;
&lt;p&gt;When a build boundary separates a layer (e.g., separate projects and or binaries), both assemblies can't be dependent on each other—the initialization/DI can't both access the types in the different assembly &lt;strong&gt;and&lt;/strong&gt; be referenced by the other assembly to invoke &lt;code&gt;Map&lt;/code&gt;/&lt;code&gt;Adapt&lt;/code&gt;. So, the mapping configuration that accesses the source and target types involved in the translation must exist in the assembly referenced by the initialization/DI. This is typically done by creating the familiar &lt;a href="https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#register-groups-of-services-with-extension-methods"&gt;&lt;code&gt;Add{GROUP_NAME}&lt;/code&gt; extension method pattern&lt;/a&gt; for example, given an application layer implemented in a separate project, an extension method (sometimes in the &lt;code&gt;Microsoft.Extensions.Hosting&lt;/code&gt; namespace, &lt;a href="https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-usage#:%7E:text=don%27t%20place%20extension%20methods%20in%20the%20microsoft.extensions.dependencyinjection%20namespace%20unless%20you%27re%20authoring%20an%20official%20microsoft%20package."&gt;but not recommended&lt;/a&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class ApplicationExtensions
{
	public static IServiceCollection AddApplicationServices(this IServiceCollection services)
	{
		ArgumentNullException.ThrowIfNull(services);
		TypeAdapterConfig.GlobalSettings.Scan(typeof(ApplicationExtensions).Assembly);

		services.AddMapster();
		return services;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/MapsterMapper/Mapster/wiki/Custom-mapping"&gt;Mapster - Custom Mapping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/MapsterMapper/Mapster"&gt;Mapster repo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/Mapster.DependencyInjection"&gt;Mapster Nuget&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/mapping-translation.png" class="img-fluid" alt="Complicated translation"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/what-are-the-proposed-csharp-type-unions-and-how-do-they-relate-to-discriminated-unions</id>
		<title>What Are the Proposed C# Type Unions and How Do They Relate to Discriminated Unions?</title>
		<link href="http://blog.peterritchie.com/posts/what-are-the-proposed-csharp-type-unions-and-how-do-they-relate-to-discriminated-unions" />
		<updated>2024-08-13T00:00:00Z</updated>
		<content>&lt;!--what-are-the-proposed-csharp-type-unions-and-how-do-they-relate-to-discriminated-unions--&gt;
&lt;p&gt;&lt;img src="../assets/views-through-different-lenses.jpg" class="img-fluid" alt="views through different lenses" /&gt;&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/dotnet/csharplang/blob/18a527bcc1f0bdaf542d8b9a189c50068615b439/proposals/TypeUnions.md"&gt;rumor&lt;/a&gt; is that a &lt;em&gt;type union&lt;/em&gt; feature may make its way into the next version of C#. The next version of C# will be 13, and C# has been around since 2000. What do type unions mean to C#?&lt;/p&gt;
&lt;p&gt;The concepts behind type unions have probably been around as long as programming languages. Some languages refer to them with different terms. Ada, Pascal, and Modula-2 refer to them as &lt;em&gt;variant records&lt;/em&gt; (like &lt;em&gt;variants&lt;/em&gt; in COM), Algo refers to them as &lt;em&gt;united modes&lt;/em&gt;, F#, and CORBA refer to them as discriminated unions and other languages refer to them as tagged unions (like Python and TypeScript). Some languages have a discriminator (tag) support in their enumerations feature (like Swift, Rust, and Haxe). You might also see discriminated union-&lt;em&gt;like&lt;/em&gt; support in other technologies like Swagger and OpenAPI.&lt;/p&gt;
&lt;p&gt;If you're familiar with C/C++, you may be familiar with unions; they're similar--their data types that define the type (or a block of memory) can be one of multiple types. C/C++ unions don't have a tag or discriminator or track what the union's storage &lt;em&gt;means&lt;/em&gt;). So, the code that uses the union has to figure out how to access data in the union correctly. I.e., the code that uses a union C/C++ must have its own discriminator/tag.&lt;/p&gt;
&lt;p&gt;C# never truly had the concept of a C/C++ union because of increased memory safety—accessing memory in many different ways wasn't considered &lt;em&gt;safe&lt;/em&gt;. You can fake C/C++ style unions in C# with &lt;code&gt;StructLayoutAttribute&lt;/code&gt; and &lt;code&gt;LayoutKind.Explicit&lt;/code&gt;. But I, for one, wouldn't recommend implementing discriminated unions that way.&lt;/p&gt;
&lt;p&gt;There have been some quasi-discriminated union implementations out there like &lt;code&gt;Result&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;. I call these &lt;em&gt;quasi&lt;/em&gt; because they're very special-case. Most &lt;code&gt;Result&amp;lt;T&amp;gt;&lt;/code&gt; implementations are discriminated unions because of the &lt;code&gt;Status&lt;/code&gt; or &lt;code&gt;IsSuccess&lt;/code&gt; properties that allow a consumer of an instance to tell whether to access the success or the error information. &lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt; is like &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt; with a discriminator &lt;code&gt;HasValue&lt;/code&gt;, but more semantically aligned with an &lt;em&gt;optional value&lt;/em&gt; (that could also be nullable).&lt;/p&gt;
&lt;h2 id="will-c-get-discriminated-unions-or-type-unions"&gt;Will C# Get &lt;em&gt;Discriminated Unions&lt;/em&gt; or &lt;em&gt;Type Unions&lt;/em&gt;?&lt;/h2&gt;
&lt;p&gt;The proposal for C# uses &amp;quot;Type Union&amp;quot; because the discriminator isn't explicit. The union object (or, more accurately, the C# compiler) knows the instance type and allows the use of existing C# type-matching features (like &lt;code&gt;is&lt;/code&gt;). The proposed syntax for declaring a Type Union is similar to declaring a single-level inheritance hierarchy that cannot be inherited from and behaves as if it is &lt;em&gt;closed&lt;/em&gt;. In fact, BCL support for the concept will use a &lt;code&gt;ClosedAttribute&lt;/code&gt; to declare Type Unions in a Common Type System way.&lt;/p&gt;
&lt;p&gt;Without a Type Union feature, something with a discriminator (specifically something like &lt;a href="https://blog.nimblepros.com/blogs/getting-started-with-ardalis-result/"&gt;&lt;code&gt;Result&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, is used like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// makes use of predefined union &amp;quot;Result&amp;lt;T&amp;gt;&amp;quot;
public Result&amp;lt;Resource&amp;gt; GetResource(Guid id)
{
   var resource = _context.Resources.SingleOrDefault(e =&amp;gt; e.Id == id);
   if(resource == null) return new Result&amp;lt;Resource&amp;gt;.NotFound;
   return new Result&amp;lt;Resource&amp;gt;(resource);
}

//... 

var result = GetResource(id);
if(result.Status == ResultStatus.Ok)
{
  result.Value.Description = newDescription;
  UpdateResource(result.Value);
}
else
{
  CreateResource(new Resource(id){Description = newDescription};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the proposed C# syntax, you'd declare a type union something like this, and for the point of comparison, I'll do one possible, simplified Type Union implementation of &lt;code&gt;Result&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public union struct Result&amp;lt;TValue&amp;gt;
{
  Success(TValue value);
  Failure(ErrorCode errorCode);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a &lt;em&gt;Type Union&lt;/em&gt;, this declares a union &lt;code&gt;Result&lt;/code&gt; and member types &lt;code&gt;Success&lt;/code&gt; and &lt;code&gt;Failure&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Creating an instance is similar to:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Result&amp;lt;Resource&amp;gt; result = Succes(resource);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Result&amp;lt;Resource&amp;gt; result = Failure(ErrorCode.NotFound);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instantiating one of the types and assigning it to an instance of the union—much like assigning a subclass to an instance of the base class.&lt;/p&gt;
&lt;p&gt;And use the instance like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;if(result is Failure f) { /*...*/ }
&lt;/code&gt;&lt;/pre&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;NOTE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;These examples were written without access to the feature in the language. Based solely on documentation, expect syntax errors when the feature is released.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;This example is covered in some common patterns in the proposal and only covers a part of what's possible with Type Unions (that part is &lt;em&gt;struct unions&lt;/em&gt;.) What's nice about this proposed feature is that it also considers union classes, ad hoc unions, and a limited ability to create custom unions (e.g., &lt;code&gt;ClosedAttribute&lt;/code&gt; and &lt;code&gt;UnionAttribute&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;What's also nice about this proposal is that it considers records, refs, boxing, nullability, co-/contra-variance (with ad hoc unions), exhaustiveness, nullability, equivalence, and assignability. The proposal might only do &lt;em&gt;most&lt;/em&gt; of what you'd expect, but it does what is correct and useful.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/views-through-different-lenses.jpg" class="img-fluid" alt="views through different lenses"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/aspiring-links-2024-07-14</id>
		<title>Aspiring Links for Period Ending July 14, 2024</title>
		<link href="http://blog.peterritchie.com/posts/aspiring-links-2024-07-14" />
		<updated>2024-07-14T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/aspiring-links.png" class="img-fluid" alt="A made from chain links" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://visualstudiomagazine.com/Articles/2024/06/28/net-aspire.aspx"&gt;Visual Studio Magazine - Microsoft Making Big .NET Aspire Push, So What Is It?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/live/YXCqkJLL3XE?si=MmW-KmBtkQnXvmXi"&gt;YouTube - Learn C# with CSharpFritz: Basics of .NET Aspire - Part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/hTtlBlsy1WA?si=nQYJggHvNg4gNkXx"&gt;YouTube - What is Dev Time Orchestration in .NET Aspire?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/fYqnWmhR-HU?si=vQogEpoNDNbmawhc"&gt;YouTube - Meet .NET Aspire&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/qtUgntF21Uw?si=WsVnZ2UPBWPw3dN-"&gt;YouTube - What are .NET Aspire components?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/lCzQ2yQr6JE?si=b3WEiW1ZX6lYjVY0"&gt;YouTube - How to deploy .NET Aspire applications?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/_DzGe2DXrKk?si=hdIRJaoUKiJrSS6h"&gt;YouTube - What is .NET Aspire telemetry?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/DzUhBG7uKUk?si=Sto7FpG7-dG51-8n"&gt;YouTube - What are .NET Aspire service defaults?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/qT6AXCLrZtw?si=ADHbcJLQ9HoR3XM1"&gt;YouTube - Technology and Friends - Scott Hunter on .NET Aspire&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/live/PUCU9ZOOgQ8?si=OgYaSvjqYPDpAJMr"&gt;YouTube - Let's Learn .NET Aspire (Português)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/live/48CWnYfTZhk?si=cgzeQ7kiEBmvS-s_"&gt;YouTube - Let's Learn .NET: Aspire (Tiếng Việt)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.postsharp.net/aspire-caching-metalama"&gt;Metalama - Simplify Your .NET Aspire Caching With Metalama&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://jeffreyfritz.com/2024/07/adding-antivirus-to-net-aspire-systems/"&gt;Fritz on the Web - Adding Antivirus to .NET Aspire Systems&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/aspiring-links.png" class="img-fluid" alt="A made from chain links"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/aspiring-links-2024-06-14</id>
		<title>Aspiring Links for Week Ending June 14, 2024</title>
		<link href="http://blog.peterritchie.com/posts/aspiring-links-2024-06-14" />
		<updated>2024-06-14T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/aspiring-links.png" class="img-fluid" alt="A made from chain links" /&gt;&lt;/p&gt;
&lt;p&gt;Using PostgreSQL with .NET and Entra ID (Blog)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/using-postgre-sql-with-dotnet-and-entra-id/"&gt;https://devblogs.microsoft.com/dotnet/using-postgre-sql-with-dotnet-and-entra-id/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Official .NET Aspire Learning Path at Microsoft Learn (Site)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/training/paths/dotnet-aspire/"&gt;https://learn.microsoft.com/en-us/training/paths/dotnet-aspire/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;My First look at .NET Aspire. What's with the Hype? by CodeOpinion (Video)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://youtu.be/maVXnkYEDIE?si=7AkKulcvVOgnxmVz"&gt;https://youtu.be/maVXnkYEDIE?si=7AkKulcvVOgnxmVz&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Instant OpenTelemetry Dashboard for JavaScript Developers with Aspire (Video)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://youtu.be/YKraN1ZETpw?si=XZUWcnZMtpzl7ztT"&gt;https://youtu.be/YKraN1ZETpw?si=XZUWcnZMtpzl7ztT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;.NET Aspire: Your Gateway to Cloud-Native Success (Blog)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://riasolutionsgroup.com/2024/06/11/using-dynatrace-to-navigate-the-microservices-maze/"&gt;https://riasolutionsgroup.com/2024/06/11/using-dynatrace-to-navigate-the-microservices-maze/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Aspirant - Extensions for .NET Aspire (GitHub Repo)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/aspirant-project/aspirant"&gt;https://github.com/aspirant-project/aspirant&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/aspiring-links.png" class="img-fluid" alt="A made from chain links"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/new-and-proposed-changes-in-csharp-13-2024-jun-5</id>
		<title>New And Proposed Changes For C# 13 - June 5, 2024</title>
		<link href="http://blog.peterritchie.com/posts/new-and-proposed-changes-in-csharp-13-2024-jun-5" />
		<updated>2024-06-05T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/types-of-extensions.png" class="img-fluid" alt="Extensions, extensions, extensions" /&gt;&lt;/p&gt;
&lt;p&gt;C# 13 is shaping up to introduce some interesting and useful additions to the C# language. Let's look at what we know as of June 5, 2024.&lt;/p&gt;
&lt;h2 id="extension-types"&gt;Extension Types&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Extension Types&lt;/em&gt; (announced at Build 2024) are the latest proposed addition to C# 13. Microsoft introduced &lt;em&gt;Extension Methods&lt;/em&gt; in C# 3, and since C# 4, the concept of &amp;quot;Extension Everything&amp;quot; has been an anticipated addition. &lt;em&gt;Extension Methods&lt;/em&gt; added the ability to extend non-static classes with statically-defined methods in unrelated static classes. &lt;em&gt;Extension Types&lt;/em&gt; extend the extensibility that Extension Methods offer, a huge leap towards Extension Everything.&lt;/p&gt;
&lt;p&gt;Extension Methods syntax stays the same, but you can be clearer about the intent of your extension methods by declaring implicit extension classes.&lt;/p&gt;
&lt;p&gt;An extension method in C#3-C#12 may look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class StringExtensions
{
    public static bool IsNotNullOrEmpty(this string text)
    {
        return !string.IsNullOrEmpty(text);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code introduces the ability to do something like &lt;code&gt;myText.IsNotNullOrEmpty()&lt;/code&gt;. In C# 13, you can be more direct (I'm trying to avoid using the word &amp;quot;explicit&amp;quot;; you'll see why in a sec.) by declaring an &lt;em&gt;implicit extension&lt;/em&gt; class with what looks like an instance method &lt;code&gt;IsNotNullOrEmpty&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;implicit extension StringExtensions for string
{
    public bool IsNotNullOrEmpty()
    {
        return !string.IsNullOrEmpty(this);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This alternative way to re-implement an extension method implements an instance method on the extension class—which is how the extension method appears when used: a call to a method on an instance of a type (&lt;code&gt;string&lt;/code&gt; in our example.) We're not limited to extending the &lt;em&gt;instance&lt;/em&gt; of a type; we can also extend the type with static methods. &lt;code&gt;IsNotNullOrEmpty&lt;/code&gt; is looking to be the opposite of the static &lt;code&gt;string&lt;/code&gt; method &lt;code&gt;IsNullOrEmpty&lt;/code&gt;. With Extension Types we will be able to implement &lt;code&gt;IsNotNullOrEmpty&lt;/code&gt; as a static method on &lt;code&gt;string&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;implicit extension StringExtensions for string
{
    public static bool IsNotNullOrEmpty(string text)
    {
        return !string.IsNullOrEmpty(text);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code adds a &lt;strong&gt;static extension method&lt;/strong&gt; that allows for &lt;code&gt;string.IsNotNullOrEmpty(myText)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But, since the code will truly be in the context—or scope of—&lt;code&gt;string&lt;/code&gt;, I don't need to qualify the call to &lt;code&gt;IsNullOrEmpty&lt;/code&gt; with the type &lt;code&gt;string&lt;/code&gt;! So, we could do this instead:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;implicit extension StringExtensions for string
{
    public static bool IsNotNullOrEmpty(string text)
    {
        return !IsNullOrEmpty(text);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since this is &amp;quot;Extensions Types,&amp;quot; we will also have &lt;em&gt;extension properties&lt;/em&gt;. Continuing with my theme of IsNotNullOrEmpty (potentially in a controversial way), we could implement my original extension method as an extension property:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;implicit extension StringExtensions for string
{
    public bool IsNotNullOrEmpty =&amp;gt; !IsNullOrEmpty(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code allows us to write &lt;code&gt;myText.IsNotNullOrEmpty&lt;/code&gt;. (Feel free to comment that I'm mad for making a property on a potentially &lt;code&gt;null&lt;/code&gt; instance of a &lt;code&gt;string&lt;/code&gt;, this is just an example.)&lt;/p&gt;
&lt;p&gt;Extension Types isn't limited to extension methods and properties but also includes extension indexers. Stealing from Dustin and Mads' demo, let's say we want to provide access to individual bits with a &lt;code&gt;UInt64&lt;/code&gt;; I could write an implicit extension type like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public implicit extension Bits for Uint64)
{
    public bool this[int index]
    {
        get =&amp;gt; (this &amp;amp; Mask(index)) != 0;
        set =&amp;gt; this = value ? this | Mask(value) : this &amp;amp; !Mash(index);
    }
    
    static ulong Mask(int index) =&amp;gt; `ul &amp;lt;&amp;lt; index;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;... so I could obtain the first bit of an unsigned 64-bit number with &lt;code&gt;unsigned64BitNumber[0]&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;What's with &lt;code&gt;implicit&lt;/code&gt;? Like implicit operators that will be resolved to based on inferred scope or that it &lt;em&gt;implicitly&lt;/em&gt; applies to all cases of the underlying type (&lt;code&gt;... for &amp;lt;type&amp;gt;&lt;/code&gt;.) The keyword &lt;code&gt;explicit&lt;/code&gt; means a caller can only use the member in an explicitly-qualified scope. So, if I made my &lt;code&gt;StringExtensions&lt;/code&gt; class &lt;code&gt;explicit&lt;/code&gt; instead, the use of &lt;code&gt;IsNullOrEmpty&lt;/code&gt; would only be callable by qualifying with &lt;code&gt;StringExtensions&lt;/code&gt;: &lt;code&gt;(StringExtensions)myText.IsNotNullOrEmpty&lt;/code&gt;. At least, that's what's currently proposed.&lt;/p&gt;
&lt;p&gt;Extension Types is a work in progress, so some of these things may change—I expect details around &lt;code&gt;explicit&lt;/code&gt; usage to change.&lt;/p&gt;
&lt;h2 id="new-field-contextual-keyword"&gt;New &lt;code&gt;field&lt;/code&gt; Contextual Keyword&lt;/h2&gt;
&lt;p&gt;A feature that almost made it into C# 12 is the &lt;code&gt;field&lt;/code&gt; contextual keyword--contextual in autoproperties. &lt;code&gt;field&lt;/code&gt; is an &amp;quot;alias&amp;quot; got access the auto-generated backing field.&lt;/p&gt;
&lt;p&gt;Since you could declare a variable within the context of an autoproperty, &lt;code&gt;field&lt;/code&gt; is technically a breaking change.&lt;/p&gt;
&lt;h2 id="params-collections"&gt;&lt;code&gt;params&lt;/code&gt; Collections&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;params&lt;/code&gt; has existed in C# since the start as a means of declaring a method that takes a variable number of arguments. Generic types were not available at the time, so &lt;code&gt;params&lt;/code&gt; only works with &lt;em&gt;arrays&lt;/em&gt;, for example, &lt;code&gt;void Method(params string[] args)&lt;/code&gt; or &lt;code&gt;void Method(params int[] numbers)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This means that &lt;code&gt;ReadOnlySpan&amp;lt;T&amp;gt;&lt;/code&gt; may be used with &lt;code&gt;params&lt;/code&gt; to realize the performance improvements of spans.&lt;/p&gt;
&lt;h2 id="system.threading.lock-type-and-lock"&gt;&lt;code&gt;System.Threading.Lock&lt;/code&gt; Type and &lt;code&gt;lock&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;.NET 9 introduces an improved lock type &lt;code&gt;System.Threading.Lock&lt;/code&gt;. &lt;code&gt;System.Threading.Lock&lt;/code&gt; offers improvements over &lt;code&gt;Monitor&lt;/code&gt; in that &lt;code&gt;Lock&lt;/code&gt; supports a narrower locking scope and avoids the overhead of SyncBlock.&lt;/p&gt;
&lt;p&gt;C# 13 &lt;code&gt;lock&lt;/code&gt; recognizes if the target is &lt;code&gt;System.Threading.Lock&lt;/code&gt; and uses its updated API.&lt;/p&gt;
&lt;h2 id="new-escape-sequence-for-esc-character"&gt;New Escape Sequence For &lt;kbd&gt;Esc&lt;/kbd&gt; Character&lt;/h2&gt;
&lt;p&gt;You can now enter &lt;kbd&gt;Esc&lt;/kbd&gt; as a string/character literal with &lt;code&gt;'\e'&lt;/code&gt;. Prior to C# 13, having the &lt;kbd&gt;Esc&lt;/kbd&gt; character in a string would require typing &lt;code&gt;\u001b&lt;/code&gt; (or &lt;code&gt;\x1b&lt;/code&gt;, but that's not recommended.) I believe this accepts the existing Regular Expression character sequence of &lt;code&gt;\e&lt;/code&gt; as an escape for &lt;kbd&gt;Esc&lt;/kbd&gt;.&lt;/p&gt;
&lt;h2 id="improved-overload-resolution-for-method-groups"&gt;Improved Overload Resolution For Method Groups&lt;/h2&gt;
&lt;p&gt;C# 13 will improve overload resolution of method groups when determining the method group's natural type. Oversimplication: instead of generating all possible candidate methods and selecting the best candidate, candidates will be constructed scope by scope. If, after pruning all the candidates at one scope, candidates at the next scope are constructed and considered. If you're interested at that level, see &lt;a href="https://github.com/dotnet/roslyn/issues/69222"&gt;Generic constraints should prune out candidates for method group natural type&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="index-operator-now-available-in-object-initializer-expressions"&gt;Index operator &lt;code&gt;^&lt;/code&gt; Now Available In Object Initializer Expressions&lt;/h2&gt;
&lt;p&gt;You can now use the &amp;quot;From the end&amp;quot; operator in object initializer expressions. e.g.:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var countdown = new TimerRemaining()
{
    buffer =
    {
        [^1] = 0,
        [^2] = 1,
        [^3] = 2,
        [^4] = 3,
        [^5] = 4,
        [^6] = 5,
        [^7] = 6,
        [^8] = 7,
        [^9] = 8,
        [^10] = 9
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="caveat"&gt;Caveat&lt;/h2&gt;
&lt;p&gt;&amp;quot;C# 13&amp;quot; is a work in progress, and the above was accurate when it was published. Hopefully we'll get everything detailed above but we may not. We may not get some of these features or we may get more!&lt;/p&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/roslyn/issues/11159"&gt;Language Feature: Extension Everything&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/csharplang/issues/5497"&gt;[Proposal]: Extensions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/csharplang/issues/140"&gt;Proposal: Semi-Auto-Properties; field keyword&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/params-collections"&gt;&lt;code&gt;params&lt;/code&gt; Collections Feature Proposal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/lock-object"&gt;Lock Object Feature Specification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/csharplang/issues/7400"&gt;[Proposal]: String/Character escape sequence \e as a short-hand for \u001b (&amp;lt;ESCAPE&amp;gt;)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/method-group-natural-type-improvements"&gt;Method group natural type improvements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/csharplang/issues/7429"&gt;[Proposal]: Method group natural type improvements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/csharplang/issues/7684"&gt;Open issue: evaluation of implicit indexers in object initializers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/types-of-extensions.png" class="img-fluid" alt="Extensions, extensions, extensions"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/dealing-with-primitive-obsession-with-entity-framework-core</id>
		<title>Dealing with Primitive Obsession with Entity Framework Core</title>
		<link href="http://blog.peterritchie.com/posts/dealing-with-primitive-obsession-with-entity-framework-core" />
		<updated>2024-05-22T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/obsessed-with-primitive-shapes.png" class="img-fluid" alt="obsessed only with creating with primitive shapes" /&gt;&lt;/p&gt;
&lt;p&gt;Unlike object-oriented languages, serialization and data transfer are limited to a small set of primitive types. These primitive types are often text, numbers (integers, floating point), booleans, arrays, etc. Sometimes, you're fortunate enough to have a more modern framework and have fancy types like date, time, and date/time, UUID/GUID, monetary, or binary data.&lt;/p&gt;
&lt;p&gt;Primitive types are &lt;em&gt;value types&lt;/em&gt;—they don't have identity semantics, and their equality/equivalence is based on their &lt;em&gt;value&lt;/em&gt;. Entity Framework Core supports &lt;em&gt;value types&lt;/em&gt; as attributes but only insomuch as what the underlying provider supports. Any complex types are &amp;quot;entities&amp;quot; in Entity Framework, despite not having an &amp;quot;identity&amp;quot;.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Note&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Every type that Entity Framework is configured to recognize is an &lt;em&gt;Entity&lt;/em&gt; (e.g., via &lt;code&gt;ModelBuilder.Entity&amp;lt;T&amp;gt;()&lt;/code&gt; or &lt;code&gt;IEntityTypeConfiguration&amp;lt;T&amp;gt;&lt;/code&gt;), despite an entity traditionally (English definition, philosophically, ontologically, or even entity-relationship diagrams) being an individual/instance with an independent (of its attributes) existence.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Domains invariably have many value types. Some may be complex (multiple attributes), and some may be simple (subsets of primitive types.) Even &lt;em&gt;simple&lt;/em&gt; domain value types have unique semantics—that constrain value validity. A common value type &lt;em&gt;Name&lt;/em&gt;, for example, is textual and thus can be implemented with a textual primitive type (like &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;VARCHAR&lt;/code&gt;.) A textual primitive type like &lt;code&gt;string&lt;/code&gt; is a sequence of characters up to 2,146,483,647 characters of any value. This is unrealistic for a &amp;quot;name&amp;quot; in most domains: e.g., a name over 2 billion characters in length or containing characters like &lt;code&gt;%'&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;&lt;/code&gt; is problematic. Unlike how an integer is not a valid text value, and there exists no way to assign an integer to a string (e.g., &lt;code&gt;string text = 1;&lt;/code&gt; is not valid and cannot be compiled and thus never be executed), re-using a primitive type for &lt;em&gt;domain types&lt;/em&gt; with validity (consistency) constraints means instances of these domain values may not be valid (e.g., &lt;code&gt;name = &amp;quot;%&amp;quot;&lt;/code&gt; or &lt;code&gt;name = new string('&amp;lt;', int.MaxValue);&lt;/code&gt;) until being checked. Enter &lt;strong&gt;Primitive Obsession&lt;/strong&gt;.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Hint&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Entity Framework &amp;quot;entities&amp;quot; are not the same as Domain-Driven Design &amp;quot;entities.&amp;quot; Despite being based on relational entities, Entity Framework considers groups of nested (owned) attributes to be entities even if they don't map to their own table (with key.)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="primitive-obsession"&gt;Primitive Obsession&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Primitive Obsession&lt;/em&gt; is a type of code smell&lt;span title="Fowler, M. (2018). &amp;quot;Refactoring: Improving the Design of Existing Code&amp;quot; "&gt;&lt;sup&gt;&lt;a href="https://amzn.to/3KkcnDT"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/span&gt; where—in an object-oriented context—something that realistically  has unique behavior and semantics has been implemented with a primitive type that doesn't guard that concept's invariants. Primitive Obsession recommends that invariants be abstracted within a unique type so that invalid or inconsistent instances of that type cannot exist.&lt;/p&gt;
&lt;h3 id="value-object-mapping-in-entity-framework"&gt;Value Object Mapping in Entity Framework&lt;/h3&gt;
&lt;p&gt;Fortunately, Entity Framework Core supports mapping from domain-specific value types to database primitive types. The domain-specific types then maintain their consistency, and correct usage is enforced.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Note&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;The converse is also important; not all uses of primitive types need to be abstracted away within a custom domain type. For example, a domain type may have attributes that realistically won't have values outside a specific range, but a type does not need to be created to abstract a primitive type. For example, making a &lt;code&gt;Length&lt;/code&gt; value type that wraps an integer value that provides no added value increases complexity rather than reduces it.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;I've encountered some complex domains that treat identity very specifically. In cases like this, custom value types like &lt;em&gt;Identifier&lt;/em&gt; that may use one of many primitive types are created to abstract the underlying primitive type. For example, a high-level view of an Identifier class (that doesn't include details like validation, parsing, etc.):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public record Identifier&amp;lt;T&amp;gt; where T : struct, IEquatable&amp;lt;T&amp;gt;
{
    private readonly T _value;
    public Identifier(T value) =&amp;gt; _value = value;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Implemented as a &lt;code&gt;record&lt;/code&gt;, &lt;code&gt;Identifer&amp;lt;T&amp;gt;&lt;/code&gt; operates as a value type (&lt;code&gt;struct&lt;/code&gt;, at the runtime level to implement a domain-level &lt;em&gt;value type&lt;/em&gt;) and provides equality and isolation (&lt;code&gt;Identifier&amp;lt;int&amp;gt;&lt;/code&gt; is not the same as &lt;code&gt;Identifier&amp;lt;Guid&amp;gt;&lt;/code&gt;. They cannot be equal, or compared.)&lt;/p&gt;
&lt;p&gt;Inferring the mapping of instances of this type to primitive database column types isn't possible (and EF will let you know with an &lt;code&gt;InvalidOperationException&lt;/code&gt; detailing &lt;em&gt;The 'Identifier' property 'ShippingCompany.Identifier' could not be mapped because the database provider does not support this type.&lt;/em&gt; We need to tell Entity Framework Core how to map to a type the database provider supports. This is done with the &lt;code&gt;PropertyBuilder&amp;lt;TProperty&amp;gt;.HasConversion&lt;/code&gt; method when configuring the containing entity type.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder
        .Entity&amp;lt;ShippingCompany&amp;gt;()
        .Property(e =&amp;gt; e.Identifer)
        .HasConversion(identifier =&amp;gt; identifer.Value, value =&amp;gt; new Identifier&amp;lt;Guid&amp;gt;(value));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above shows how you can address Primitive Obsession when using Entity Framework but, it assumes that you're directly persisting domain objects through Entity Framework. Focusing on behavior over attributes in a domain may not make all domain objects persistable by Entity Framework. Still, you can at least push off the mapping of non-primitive value types to Entity Framework if you don't want to introduce another layer of mapping (treating the types persisted via Entity Framework as persistence DTOs).  You could still have a non-primitive-DTO (e.g., &lt;code&gt;IdentifierDto&lt;/code&gt;) persisted through Entity Framework.  I'll leave it up to you to decide if that's &amp;quot;proper&amp;quot; for your domain.&lt;/p&gt;
&lt;h3 id="references"&gt;References&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;[1]: &lt;a href="https://amzn.to/3KkcnDT"&gt;Refactoring: Improving the Design of Existing Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.c2.com/?ReplaceDataValueWithObject"&gt;Replace Data Value With Object Refactoring&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/obsessed-with-primitive-shapes.png" class="img-fluid" alt="obsessed only with creating with primitive shapes"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/contributing-to-many-git-repos</id>
		<title>A tool to help contributing to many Git repos</title>
		<link href="http://blog.peterritchie.com/posts/contributing-to-many-git-repos" />
		<updated>2023-11-30T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/contributing-to-many-git-repos.jpg" class="img-fluid" alt="Source code from many sources" /&gt;&lt;/p&gt;
&lt;p&gt;I've contributed to many Git repos over the years. Doing this means I work in a code base for a little while, switch to another, and often eventually switch back.&lt;/p&gt;
&lt;h2 id="collaborating-with-others"&gt;Collaborating with Others&lt;/h2&gt;
&lt;p&gt;In the repos that I work in, many have multiple contributors. The contributions to those repos can be prolific, and if the repo is using a workflow that uses feature or topic branches, branches come and go quite often. &lt;code&gt;git fetch&lt;/code&gt; by default (or with no other options) gets all branches so you'll have other team members' branches after a fetch--which can be used to do a deep dive on a PR.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;You could choose not to use the &lt;code&gt;git fetch&lt;/code&gt; defaults and have it only get a particular branch. This can typically be done with &lt;code&gt;git fetch origin main&lt;/code&gt; (depending on how you've named your remotes and your branches.)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;p&gt;I work with many organizations and rarely is there one repo (yes, I know, there's this thing called a &amp;quot;monorepo&amp;quot;; but I find that organizations that can make this work need to be very technically savy, with products/technologies geared towards developers, and only a few of the organizations I work with are at that level.) With remote work being what it is (I'm often working at a different time than other contributors), when I return to work with an organization's code, I usually need to update several repos.&lt;/p&gt;
&lt;p&gt;|Why not do a &lt;code&gt;git pull&lt;/code&gt; instead of &lt;code&gt;git fetch&lt;/code&gt;?|
|:-:|
What I'm contributing to, what I may be reviewing, and whether I'm connected, are variable enough that I've built a habit only to pull when I'm ready to merge and deal with potential conflicts. If I have conflicts, I must resolve them (or abort: &lt;code&gt;git merge --abort&lt;/code&gt; or &lt;code&gt;git fetch origin&lt;/code&gt; and &lt;code&gt;git reset --hard origin&lt;/code&gt;) before doing anything else. This means I must commit to resolving those conflicts before switching to another branch to review or work with it. (Yes, I could re-clone in a different place, but frequent-fetch&amp;gt;abort&amp;gt;clone in terms of effort and risk.)}&lt;/p&gt;
&lt;h1 id="a-tool-to-help"&gt;A tool to help&lt;/h1&gt;
&lt;p&gt;When I re-start work (or maybe I'm coming off a vacation), going to each repo dir to perform &lt;code&gt;git fetch&lt;/code&gt; is tedious. I've developed a Powershell script to do that. I'll walk through the script after the code (commented code available &lt;a href="https://github.com/peteraritchie/pri.powershell/blob/main/git/fetch-all.ps1"&gt;here&lt;/a&gt;.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;using namespace System.IO;
param (
    [switch]$WhatIf,
    [switch]$Verbose,
    [switch]$Quiet
    )
$currentDir = (get-location).Path;

if($Verbose.IsPresent) {
    $VerbosePreference = &amp;quot;Continue&amp;quot;;
}

function Build-Command {
    $expression = 'git fetch';
    if($Quiet.IsPresent) {
        $expression += ' -q';
    }
    if($Verbose.IsPresent) {
        $expression += ' -v --progress';
    }
    if($WhatIf.IsPresent) {
        $expression += ' --dry-run';
    }
    $expression += &amp;quot; origin&amp;quot;;
    return $expression;
}

foreach($item in $([Directory]::GetDirectories($currentDir, '.git', [SearchOption]::AllDirectories);)) {
    $dir = get-item -Force $item;
    Push-Location $dir.Parent;
    try {
        Write-Verbose &amp;quot;fetching in $((Get-Location).Path)...&amp;quot;;
        $expression = Build-Command;

        Invoke-expression $expression;

    } finally {
        Pop-Location;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, I'm translating the PowerShell idioms &lt;code&gt;WhatIf&lt;/code&gt;, &lt;code&gt;Verbose&lt;/code&gt;, and &lt;code&gt;Quiet&lt;/code&gt; to common Git options &lt;code&gt;--dry-run&lt;/code&gt;, &lt;code&gt;--verbose&lt;/code&gt; (&lt;code&gt;-v&lt;/code&gt;), and &lt;code&gt;--quiet&lt;/code&gt; (&lt;code&gt;-q&lt;/code&gt;). The &lt;code&gt;Build-Command&lt;/code&gt; builds up the expression we want to use to invoke git. I've included the &lt;code&gt;--progress&lt;/code&gt; option with &lt;code&gt;git fetch&lt;/code&gt; to display progress when&lt;code&gt;-Verbose&lt;/code&gt; is specified. Next, I'm looping through all directories, looking for a &lt;code&gt;.git&lt;/code&gt; directory. I'm using &lt;code&gt;System.IO.GetDirectories&lt;/code&gt; instead of &lt;code&gt;Get-ChildItem&lt;/code&gt; because it's much faster. For each directory that contains a &lt;code&gt;.git&lt;/code&gt; subdirectory, Git &lt;code&gt;fetch&lt;/code&gt; is invoked. This allows me to fetch several Git repos within the hierarchy of the current directory.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Organizaing Code Locally&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;I work with my code (spikes, libraries, experiments, etc.), open-source projects, and multiple clients. All these diverge from one another at one level in my directory structure. e.g. I may have a &lt;code&gt;src&lt;/code&gt; subdiretory in my home directory; and &lt;code&gt;oss&lt;/code&gt;, &lt;code&gt;experiments&lt;/code&gt;, and &lt;code&gt;client&lt;/code&gt; subdirectories within &lt;code&gt;src&lt;/code&gt;, so I can choose to fetch from all the repos recursively in each of those subdirectories--if I'm returning to work on an OSS project after being away from OSS for a while, I just &lt;code&gt;fetch-all.ps&lt;/code&gt; within the &lt;code&gt;oss&lt;/code&gt; subdirectory.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;By default (or with no other options), &lt;code&gt;git fetch&lt;/code&gt; does not delete corresponding local branches that have been removed from a remote. So, new branches will be downloaded, but those that were removed will remain.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;To also remove local branches removed from the remote, you can include a purge option with &lt;code&gt;git fetch&lt;/code&gt;: &lt;code&gt;git fetch --prune&lt;/code&gt; or &lt;code&gt;git fetch -p&lt;/code&gt;.&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;p&gt;If I'm reviewing a PR, I don't necessarily want removed remote branches to be removed locally &lt;em&gt;all the time&lt;/em&gt;. So, I like pruning separately from fetching. The following is the script for that (other than Build-Command, it has the same structure and flow as &lt;code&gt;fetch-all.ps1&lt;/code&gt; (so I won't walk through this snippet.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-PowerShell"&gt;using namespace System.IO;
param (
    [switch]$WhatIf,
    [switch]$Verbose
    )
$currentDir = (get-location).Path;

if($Verbose.IsPresent) {
    $VerbosePreference = &amp;quot;Continue&amp;quot;;
}

function Build-Command {
    $expression = 'git remote';
    if($Verbose.IsPresent) {
        $expression += ' -v';
    }
    $expression += ' prune';
    if($WhatIf.IsPresent) {
        $expression += ' --dry-run';
    }
    $expression += ' origin';
    return $expression;
}

foreach($item in $([Directory]::GetDirectories($currentDir, '.git', [SearchOption]::AllDirectories);)) {
    $dir = get-item -Force $item;
    Push-Location $dir.Parent;
    try {
        Write-Verbose &amp;quot;pruning in $((Get-Location).Path)...&amp;quot;;
        $expression = Build-Command;

        Invoke-expression $expression;
    } finally {
        Pop-Location;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Separating pruning from fetching also allows me to prune at a wider scope than fetching. e.g. &lt;code&gt;c:\Users\peter\src\client .\fetch-all.ps1&lt;/code&gt; and &lt;code&gt;c:\Users\peter\src .prune-all.ps1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I look forward to your feedback and comments.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/contributing-to-many-git-repos.jpg" class="img-fluid" alt="Source code from many sources"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/entity-framework-in-aspire</id>
		<title>Entity Framework in .NET Aspire</title>
		<link href="http://blog.peterritchie.com/posts/entity-framework-in-aspire" />
		<updated>2023-11-29T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/entity-framework-in-aspire.jpg" class="img-fluid" alt="A path through the infrastructure" /&gt;&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;.NET Aspire is an opinionated, cloud ready stack for building observable, production ready, distributed applications.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/aspire/get-started/aspire-overview"&gt;.NET Aspire&lt;/a&gt; is currently in preview and focuses on &lt;em&gt;simplifying the developer experience&lt;/em&gt; with &lt;em&gt;orchestration&lt;/em&gt; and &lt;em&gt;automatic service discovery&lt;/em&gt; features. There's a huge potential for .NET Aspire beyond this initial valuable feature set.&lt;/p&gt;
&lt;p&gt;Being in preview, .NET Aspire may not yet support all the scenarios or workloads you may be comfortable with. It's an opinionated framework, which means differences of opinion are natural and expected. Currently, one of those opinions seems to be a focus on containers. The sample solutions that the new &lt;code&gt;dotnet&lt;/code&gt; templates provide are a great example of the benefits of containerization. The .NET Aspire starter solution that &lt;code&gt;dotnet new --use-redis-cache --output AspireStarter&lt;/code&gt; generates, out of the box, is something that, when debugged, will download, run, and utilize a Docker Redis image. (I've worked with teams where getting each member productive in a development environment has ended up being days of work.) The AppHost component of a .NET Aspire solution codifies abstract aspects of the architectural decisions that automates the generation and deployment of a development environment&amp;lt;(!--and configuration provides the details from future decisions about other environments--&amp;gt;.)&lt;/p&gt;
&lt;p&gt;A container focus is empowered by .NET Aspire's &lt;em&gt;orchestration&lt;/em&gt; features. An independent orchestration responsibility enables better separation of &lt;em&gt;release and deploy&lt;/em&gt; concerns from &lt;em&gt;build and test&lt;/em&gt; concerns; &lt;em&gt;shifting right&lt;/em&gt; those decisions that release and deploy depend on. (i.e., the ability to develop, execute, and evaluate solutions are discernibly &lt;em&gt;left&lt;/em&gt; of release and operation.) Containers are an established method of componentizing a distributed system with independent servers (sometimes called &amp;quot;tiers.&amp;quot;) This provides flexibility to deploy and execute in a development environment even before architectural decisions about a production topology have been considered. For example, debugging the .NET Aspire starter app automatically spins up a Redis container in Docker, but it's extremely unlikely that's how it will be deployed in production. In production, will there be one only Redis instance? If you have many instances, what sort of gateway or reverse proxy to that pool of instances will be utilized? Will it be on-prem or cloud? Will it be Azure, AWS, or Google Cloud? The beauty of Aspire's orchestration feature is that it doesn't matter yet; you can configure orchestration to &lt;em&gt;figure it out at run-time&lt;/em&gt;, one environment at a time!&lt;/p&gt;
&lt;p&gt;But, with every decision comes compromise. Technologies that depend on the physical resources that come from those decisions (that we're now effectively deferring) introduce some challenges with some existing software development idioms. A chicken-and-egg situation: if how to connect to physical resources may only be known at run-time, what happens to design-time technologies that depend on that connection information?&lt;/p&gt;
&lt;p&gt;One popular technology in .NET, Entity Framework, suffers one of those challenges in .NET Aspire (Possibly only in &lt;em&gt;code-first&lt;/em&gt; scenarios. Many Entity Framework examples detail adding Entity Framework support to an existing component (resource, like console app, ASP.NET Core web API, Razor app, etc.), creating a circular dependency between its project and the existence of an executing database (i.e., a valid database connection string.) In database-first, you have an existing application with existing physical databases and practices to utilize them in a development environment. With .NET Aspire, developers are &lt;em&gt;shifted left&lt;/em&gt; from the decisions that provide the resources that things like &lt;code&gt;migrations add &amp;lt;migration-name&amp;gt;&lt;/code&gt; and &lt;code&gt;dotnet ef database update&lt;/code&gt; require to function properly.&lt;/p&gt;
&lt;p&gt;To be clear, the way .NET Aspire works is that the orchestration (AppHost) executes, figures out the various connection strings, and overrides the &lt;code&gt;appsettings&lt;/code&gt; by setting environment variables before running the other components. The premise behind this means that at run-time, whatever is in &lt;code&gt;appsettings&lt;/code&gt; is ignored. &lt;code&gt;dotnet ef&lt;/code&gt; command doesn't execute at run-time; it effectively runs at design-time and gets its configuration from &lt;code&gt;appsettings&lt;/code&gt;, so it's out of sync with reality.&lt;/p&gt;
&lt;p&gt;The basic guidance is to &lt;em&gt;abstract those types of dependencies as .NET Aspire resources&lt;/em&gt;. Nothing new conceptually, but this might be an application of the principles of abstraction at a level less commonly applied. Refining that guidance to using Entity Framework: &lt;em&gt;the database should be an independent resource&lt;/em&gt;. Independent resources are modeled in .NET as either separate projects or separate solutions. Luckily, an &lt;a href="https://github.com/dotnet/aspire-samples/tree/main/samples/eShopLite"&gt;.NET Aspire sample&lt;/a&gt; addresses this. Let's look into the details.&lt;/p&gt;
&lt;p&gt;The structure of the eShopLite sample overlaps with the .NET Aspire starter &lt;code&gt;dotnet new&lt;/code&gt; template. It has a Blazor web frontend, a web API, an Aspire AppHost, and an Aspire service defaults project. Additionally, there is a shopping cart service (BasketService), and the catalog database (CatalogDb) project is an abstraction of the database resource.&lt;/p&gt;
&lt;p&gt;The CatalogDb looks very similar to what you'd end up with following &lt;a href="https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-8.0&amp;amp;tabs=visual-studio"&gt;Tutorial: Create a web API with ASP.NET Core&lt;/a&gt;: an ASP.NET Core web API that leverages Entity Framework, and is effectively a gateway to a backend database. Although, that tutorial uses Entity Framework &lt;em&gt;in-memory&lt;/em&gt; rather than via PostgreSQL. The way eShopLite supports Entity Framework is through the CatalogDb project. CatalogDb is like a stub project to the rest of the solution: Aspire doesn't execute it, but CatalogService depends upon it for the database model classes and &lt;code&gt;DbContext&lt;/code&gt; (utilized more like a class library.)  Nothing connects to the CatalogDb &lt;em&gt;web API&lt;/em&gt;. The CatalogDb project contains all the Entity Framework design-time details and references, allowing you to utilize Entity Framework's features like &lt;code&gt;migrations add &amp;lt;migration-name&amp;gt;&lt;/code&gt; and &lt;code&gt;dotnet ef database update&lt;/code&gt;. The target of Entity Framework operations like migration add and database update would depend on the configuration in &lt;code&gt;appsettings.json&lt;/code&gt;. Initialization/seeding of the data is handled in &lt;code&gt;CatalogDbInitializer&lt;/code&gt; within CatalogDb, as well as migrations at run-time (startup). CatalogDb &lt;code&gt;appsettings&lt;/code&gt; connection strings must be in sync with the run-time values for &lt;code&gt;ef&lt;/code&gt; commands to work.&lt;/p&gt;
&lt;p&gt;In summary, if you want to utilize Entity Framework in a basic .NET Aspire application, &lt;a href="https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-8.0&amp;amp;tabs=visual-studio"&gt;adding a project&lt;/a&gt; to contain the entity models, context, and Entity Framework references and supporting a database engine container is a recommended place to get started. I suspect this guidance may be refined as .NET Aspire evolves.&lt;/p&gt;
&lt;p&gt;I'm still wrapping my head around how .NET Aspire can support other non-containerized workloads like Azure SQL. Still, a containerized design melds nicely with the idea of independent resources (or nodes) in .NET Aspire.  .NET Aspire also helps to more clearly delineate concerns like design, build, test, release, and deploy. As with .NET Aspire, containerization is an easier starting point for someone interested in distributed applications.&lt;/p&gt;
&lt;p&gt;I look forward to how .NET Aspire evolves.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/entity-framework-in-aspire.jpg" class="img-fluid" alt="A path through the infrastructure"&gt;&lt;/p&gt;</summary>
	</entry>
</feed>