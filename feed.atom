<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<id>http://blog.peterritchie.com/</id>
	<title>Peter Ritchie's Blog</title>
	<link rel="self" href="http://blog.peterritchie.com/" />
	<rights>2024</rights>
	<updated>2024-11-07T19:48:24Z</updated>
	<subtitle>Peter Ritchie</subtitle>
	<entry>
		<id>http://blog.peterritchie.com/posts/working-with-dto-auto-translators--mapperly</id>
		<title>Working With DTO Auto Translators -- Mapperly</title>
		<link href="http://blog.peterritchie.com/posts/working-with-dto-auto-translators--mapperly" />
		<updated>2024-11-07T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/mapping-translation.png" class="img-fluid" alt="Complicated translation" /&gt;&lt;/p&gt;
&lt;!-- Mapping/Translation series intro boilerplate --&gt;
&lt;p&gt;Modern software applications heavily rely on external services, making data transfer a crucial aspect of application functionality. Invariably, data transfer involves translating an internal representation of information to data compatible with a particular communication channel. High-level programming languages empower programmers to model abstractions in high-level types independent of lower-level implementation details. This internal representation of data is sometimes called &lt;em&gt;abstract syntax&lt;/em&gt;, which is purposely devoid of the specifics (&lt;em&gt;concrete syntax&lt;/em&gt;) required by the channel and, or the receiver. Translation from one syntax to another must first map source data elements to target data elements. That mapping includes the necessary translation method/function.&lt;/p&gt;
&lt;!-- Data Transfer Object boilerplate pull quote/box copy --&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Data Transfer Objects&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Defining concrete syntax in high-level languages is so essential that a design pattern is devoted to it. The Data Transfer Object&lt;sup&gt;[&lt;a href="https://amzn.to/3SR8c73"&gt;ppoe&lt;/a&gt;]&lt;/sup&gt; design pattern describes declaring high-level types to describe aspects of concrete syntax.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;This installment details the mapping and translation of Data Transfer Objects with a package named &lt;a href="https://github.com/riok/mapperly"&gt;&lt;code&gt;Mapperly&lt;/code&gt;&lt;/a&gt; (&lt;a href="https://www.nuget.org/packages/Riok.Mapperly/"&gt;Riok.Mapperly&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Mapperly accomplishes translation by being a .NET Source Generator, meaning the translation code is generated and exists when your application is compiled. The translation code, therefore, does not need to jump through a bunch of hoops by evaluating expressions and dynamically generating types and methods. Being a Source Generator makes Mapperly pleasantly different from other mappers like AutoMapper and Mapster. You have to declare the intent to translate from one type to another by declaring a partial method (in a partial class decorated with the &lt;code&gt;MapperAttribute&lt;/code&gt;) that tells Mapperly what the source and destination types are (the method that returns the &lt;em&gt;destination&lt;/em&gt; type and accepts the &lt;em&gt;source&lt;/em&gt; type as an argument.) The name of the class method is up to you. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Mapper]
public partial class AccountTranslator
{
	public partial AccountDto AccountToAccountDto(Account account);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mapperly determines how to translate each property based on their names and types (the default &lt;em&gt;convention&lt;/em&gt;). In our simple case, it would generate a method similar to:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;{
    public partial class AccountTranslator
    {
        [global::System.CodeDom.Compiler.GeneratedCode(&amp;quot;Riok.Mapperly&amp;quot;, &amp;quot;4.1.0.0&amp;quot;)]
        public partial global::MapperlyTests.Application.AccountDto AccountToAccountDto(global::MapperlyTests.Domain.Account account)
        {
            var target = new global::MapperlyTests.Application.AccountDto();
            target.Id = account.Id;
            target.Name = account.Name;
            target.CreationDate = account.CreationDate;
            return target;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mapperly supports immutable record types, so if you wanted to use &lt;code&gt;record&lt;/code&gt; with &lt;code&gt;AccountDto&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public record AccountDto(Guid Id, DateOnly CreationDate, string Name);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And with those immutable record types Mapperly will generate code that passes arguments to the constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;        [global::System.CodeDom.Compiler.GeneratedCode(&amp;quot;Riok.Mapperly&amp;quot;, &amp;quot;4.1.0.0&amp;quot;)]
        public partial global::MapperlyTests.Application.AccountDto AccountToAccountDto(global::MapperlyTests.Domain.Account account)
        {
            var target = new global::MapperlyTests.Application.AccountDto(account.Id, account.CreationDate, account.Name);
            return target;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Say goodbye to &lt;code&gt;ConstructUsing&lt;/code&gt; (as well as &lt;code&gt;ForMember&lt;/code&gt;, et al.)&lt;/p&gt;
&lt;h2 id="mapping-by-convention"&gt;Mapping by Convention&lt;/h2&gt;
&lt;p&gt;The raison d'etre of mapping/translation frameworks is to make translating one data type to another as simple as possible. A key feature of these frameworks is to map by convention, which automatically maps fields or properties based on criteria like name and data type. As we can see from the generated code above, Mapperly, by convention, figures out the source and target properties to translate. What's nice about Mapperly is that you can see the results of applying that convention by looking at the generated code (Ctrl-click the &lt;code&gt;partial&lt;/code&gt; method name to go to the generated code.)&lt;/p&gt;
&lt;h2 id="custom-mapping"&gt;Custom Mapping&lt;/h2&gt;
&lt;p&gt;When we start (greenfield) development, our DTOs are usually closely aligned with our domain objects, so by-convention mapping is our friend. However, an important reason for having two abstractions is that they can evolve independently. Eventually, as we gain a better understanding of the domain or clients of the communication channel, we will need to make changes that cause our DTO and Domain Objects to diverge. We can manage that divergence by extending the by-convention mapping to include custom mapping on a per-property basis. Mapperly supports this through members of the &lt;code&gt;Mapper&lt;/code&gt;-decorated class.&lt;/p&gt;
&lt;p&gt;For example, we've gained a better understanding of the domain, and an Account doesn't necessarily have a &amp;quot;name&amp;quot; but has an associated account holder with a given and family name. That understanding may make its way into the domain like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Account(Guid id, DateOnly creationDate, string accountHolderGivenName, string accountHolderFamilyName)
{
	public Guid Id { get; } = id;
	public string AccountHolderGivenName { get; private set; } = accountHolderGivenName;
	public string AccountHolderFamilyName { get; private set; } = accountHolderFamilyName;
	public DateOnly CreationDate { get; } = creationDate;

	public void ChangeName(string accountHolderGivenName, string accountHolderFamilyName)
	{
		AccountHolderGivenName = accountHolderGivenName;
		AccountHolderFamilyName = accountHolderFamilyName;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Receivers of our &lt;code&gt;AccountDto&lt;/code&gt; might be unable to accommodate that change immediately, so we may deal with that by mapping properties differently. Instead of including &lt;code&gt;FamilyName&lt;/code&gt; and &lt;code&gt;GivenName&lt;/code&gt; in this version of &lt;code&gt;AccountDto&lt;/code&gt;, we may concatenate the given and family name and assign it to &lt;code&gt;AccountDto.Name&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can configure this type of two properties to one property conversion with the &lt;code&gt;MapPropertyFromSource&lt;/code&gt; attribute. More than just the name of the two properties is needed for Mapperly to automatically figure out what to do (concatenate, concatenate with delimiter, etc.). So, we use &lt;code&gt;MapPropertyFromSource&lt;/code&gt; to point to a method that takes the source type and returns an instance of a type assignable to the destination property.  In this example, a &lt;code&gt;MapGivenFamilyNames&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Mapper]
public partial class AccountTranslator
	: IAccountTranslator
{
	[MapPropertyFromSource(target: nameof(AccountDto.Name), Use = nameof(MapGivenFamilyNames))]
	public partial AccountDto AccountToAccountDto(Account account);
	private string MapGivenFamilyNames(Account account)
	{
		return account.AccountHolderGivenName + ' ' + account.AccountHolderFamilyName;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mapperly supports arrays of strings for &lt;code&gt;target&lt;/code&gt; so you can map to nested properties of properties.&lt;/p&gt;
&lt;p&gt;Mapperly also supports property-to-property mapping of properties that a simple matching strategy wouldn't match.  Given the same client application constraints and the domain understanding uncovered that the &lt;code&gt;Name&lt;/code&gt; property doesn't fit in the ubiquitous language but &lt;code&gt;FullName&lt;/code&gt; does, we would use &lt;code&gt;MapPropertyAttribute&lt;/code&gt; to tell Mapperly how to assign the &lt;code&gt;AccountDto.Name&lt;/code&gt; property:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Mapper]
public partial class AccountTranslator
	: IAccountTranslator
{
	[MapProperty(source: nameof(AccountDto.Name), target: nameof(Account.FullName))]
	public partial AccountDto AccountToAccountDto(Account account);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;NOTE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;The constructor for &lt;code&gt;MapPropertyFromSourceAttribute&lt;/code&gt; has only one parameter, the &lt;code&gt;target&lt;/code&gt;.  The constructor for &lt;code&gt;MapPropertyAttribute&lt;/code&gt; has two, the &lt;code&gt;source&lt;/code&gt; and the &lt;code&gt;target&lt;/code&gt;, so it &lt;em&gt;may look like&lt;/em&gt; the parameters are in a different order. C#'s &lt;em&gt;named arguments&lt;/em&gt; shines here to clarify intent.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Technically, attributes like &lt;code&gt;MapPropertyFromSourceAttribute&lt;/code&gt; and &lt;code&gt;MapPropertyAttribute&lt;/code&gt; work with string names of classes and members. Use the &lt;code&gt;name of&lt;/code&gt; expression so that identifiers get used at compile-time, as seen in the above example.&lt;/p&gt;
&lt;h2 id="but-wait-theres-more"&gt;But Wait, There's More&lt;/h2&gt;
&lt;p&gt;A benefit of being a Source Generator is that Mapperly can generate compiler/analyzer warnings when not all properties are mapped from or to.  If you're following along and you updated &lt;code&gt;Account&lt;/code&gt;, renaming &lt;code&gt;Name&lt;/code&gt; to &lt;code&gt;FullName&lt;/code&gt;, you would have noticed RMG020 and RMG012 warnings:&lt;/p&gt;
&lt;p&gt;&lt;img src="../assets/mapperly-unmapped-member-warning.png" class="img-fluid" alt="RMG020 and RMG012 warnings" /&gt;&lt;/p&gt;
&lt;h2 id="dependency-injections-with-mapperly"&gt;Dependency Injections with Mapperly&lt;/h2&gt;
&lt;p&gt;Other mappers have initialization and startup requirements making their use in Dependency Injection more than just registering an implementation of an interface (&lt;code&gt;services.AddScoped&amp;lt;ITheInterface, TheImplementation&amp;gt;();&lt;/code&gt;) and require an &lt;code&gt;Add{Technology}()&lt;/code&gt; method call (like &lt;code&gt;AddMapster&lt;/code&gt; or &lt;code&gt;AddAutoMapper&lt;/code&gt;.) Since Mapperly generates the translation code at compilation, you only have to register the translating type (e.g., &lt;code&gt;services.AddScoped&amp;lt;AccountTranslator&amp;gt;()&lt;/code&gt;) and declare the dependency in the constructors of types that need to invoke translators (e.g., &lt;code&gt;public class AccountService(AccountTranslator accountTranslator){/*...*/}&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;If you're interface-obsessed when it comes to Dependency Injection, you're free to create an interface to use and configure your services appropriately, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IAccountTranslator
{
	public AccountDto AccountToAccountDto(Account account);
}
//...
[Mapper]
public partial class AccountTranslator
	: IAccountTranslator
{
	public partial AccountDto AccountToAccountDto(Account account);
}
//...
services.AddScoped&amp;lt;IAccountTranslator, AccountTranslator&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then declare the dependency in the constructors of types that need to invoke translators (e.g., &lt;code&gt;public class AccountService(IAccountTranslator accountTranslator){/*...*/}&lt;/code&gt;.)&lt;/p&gt;
&lt;h2 id="where-does-mapping-and-translation-occur"&gt;Where Does Mapping and Translation Occur?&lt;/h2&gt;
&lt;p&gt;Data transfer can occur in different layers. Data transfer triggers a website or API (presentation layer); the application layer requests external services via an infrastructure layer to transfer data to and from. I'm often asked where that mapping and translation source code should exist and in which project in the solution. It's important to remember that we're dealing with multiple layers. The presentation layer is typically where the process entry point is, so initialization (DI container configuration) occurs here. That initialization depends at least indirectly on the translation code to configure services that perform the translation.&lt;/p&gt;
&lt;p&gt;Translation of web/API models exist in the presentation layer because that's where &lt;em&gt;that&lt;/em&gt; data transfer occurs. It can get complex when more layers are in their own project or are their own artifact. I recommend that DTOs live in the project where the data transfer occurs because they should be viewed as an implementation detail of the facade/adapter performing the data transfer. This typically means that the translation codes lives along side the DTOs because you want to keep implementation details encapsulated. The translation should be made available through an interface that is configured by your Dependency Injection container. I'll leave the complexity of doing that in the context of project-scoped layers for another post.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;NOTE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;Regardless of whether you have multiple presentation layers or an independent application layer, translation logic &lt;em&gt;should not&lt;/em&gt; be a responsibility in the Domain layer.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/mapping-translation.png" class="img-fluid" alt="Complicated translation"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/naming-things--generic-actions</id>
		<title>Naming things: Actions</title>
		<link href="http://blog.peterritchie.com/posts/naming-things--generic-actions" />
		<updated>2024-10-24T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/overwhelming-possibilities.png" class="img-fluid" alt="Overwhelming Possibilities" /&gt;&lt;/p&gt;
&lt;p&gt;A few years ago, I decided to look into &lt;em&gt;why&lt;/em&gt; naming is hard. That spawned a conference talk that I've done several times. Part of what I present in that talk is my observations of working with many teams regarding establishing names for generic actions applicable in their unique domain.&lt;/p&gt;
&lt;h2 id="actions-activities-operations-events-occurrences-oh-my"&gt;Actions, Activities, Operations, Events, Occurrences, Oh My&lt;/h2&gt;
&lt;p&gt;Generic actions have many synonyms. Without considering different words to mean the same thing, the names of things in the code related to generic actions added a noticeable cognitive load to the initial understanding of the domain. Let's look at what I mean by &lt;em&gt;generic actions&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In a domain, things &lt;em&gt;happen&lt;/em&gt; to domain objects. Many of these actions can be considered &amp;quot;updates,&amp;quot; but it's more fine-grained. For example, here's a table of some verbs that could mean some sort of &lt;em&gt;update&lt;/em&gt; in most domains:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;Add     Create   Generate  Build   Construct  Initialize  Make    Establish
Update  Change   Modify    Mutate  Alter      Revise      Adjust  Transform
Delete  Destroy  Remove    Erase   Move       Release     Pull    Withdraw
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It's extremely unlikely that there are 24 distinct mutating actions in any domain. Most domains work on a CRUD model where, besides Read, there are &lt;code&gt;Create&lt;/code&gt;, &lt;code&gt;Update&lt;/code&gt;, and &lt;code&gt;Delete&lt;/code&gt;. Unfortunately, three mutating actions are typically too coarse-grained and can be unrepresentative of the domain language.&lt;/p&gt;
&lt;p&gt;Spending a short time creating a happy medium is valuable: making a brief list of the terms used for the generic domain actions. The list should be imperative verbs that can be (or are) transitive (that is, they can refer to an object. e.g., &amp;quot;arrive&amp;quot; is a verb that cannot be transitive).&lt;/p&gt;
&lt;p&gt;Once there is agreement on the generic actions that apply to the domain, establishing a similar list of events further increases value. That list should be the action verbs in past participle form. For example, if &amp;quot;create&amp;quot; is an action in the domain, then the event that describes it would be the past participle form of &amp;quot;create&amp;quot;: &amp;quot;created.&amp;quot;&lt;/p&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;p&gt;Each domain is unique, so make sure these terms work for yours.&lt;/p&gt;
&lt;h3 id="actions"&gt;Actions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Create&lt;/code&gt;&lt;/strong&gt; - to bring something into existence. Contrast with Add. See also &lt;code&gt;Destroy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Add&lt;/code&gt;&lt;/strong&gt; - to add something (already created) to a container or collection. See also &lt;code&gt;Remove&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Update&lt;/code&gt;&lt;/strong&gt; - to change the value of one or properties of an object. Contrast with &lt;code&gt;Change&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Change&lt;/code&gt;&lt;/strong&gt; - to replace an entire instance with another instance.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Delete&lt;/code&gt;&lt;/strong&gt; - to remove access to something in some context. Contrast with &lt;code&gt;Destroy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Destroy&lt;/code&gt;&lt;/strong&gt; - to eliminate something from existence, the opposite of Create. Contrast with &lt;code&gt;Delete&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Remove&lt;/code&gt;&lt;/strong&gt; - to remove something from a container or collection, the opposite of Add. Contrast with &lt;code&gt;Delete&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Modify&lt;/code&gt;&lt;/strong&gt; - to modify the structure or schema of something. Contrast with &lt;code&gt;Update&lt;/code&gt; and &lt;code&gt;Change&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This list should be a stretch for most domains. Many domains don't have a concept of &lt;em&gt;modifying&lt;/em&gt; schema or &lt;em&gt;changing&lt;/em&gt; instances. Further still, I have found that most domains either &lt;code&gt;Delete&lt;/code&gt; or &lt;code&gt;Destroy&lt;/code&gt; data. This leaves &lt;code&gt;Create&lt;/code&gt;, &lt;code&gt;Delete&lt;/code&gt;, &lt;code&gt;Add&lt;/code&gt;, &lt;code&gt;Remove&lt;/code&gt;, and &lt;code&gt;Update&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Remember that this example list is designed to be generic--actions not likely to be domain-specific. In your ubiquitous language, you will still have other terms to refer to domain-specific actions. e.g., you may &lt;code&gt;Correct&lt;/code&gt; an Address in the domain to signify an &lt;code&gt;Update&lt;/code&gt; or &lt;code&gt;Change&lt;/code&gt; to an Address to differentiate it from a &lt;code&gt;Move&lt;/code&gt; concept. Or a domain might have a &lt;code&gt;Restore&lt;/code&gt; behavior as a specialized type of &lt;code&gt;Update&lt;/code&gt; or &lt;code&gt;Change&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I recommend establishing a similar list of event names that is effectively the same list of verbs for the actions but in past participle form:&lt;/p&gt;
&lt;h3 id="events"&gt;Events&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Created&lt;/code&gt;&lt;/strong&gt; - something was brought into existence. Contrast with &lt;code&gt;Added&lt;/code&gt;. See also &lt;code&gt;Destroyed&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Added&lt;/code&gt;&lt;/strong&gt; - something (already created) was added to a container or collection. See also &lt;code&gt;Removed&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Updated&lt;/code&gt;&lt;/strong&gt; - the value of one or properties of an object was changed. Contrast with &lt;code&gt;Changed&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Changed&lt;/code&gt;&lt;/strong&gt; - an entire instance was replaced with another instance.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Deleted&lt;/code&gt;&lt;/strong&gt; - access to something was removed in some context. Contrast with &lt;code&gt;Destroyed&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Destroyed&lt;/code&gt;&lt;/strong&gt; - something was eliminated from existence, the opposite of &lt;code&gt;Created&lt;/code&gt;. Contrast with &lt;code&gt;Deleted&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Removed&lt;/code&gt;&lt;/strong&gt; - something was removed from a container or collection, the opposite of &lt;code&gt;Added&lt;/code&gt;. Contrast with &lt;code&gt;Deleted&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Modified&lt;/code&gt;&lt;/strong&gt; - the structure or schema of something was modified. Contrast with &lt;code&gt;Updated&lt;/code&gt; and &lt;code&gt;Changed&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This list of events could be similarly optimized as &lt;code&gt;Created&lt;/code&gt;, &lt;code&gt;Deleted&lt;/code&gt;, &lt;code&gt;Added&lt;/code&gt;, &lt;code&gt;Removed&lt;/code&gt;, and &lt;code&gt;Updated&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;My experience has been that establishing and communicating lists like these work well in avoiding ambiguity and establishing clarity. Most domains are complex, but clarifying the names of generic actions can make a noticeable difference in understandability and approachability. I've even found that this level of attention to naming makes the code base more agile.&lt;/p&gt;
&lt;p&gt;In the comments, I'd love to hear what generic actions apply to your domain if these don't apply.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/overwhelming-possibilities.png" class="img-fluid" alt="Overwhelming Possibilities"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/avoiding-identity-obsession-in-dotnet-with-entity-framework-core</id>
		<title>Avoiding Identity Obsession in .NET with Entity Framework Core</title>
		<link href="http://blog.peterritchie.com/posts/avoiding-identity-obsession-in-dotnet-with-entity-framework-core" />
		<updated>2024-10-01T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/technological-layers.png" class="img-fluid" alt="Complicated translation" /&gt;&lt;/p&gt;
&lt;p&gt;In a &lt;a href="identity-obsession-and-domain-driven-design"&gt;previous post&lt;/a&gt;, I introduced Identity Obsession. Identity Obsession can introduce race conditions relating to consistency with Domain Entities and other complexity. In that post, I point out that most entities have an inherent (implicit) local identity and that any additional global Identifiers are due to persistence (RDBMS) implementation details. I recommended that Identifiers be something in your persistence layer rather than your Domain layer. I won't rehash that post more than that here, but you may want to read that first.&lt;/p&gt;
&lt;p&gt;It can be perceived as &lt;em&gt;easy for me to say&lt;/em&gt; when it comes to design constraints of Aggregates and Entities when implementing the persistence layer. This perception is probably most apparent with technologies like Entity Framework Core (EF) and that Entity Framework's support for Domain-Driven Design has been an afterthought. When dealing with external sources and targets of data, the Data Transfer Object pattern is recommended. Technically, EF supports persistence via DTOs.&lt;/p&gt;
&lt;p&gt;Entity Framework can rarely do what it does out-of-the-box, provided classes are designed with a Domain-Driven Design mindset. Impedance Mismatch rears its ugly head resulting in translating data to/from the limited data types that databases tend to have (see &lt;code&gt;HasConversion&lt;/code&gt;, &lt;code&gt;HasKey&lt;/code&gt;, et al.) Despite best practices that recommend that Entities be implemented as POCOs and relational mapping be configured with fluent builders—outside of the Domain Layer—the needs and constraints of databases can easily leak into the design and evolution of Domain Objects.&lt;/p&gt;
&lt;p&gt;In this post, I will provide an example of configuring Entity Framework to work with Domain Objects that don't suffer from Identity Obsession. The scenario (or use-case) I'll show with this Domain Object is onboarding a Client to the point they will have a Domain Identifier assigned. The Domain I introduced in my previous post involved SSNs; we can presume the Social Security Administration would be the Domain context. I'm sure none of my readers work in this context, but I believe it to be understandable by many people, making it a good example of Domain Identity. For my Canadian friends, replace &amp;quot;SSN&amp;quot; with &amp;quot;SIN&amp;quot; and &amp;quot;Social Security Administration&amp;quot; with &amp;quot;Service Canada.&amp;quot;&lt;/p&gt;
&lt;p&gt;Entity Framework is a persistence/infrastructure implementation detail, and the Repository Pattern is used to isolate those details from the Domain. I gave an example repository in my previous post; for this example, I've expanded it to support asynchronous and the Result Pattern:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IClientRepository
{
    Task&amp;lt;Result&amp;lt;Client&amp;gt;&amp;gt; FindBySsnAsync(Ssn ssn, CancellationToken cancellationToken);
    Task&amp;lt;Result&amp;gt; SaveAsync(Client client, CancellationToken cancellationToken);
    Task&amp;lt;Result&amp;lt;Ssn&amp;gt;&amp;gt; AddAsync(Client client, CancellationToken cancellationToken);
	Task&amp;lt;Result&amp;lt;IEnumerable&amp;lt;Client&amp;gt;&amp;gt;&amp;gt; FindClientsAsync(CancellationToken cancellationToken);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This Repository provides the ability to find a Client by SSN (&lt;code&gt;FindBySsnAsync&lt;/code&gt;), save a &lt;code&gt;Client&lt;/code&gt; after being updated (&lt;code&gt;SaveAsync&lt;/code&gt;), and add a new &lt;code&gt;Client&lt;/code&gt; by allocating a new SSN (&lt;code&gt;AddAsync&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;Elements within a container naturally have container Identity. The container understands how to identify individual elements based on an identifier. Contained elements, therefore, do not also have to take on that burden. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Client(string givenName, string familyName)
    : Person(givenName, familyName)
{
    public void ChangeName(string givenName, string familyName)
    {
        GivenName = givenName;
        FamilyName = familyName;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I've expanded &lt;code&gt;Client&lt;/code&gt; to support an update scenario (&lt;code&gt;ChangeName&lt;/code&gt;) so that there is Domain behavior.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Quote&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;&amp;quot;All models are wrong, but some are useful&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The use-case of working with a Domain Object (&lt;code&gt;Client&lt;/code&gt;) before needing an SSN to be persisted might follow a sequence like this:&lt;/p&gt;
&lt;p&gt;&lt;img src="../assets/onboarding-client-use-case.png" class="img-fluid" alt="sequence" /&gt;&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;Client&lt;/code&gt; instance exists for a time before a Domain Identifier is allocated for it. However, our database requires an SSN for each client record. So, we need to configure Entity Framework to accommodate that detail and include a primary key. We do that through an &lt;code&gt;IEntityTypeConfiguration&amp;lt;T&amp;gt;&lt;/code&gt; implementation like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class ClientEntityTypeConfiguration : IEntityTypeConfiguration&amp;lt;Client&amp;gt;
{
    public void Configure(EntityTypeBuilder&amp;lt;Client&amp;gt; builder)
    {
        // Create a string &amp;quot;Id&amp;quot; Shadow Property to hold GUID values
        builder.Property&amp;lt;string&amp;gt;(ColumnNames.Id)
            .HasColumnType(&amp;quot;varchar(36)&amp;quot;)
            .HasMaxLength(36);
        builder.HasKey(ColumnNames.Id);

        // Create a string &amp;quot;Ssn&amp;quot; Shadow Property that uses the type Sss,
        // with conversion
        builder.Property&amp;lt;Ssn&amp;gt;(ColumnNames.Ssn)
            .HasColumnType(&amp;quot;varchar(11)&amp;quot;)
            .HasMaxLength(11)
            .HasConversion(ssn =&amp;gt; ssn.ToString(), value =&amp;gt; Ssn.Parse(value))
            .IsRequired();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As with any &lt;code&gt;IEntityTypeConfiguration&amp;lt;T&amp;gt;&lt;/code&gt; implementation, we're configuring the primary key and other properties with property-specific requirements. This implementation may differ from other implementations because we're configuring &lt;em&gt;shadow properties&lt;/em&gt; for our identifiers. The &lt;code&gt;DbContext&lt;/code&gt; implementation will be responsible for the persistence concern of generating the primary key value, and the repository will be responsible for the Domain concern of generating the Domain Identifier (SSN).&lt;/p&gt;
&lt;p&gt;Let's look at that &lt;code&gt;DbContext&lt;/code&gt; implementation (I'm using SQLite for this implementation):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class DatabaseContext : DbContext
{
	protected override void OnModelCreating(ModelBuilder modelBuilder)
	{
		modelBuilder.ApplyConfiguration(new ClientEntityTypeConfiguration());

		base.OnModelCreating(modelBuilder);
	}

	public async Task&amp;lt;Result&amp;lt;Client&amp;gt;&amp;gt; GetClientBySsnAsync(Ssn ssn, CancellationToken cancellationToken)
	{
		var client = await Clients
			.SingleOrDefaultAsync(c =&amp;gt; EF.Property&amp;lt;Ssn&amp;gt;(c, ColumnNames.Ssn) == ssn, cancellationToken);

		return client ?? Result&amp;lt;Client&amp;gt;.NotFound();
	}

	public async Task&amp;lt;Result&amp;lt;Client&amp;gt;&amp;gt; GetClientByIdAsync(Guid id, CancellationToken cancellationToken)
	{
		var client = await Clients
			.SingleOrDefaultAsync(c =&amp;gt; EF.Property&amp;lt;string&amp;gt;(c, ColumnNames.Id) == id.ToString(), cancellationToken);

		return client ?? Result&amp;lt;Client&amp;gt;.NotFound();
	}

	public Result&amp;lt;Ssn&amp;gt; GetClientSsn(Client client)
	{
		var entry = Entry(client);
		var currentValue = entry.Property(ColumnNames.Ssn).CurrentValue as Ssn;

		return currentValue ?? Result&amp;lt;Ssn&amp;gt;.NotFound();
	}

	public async Task AddClientAsync(Client client, Ssn ssn, CancellationToken cancellationToken)
	{
		var entry = Entry(client);
		entry.Property(ColumnNames.Ssn).CurrentValue = ssn;
		entry.Property(ColumnNames.Id).CurrentValue = Guid.NewGuid().ToString();
		await AddAsync(client, cancellationToken);

		await SaveChangesAsync(cancellationToken);
	}
	public DbSet&amp;lt;Client&amp;gt; Clients { get; set; }

	protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
	{
		optionsBuilder.UseSqlite($&amp;quot;Data Source={DataSourcePath}&amp;quot;);
	}

	public static string DataSourcePath {
		get
		{
			var localAppDataPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
			return Path.Join(localAppDataPath, &amp;quot;clients.db&amp;quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notable is &lt;code&gt;AddClientAsync&lt;/code&gt;, where it accepts an &lt;code&gt;Ssn&lt;/code&gt; value, sets the shadow property value for that database column, and generates the primary key by calling &lt;code&gt;Guid.NewGuid()&lt;/code&gt;. &lt;code&gt;DatabaseContext&lt;/code&gt; encapsulates the implementation detail of shadow properties. I've chosen to generate a&lt;code&gt;Guid&lt;/code&gt; in code rather than by the database for clarity. As a database concern, it could go either way. Also notable is the method &lt;code&gt;GetClientSsn&lt;/code&gt;, which shows how an SSN can be obtained outside the Domain (e.g., for Presentation concerns.)&lt;/p&gt;
&lt;p&gt;Next, let's look at an implementation of &lt;code&gt;IClientRepository&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class ClientRepository(DatabaseContext dbContext, ISsnRegistry ssnRegistry) : IClientRepository
{
	private readonly DatabaseContext dbContext = dbContext;
	private readonly ISsnRegistry ssnRegistry = ssnRegistry;

	public Task&amp;lt;Result&amp;lt;IEnumerable&amp;lt;Client&amp;gt;&amp;gt;&amp;gt; FindClientsAsync(CancellationToken _)
	{
		Result&amp;lt;IEnumerable&amp;lt;Client&amp;gt;&amp;gt; result = dbContext.Clients;
		return Task.FromResult(result);
	}

	public Task&amp;lt;Result&amp;lt;Client&amp;gt;&amp;gt; FindBySsnAsync(Ssn ssn, CancellationToken cancellationToken)
	{
		return dbContext.GetClientBySsnAsync(ssn, cancellationToken);
	}

	public async Task&amp;lt;Result&amp;lt;Ssn&amp;gt;&amp;gt; AddAsync(Client client, CancellationToken cancellationToken)
	{
		var reservationResult = ssnRegistry.Reserve();
		if (reservationResult.IsError()) return Result&amp;lt;Ssn&amp;gt;.Error();

		using var ssnReservation = reservationResult.Value;
		Ssn newSsn = new(ssnReservation.Value);
		await dbContext.AddClientAsync(client, newSsn, cancellationToken);
		await dbContext.SaveChangesAsync(cancellationToken);
		ssnReservation.Commit();
		return newSsn;
	}

	public async Task&amp;lt;Result&amp;gt; SaveAsync(Client client, CancellationToken cancellationToken)
	{
		var entry = dbContext.Entry(client);
		switch (entry.State)
		{
			case EntityState.Detached:
				{
					var addResult = await AddAsync(client, cancellationToken);
					return addResult.IsSuccess
						? Result.Success()
						: Result.CriticalError(addResult.Errors.ToArray());
				}
			case EntityState.Modified:
				await dbContext.SaveChangesAsync(cancellationToken);
				return Result.Success();
			default:
				return Result.Success();
		}
	}

	public Result&amp;lt;Ssn&amp;gt; GetClientSsn(Client client)
	{
		return dbContext.GetClientSsn(client);
	}

	public Task&amp;lt;Result&amp;lt;Client&amp;gt;&amp;gt; FindByIdAsync(Guid id, CancellationToken cancellationToken)
	{
		return dbContext.GetClientByIdAsync(id, cancellationToken);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since the primary key and the SSN storage is a Persistence concern, the &lt;code&gt;DbContext&lt;/code&gt; implementation is where the logic to work with Shadow Properties lives.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SaveAsync&lt;/code&gt; and &lt;code&gt;FindBySsnAsync&lt;/code&gt; simply encapsulate &lt;code&gt;DbContext.SaveChangesAsync&lt;/code&gt; and &lt;code&gt;DatabaseContext.GetClientBySsnAsync&lt;/code&gt; respectively. &lt;code&gt;FindClientsAsync&lt;/code&gt; finds all the client instances (typically, this would have a filter, which I've omitted for clarity.) SSN allocation is outside the scope of this post. But, because SSN allocation is a Domain concern, I'll show where it might fit in an orchestration with &lt;code&gt;DatabaseContext&lt;/code&gt; within &lt;code&gt;AddAsync&lt;/code&gt; (using a fictitious &lt;code&gt;ISsnRegistry&lt;/code&gt; object that manages generating/reserving then committing an SSN value--completing/committing the reserved value if it is successfully persisted to the database.) I've included &lt;code&gt;GetClientSsn&lt;/code&gt; as an example of how an SSN can be obtained outside the Domain (e.g., for Presentation concerns.) Also, I've included &lt;code&gt;FindByIdAsync&lt;/code&gt; as an example of how we can find a &lt;code&gt;Client&lt;/code&gt; instance based on a primary key value.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Caveat&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;Storing SSNs in a database is frowned upon. This example is for clarity, the value should be hashed or encrypted before storing in the database. Look ups based on last-four &amp;amp; name are beyond the scope of this post&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;Entity Framework makes mapping Entity properties to columns in a relational database easy. But don't let that ease of use let Persistence concerns leak into your Domain. With a clear understanding of what Domain concerns are, what Persistence concerns are, and what Presentation concerns are Entity Framework can easily be leveraged to support loosely coupling the Persistence concerns from Entities.&lt;/p&gt;
&lt;p&gt;The code from this post can be found in &lt;a href="https://github.com/peteraritchie/IdentityObsession"&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/technological-layers.png" class="img-fluid" alt="Complicated translation"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/identity-obsession-and-domain-driven-design</id>
		<title>Identity Obsession and Domain-Driven Design</title>
		<link href="http://blog.peterritchie.com/posts/identity-obsession-and-domain-driven-design" />
		<updated>2024-09-26T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/mind-map.png" class="img-fluid" alt="Complicated translation" /&gt;&lt;/p&gt;
&lt;p&gt;Domain-Driven Design builds on established ontological concepts like Identity, Entities, and characteristics. Entities in either context are constructs with &lt;em&gt;Identity&lt;/em&gt;. Entities are recognizable instances of higher-level classifications. Entities are recognized not just by their characteristics or qualities. Ontologically, an Entity's Identity can be numerical &lt;em&gt;or&lt;/em&gt; philosophical. In software, explicit Identity is always implemented &lt;em&gt;numerically&lt;/em&gt; (that is, an Identifier that is compared by value.) In either context, Identity can be &lt;em&gt;implicit&lt;/em&gt; or &lt;em&gt;explicit&lt;/em&gt;, too often explicit in software.&lt;/p&gt;
&lt;p&gt;Domain-Driven Design categorizes Identity as either &lt;em&gt;global&lt;/em&gt; or &lt;em&gt;local&lt;/em&gt;. I have found that too often, only global Identity is implemented or recognized—which may be due to the explicitness of global Identity. I have also observed the over-use of Identity (explicit and global.) I'm calling this phenomenon &amp;quot;Identity Obsession,&amp;quot; I'll explain it by comparing it to what helped inspire it: Primitive Obsession.&lt;/p&gt;
&lt;p&gt;There's a code smell called Primitive Obsession&lt;sup&gt;[&lt;a href="https://amzn.to/3Y05vTq"&gt;Refactoring&lt;/a&gt;]&lt;/sup&gt;, where domain-specific concepts are implemented in object-oriented languages as primitive (or built-in) types instead of custom types. Domain concepts are domain concepts because they are unique to a domain, so it's unlikely they would be on parity with anything in another, independent, domain; especially a technical concept like an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;. Primitive Obsession exists to help recognize that a custom type is necessary embody unique constraints over and above any implementation details of a primitive type.&lt;/p&gt;
&lt;p&gt;Like Primitive Obsession, &lt;em&gt;Identity Obsession&lt;/em&gt; occurs due to the influence of implementation details. In the case of Identity Obsession, those implementation details are typically &lt;em&gt;the possibility&lt;/em&gt; of an RDBMS being involved.&lt;/p&gt;
&lt;p&gt;But first, let's align on &lt;em&gt;Identity&lt;/em&gt; in Domain-Driven Design. Something has an Identity when you can differentiate it from something beyond its qualities or attributes. The obsession is that &lt;em&gt;implemented&lt;/em&gt; Domain Objects are given a globally unique Identifier (as opposed to locally unique) that habitually manifests as an &lt;code&gt;Id&lt;/code&gt; property on the Domain Object's implementation. It's not uncommon for me to see &lt;em&gt;modeled&lt;/em&gt; Domain Objects (i.e., abstract concepts) given a globally unique Identifier attribute—that is, modeled to include a value with unique characteristics (auto-incrementing or universally unique) at a time when implementation details are yet to be considered.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Identity Obsession&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;All Entities are modeled with an Identifier and all implemented Entities have a public &lt;code&gt;Id&lt;/code&gt; property whether they are necessary or not&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;It's important to remember that one, Domain Objects can be differentiated from one another by more than an assignable property, and two, Domain Objects may have more than one Identity. Arguably, not all Identities are that of the &lt;em&gt;Domain Object&lt;/em&gt; (and others are the Identity of a DTO or the database row), but that's another symptom of the obsession. Let's look at a Domain Identity.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Note&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;An Entity doesn't need to differentiate itself from another instance of an Entity, it knows who it is&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;In many domains, an Entity called &amp;quot;Account&amp;quot; exists. Abstractly, it has a Domain-specific Identity used within the domain to identify one physical account from another. The type and value of that Identifier depends on the domain—typically, it's textual and has format/structure rules. Social Security Numbers, for example, have a textual structure of &lt;code&gt;123-45-6789&lt;/code&gt; (&amp;quot;textual&amp;quot;, not &amp;quot;string&amp;quot; to avoid Primitive Obsession).&lt;/p&gt;
&lt;p&gt;A Domain-specific Identity is a part of the Domain whether there are technical implementations related to that Domain or not. Upon recognition or observance of that Identity, it becomes part of the Ubiquitous Language and independent of implementation details and constraints. The Identifier of the Domain Identity is sometimes not used as the implemented Identifier. That Identifier value has unique characteristics in technical solutions within the Domain, but that doesn't mean that the Domain Identifier is also the technical solution's unique Identifier. When implementing storage, there are many reasons why I don't want the Domain Identifier to be the &lt;em&gt;primary key&lt;/em&gt; and I would choose another value and probably a different primitive type for the implementation, like a UUID/GUID. Similarly, when implementing an API, I may not want to use an SSN within a URI or the primary key from the storage implementation. In this case, there are three &lt;em&gt;concrete Identifiers&lt;/em&gt; for the one abstract concept.&lt;/p&gt;
&lt;p&gt;Both Entities and Value Objects can have Identity. As Domain-Driven Design practitioners, it's ingrained in us that an Entity has Identity and that often manifests as an &lt;code&gt;Id&lt;/code&gt; property on an Entity implementation. But it shouldn't be that way. As a &lt;em&gt;global&lt;/em&gt; Identity, it should not be managed by the Entity to which it is assigned. The Identity is meaningless within the implementation class of an Entity. Identity is a higher-level concept from the concept it applies to. Something needs to manifest an &lt;em&gt;Identifier&lt;/em&gt; and an Entity must be consistent upon creation, so the Entity itself cannot be responsible for creating its own Identifier. The &lt;em&gt;Identifier&lt;/em&gt; is in fact an implementation detail. Management of that Identifier is typically the responsibility of a service, often a Repository service since that's when global Identity is required.&lt;/p&gt;
&lt;p&gt;An Entity that requires an Identifier upon creation (and to thus be always consistent) in an object oriented language needs that Identifier to be passed in during construction or calculated within the Entity during construction. In the first scenario, instantiation of an Entity is now coupled to something responsible for the generation of Identifiers.  In the second scenario the Entity implementation has taken on too much responsibility. At best case it implements an algorithm for generating a globally unique Identifier.  At worst case it has to take on responsibility of the Identity semantics, like rules, validation, etc. Let's look at a naive example of an Entity that uses an SSN as an Identifier;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Client : Person
{
    public Client(string givenName, string familyName, Ssn ssn)
        : base(givenName, familyName)
    {
        Ssn = ssn;
    }
    public Client(string givenName, string familyName, ISsnGenerator ssnGenerator)
        : base(givenName, familyName)
    {
        Ssn = ssnGenerator.Generate();
    }

    public Ssn Ssn { get; }
}
//...
public interface IClientRepository
{
    void Save(Client client);
    Result&amp;lt;Client&amp;gt; FindBySsn(Ssn ssn);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Constructing a &lt;code&gt;Client&lt;/code&gt; instance is problematic with either of these constructors. One problem is the life of an SSN. What if an instantiation of a Client doesn't need to be persisted or is destroyed before it gets persisted? SSNs are a limited resource and need to be accounted for. We can't reserve one by generating it and not release it if it never gets used. We &lt;em&gt;could&lt;/em&gt; expand on this to include something silly like an &lt;code&gt;ISsnManager&lt;/code&gt; but now &lt;code&gt;Client&lt;/code&gt; needs to understand when it does or does not get persisted. This can't accommodate exceptional situations where a &lt;code&gt;Client&lt;/code&gt; instance is destroyed without warning. This implemented behavior is equivalent of a domain that allows residents of the USA to create and assign their own SSNs. Can you imagine the problems this would create? One may say that this is unique to SSNs and you wouldn't have this problem with &lt;code&gt;Guid&lt;/code&gt;s. This is a naive point of view due to a perception that it's safe to throw away GUID values due to an implementation detail. There are multiple race conditions between when an new &lt;code&gt;Client&lt;/code&gt; exists and when they are persisted to the system. Because of that reality, and that Repositories aren't Factories, the only solution is the &lt;code&gt;Client&lt;/code&gt; class not to have an SSN property:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Client(string givenName, string familyName)
    : Person(givenName, familyName);
//...
public interface IClientRepository
{
    Result&amp;lt;Ssn&amp;gt; Save(Client client);
    Result&amp;lt;Client&amp;gt; FindBySsn(Ssn ssn);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this implementation, SSN generation is deferred until a &lt;code&gt;Client&lt;/code&gt; is persisted in the system. If the destruction of a &lt;code&gt;Client&lt;/code&gt; occurs before being persisted, the system generates no SSN, and the release of the SSN is no longer an issue. The implementation of SSN generation and persistence still needs to account for failure, but that can handled &lt;em&gt;transactionally&lt;/em&gt; and that responsibility can live where it belongs, outside of the Domain. SSN generation is still a domain concept, but how an allocated value is transactionally assigned is an implementation detail of the chosen infrastructure.&lt;/p&gt;
&lt;p&gt;This implement doesn't impose SSN be a primary key, this implementation simply recognizes SSN as a Domain Identifier. Implementation details within the infrastructure are free to use another Identifier for a primary key—if that applies at all in the chosen infrastructure.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Note&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;Nested objects implicitly have Identifiers that are field or property names.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="implicit-local-domain-identifiers"&gt;Implicit Local Domain Identifiers&lt;/h2&gt;
&lt;p&gt;Another aspect of Identity Obsession is the failure to recognize implicit local Identity, which is most common with Aggregates. The idea behind Aggregates is that it is a group of Domain Objects considered a unit with unit-wide consistency requirements. Similar to our Client SSN example, because an Aggregate is a consistency boundary, operations on the Aggregate become part of a &lt;em&gt;transaction&lt;/em&gt;. Entities composed within an Aggregate are implementation details accessible only through the interface provided by the Aggregate. Those Entities are owned by the Aggregate, meaning the Aggregate controls their lifecycle, including their construction and assignment of an Identifier. The transaction race conditions also arise with Aggregates: global Identifiers are meaningless until the Aggregate is persisted. That is, an Entity with global Identity made available as a property of an Aggregate is problematic due to those race conditions I mentioned earlier. You can't reliably realize global Identity until the Aggregate is persisted, but the Aggregate still needs to differentiate all the Domain Objects it owns. This means owned Domain Objects have &lt;em&gt;local Identity&lt;/em&gt;.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Note&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;Because the Entities within an Aggregate are an implementation detail, Entities within the Aggregate have Identity local to the Aggregate&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The Aggregate still needs to differentiate the objects it owns, properties, fields, or indexes are &lt;em&gt;implicitly&lt;/em&gt; the Identifiers of Entities assigned to them, &lt;em&gt;local&lt;/em&gt; to the Aggregate. Imagine the quintessential e-commerce Domain that has order and order line Domain Objects. In this domain, order lines have no meaning outside of an order. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void CreateDeveloperToolsOrder(IOrderRepository repository)
{
    var order = new Order();
    order.AddItem(&amp;quot;Visual Studio 2022&amp;quot;, 667.00m);
    order.AddItem(&amp;quot;ReSharper&amp;quot;, 1, 139.00m);
    order.AddItem(&amp;quot;NDepend&amp;quot;, 1, 492.00m);
    order.AddItem(&amp;quot;LINQPad&amp;quot;, 1, 65.00m);
    var firstItem = order.OrderLines.ElementAt(0);
    order.RemoveItem(0);
    var orderNumber = repository.Save(order);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--|Note|
|:-:|
|Entities owned by an Aggregate must appear like Value Objects within the interface of the Aggregate|--&gt;
&lt;p&gt;The resulting &lt;code&gt;Order&lt;/code&gt; instance comprises three &lt;code&gt;OrderLine&lt;/code&gt; Entities. &lt;code&gt;OrderLine&lt;/code&gt; Identity is the index of that instance in the &lt;code&gt;OrderLines&lt;/code&gt; collection—a local identity. Until the call to &lt;code&gt;RemoveItem&lt;/code&gt;, the Identity of the &lt;code&gt;Visual Studio Professional 2022&lt;/code&gt; order line was &lt;code&gt;0&lt;/code&gt;. Since &lt;code&gt;Visual Studio Professional 2022&lt;/code&gt; was removed before &lt;code&gt;Save&lt;/code&gt; was invoked, the local Identifier of &lt;code&gt;0&lt;/code&gt; was the only Identifier that was ever required of it. Since order item Identity is local to an order, &lt;code&gt;OrderItem&lt;/code&gt; implements no Identity:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public record OrderLine(string ProductName, float Quantity, decimal Price)
{
    public float Quantity { get; private set; } = Quantity;
    public decimal Price { get; private set; } = Price;
    public string ProductName { get; private set; } = ProductName;

    public void ChangePrice(decimal price)
    {
        Price = price;
    }
    public void ChangeQuantity(float quantity)
    {
        Quantity = quantity;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Note&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;Global Identifiers required only for persistence should be an implementation detail of the Repository, not the Entity.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="recognizing-identity-obsession"&gt;Recognizing Identity Obsession&lt;/h2&gt;
&lt;h3 id="domain-objects-described-with-an-id-characteristic-or-attribute"&gt;Domain Objects Described With an “ID” Characteristic or Attribute&lt;/h3&gt;
&lt;p&gt;I have found it rare that Domain Identity manifests as a concept named &amp;quot;ID.&amp;quot; For example, an &lt;em&gt;account&lt;/em&gt; typically has an Account Number Identifier, not an &amp;quot;ID&amp;quot; in banking. The Account Number &lt;em&gt;is&lt;/em&gt; an &amp;quot;ID&amp;quot;, but the Domain does not use that term (and should not be part of the Ubiquitous Language.) If you run across descriptions of Domain Objects that use the term &amp;quot;ID&amp;quot; or &amp;quot;Id&amp;quot; you can avoid or remedy Identity Obsession by asking the Domain experts questions to get clarity.&lt;/p&gt;
&lt;h3 id="entities-implemented-with-an-id-property"&gt;Entities implemented with an &lt;code&gt;Id&lt;/code&gt; property&lt;/h3&gt;
&lt;p&gt;Entity implementations may include an &lt;code&gt;Id&lt;/code&gt; property if descriptions of the underlying Domain Object include an &amp;quot;ID&amp;quot; characteristic or attribute. If the underlying Domain Object description does not include an &amp;quot;ID&amp;quot; attribute and the Entity implementation has an &lt;code&gt;Id&lt;/code&gt; property, you've probably discovered Identity Obsession. The Entity implementation should mirror the Domain Object's Identity terminology. If it's unclear, asking questions of the Domain experts will result in clarity.&lt;/p&gt;
&lt;h2 id="take-aways"&gt;Take Aways&lt;/h2&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Take Away&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;Isolate Identity and Identifiers from Entities&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Identity Obsession is the compulsion that every Domain Entity is described and implemented with a global Identifier. Global Identifiers are too frequently an implementation detail relating to a relational database. You can improve the implementation and gain deeper insight into the Domain by classifying Identities and treating them as independent Domain concepts. Identity as a separate domain concept enables you to isolate Identity and Identifiers from Entities so that an Entity is standalone and not complicated by the constraints of Identity.&lt;/p&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wiki.c2.com/?PrimitiveObsession"&gt;Primitive Obsession&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://amzn.to/3Y05vTq"&gt;Refactoring: Improving the Design of Existing Code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/mind-map.png" class="img-fluid" alt="Complicated translation"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/working-with-dto-auto-translators--mapster</id>
		<title>Working With DTO Auto Translators -- Mapster</title>
		<link href="http://blog.peterritchie.com/posts/working-with-dto-auto-translators--mapster" />
		<updated>2024-08-26T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/mapping-translation.png" class="img-fluid" alt="Complicated translation" /&gt;&lt;/p&gt;
&lt;!-- Mapping/Translation series intro boilerplate --&gt;
&lt;p&gt;Modern software applications heavily rely on external services, making data transfer a crucial aspect of application functionality. Invariably, data transfer involves translating an internal representation of information to data compatible with a particular communication channel. High-level programming languages empower programmers to model abstractions in high-level types independent of lower-level implementation details. This internal representation of data is sometimes called &lt;em&gt;abstract syntax&lt;/em&gt;, which is purposely devoid of the specifics (&lt;em&gt;concrete syntax&lt;/em&gt;) required by the channel and, or the receiver. Translation from one syntax to another must first map source data elements to target data elements. That mapping includes the necessary conversion method.&lt;/p&gt;
&lt;!-- Data Transfer Object boilerplate pull quote/box copy --&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Data Transfer Objects&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Defining concrete syntax in high-level languages is so essential that a design pattern is devoted to it. The Data Transfer Object&lt;sup&gt;[&lt;a href="https://amzn.to/3SR8c73"&gt;ppoe&lt;/a&gt;]&lt;/sup&gt; design pattern describes declaring high-level types to describe aspects of concrete syntax.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;This installment details the mapping and translation of Data Transfer Objects with a package named &lt;a href="https://github.com/MapsterMapper/Mapster"&gt;Mapster&lt;/a&gt; (&lt;a href="https://www.nuget.org/packages/Mapster.DependencyInjection"&gt;&lt;code&gt;Mapster.DependencyInjection&lt;/code&gt;&lt;/a&gt;).&lt;/p&gt;
&lt;h2 id="translation"&gt;Translation&lt;/h2&gt;
&lt;p&gt;Mapster makes translation available in several ways. Because this post details a solution with dependency injection, I'll be focusing on injecting an &lt;code&gt;IMapper&lt;/code&gt; (&lt;code&gt;MapsterMapper.IMapper&lt;/code&gt;) object where translation is required rather than the generated &lt;code&gt;TDestination Adapt&amp;lt;TSource, TDestination&amp;gt;(this TSource source)&lt;/code&gt; methods.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Opinion&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;I don't like thinking of this type of translation as an adaptation (i.e., as an Adapter Pattern implementation) because this isn't adapting one interface to another; it's raw data translation. As &amp;quot;&lt;code&gt;Adapt&lt;/code&gt;&amp;quot; alludes to mapping and translation being two different actions, I don't like the method that performs translation being named &amp;quot;&lt;code&gt;Map&lt;/code&gt;.&amp;quot; But &lt;a href="https://bit.ly/naming-things-repo"&gt;Naming is Hard&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Mapster generates classes with &lt;code&gt;Adapt&lt;/code&gt; methods at compile-time, so they're as fast as coding them by hand. The above method of invoking &lt;code&gt;Adapt&lt;/code&gt; doesn't generate code you can browse to in the IDE, but it's still pre-generated.&lt;/p&gt;
&lt;p&gt;Given a domain object of &lt;code&gt;Account&lt;/code&gt; and a Data Transfer Object &lt;code&gt;AccountDto&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Account(Guid id, DateOnly creationDate, string name)
{
	public Guid Id { get; } = id;
	public string Name { get; private set; } = name;
	public DateOnly CreationDate { get; } = creationDate;

	public void ChangeName(string name)
	{
		Name = name;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class AccountDto
{
	public Guid Id { get; set; }
	public string Name { get; set; }
	public DateOnly CreationDate { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mapster generates code to translate to/from &lt;code&gt;Account&lt;/code&gt;/&lt;code&gt;AccountDto&lt;/code&gt; so that you just need to inject an &lt;code&gt;IMapper&lt;/code&gt; and invoke the &lt;code&gt;IMapper.Map&amp;lt;TSource, TDestination&amp;gt;&lt;/code&gt; method. &lt;code&gt;AddMapster(this IServiceCollection serviceCollection)&lt;/code&gt; is used to add &lt;code&gt;IMapper&lt;/code&gt; to services.&lt;/p&gt;
&lt;h2 id="mapping-by-convention"&gt;Mapping by Convention&lt;/h2&gt;
&lt;p&gt;The raison d'etre of mapping/translation frameworks is to make translating one data type to another as simple as possible. A key feature of these frameworks is to map by convention, which automatically maps fields or properties based on criteria like name and data type. Mapster does an excellent job of mapping by convention. In the above example, you don't have to tell Mapster anything. It knows that &lt;code&gt;Account.Id&lt;/code&gt; maps to &lt;code&gt;AccountDto.Id&lt;/code&gt;, and &lt;code&gt;Account.Name&lt;/code&gt; maps to &lt;code&gt;AccountDto.Name&lt;/code&gt;, and &lt;code&gt;Account.CreationDate&lt;/code&gt; maps to &lt;code&gt;AccountDto.CreationDate&lt;/code&gt; because the properties have the same name and type.&lt;/p&gt;
&lt;p&gt;Explicit mapping isn't necessary. Simply injecting an &lt;code&gt;IMapper&lt;/code&gt; instance and invoking &lt;code&gt;IMapper.Map&amp;lt;TSource, TDestination&amp;gt;&lt;/code&gt; is enough to map th two type's properties by convention&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class CreateAccountCommandHandler(IMapper mapper, INotificationService notificationService)
	: IRequestHandler&amp;lt;CreateAccountCommand&amp;gt;
{
	private readonly IMapper mapper = mapper;

	public async Task Handle(CreateAccountCommand request, CancellationToken cancellationToken)
	{
		Guid accountId = Guid.NewGuid();
		Account account = CreateAccount(accountId);

		var dto = mapper.Map&amp;lt;Account, AccountDto&amp;gt;(account);

		await notificationService.PublishAsync(new AccountCreated(dto), cancellationToken);
	}
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="custom-mapping"&gt;Custom Mapping&lt;/h2&gt;
&lt;p&gt;When we start (greenfield) development, our DTOs are usually closely aligned with our domain objects, so by-convention mapping is our friend. However, an important reason for having two abstractions is that they can evolve independently. Eventually, as we gain a better understanding of the domain or clients of the communication channel, we will need to make changes that cause our DTO and Domain Objects to diverge. We can manage that divergence by extending the by-convention mapping to include custom mapping. Mapster supports this through what it calls registers or via &lt;code&gt;Register&lt;/code&gt; methods. Mapster can be told to scan for Register methods and perform custom mapping automatically.&lt;/p&gt;
&lt;p&gt;For example, we've gained a better understanding of the domain, and an Account doesn't necessarily have a &amp;quot;name&amp;quot; but has an associated account holder with a given and family name. That understanding may make its way into the domain like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Account(Guid id, DateOnly creationDate, string accountHolderGivenName, string accountHolderFamilyName)
{
	public Guid Id { get; } = id;
	public string AccountHolderGivenName { get; private set; } = accountHolderGivenName;
	public string AccountHolderFamilyName { get; private set; } = accountHolderFamilyName;
	public DateOnly CreationDate { get; } = creationDate;

	public void ChangeName(string accountHolderGivenName, string accountHolderFamilyName)
	{
		AccountHolderGivenName = accountHolderGivenName;
		AccountHolderFamilyName = accountHolderFamilyName;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Receivers of our &lt;code&gt;AccountDto&lt;/code&gt; might be unable to accommodate that change immediately, so we may deal with that by mapping properties differently. Instead of including FamilyName and GivenName in AccountDto, we may concatenate the given and family name and assign it to &lt;code&gt;AccountDto.Name&lt;/code&gt;. (A Strategy Pattern implementation that deals with whether a given name appears before a family name for a particular culture/customer is a topic for another time.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class MappingRegister : IRegister
{
	public void Register(TypeAdapterConfig config)
	{
		config.NewConfig&amp;lt;Account, AccountDto&amp;gt;()
			.Map(dest =&amp;gt; dest.Name, src=&amp;gt; $&amp;quot;{src.AccountHolderGivenName} {src.AccountHolderFamilyName}&amp;quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;During startup/service configuration, Mapster can be to told to scan for implementations of &lt;code&gt;IRegister&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;	TypeAdapterConfig.GlobalSettings.Scan(Assembly.GetExecutingAssembly());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="where-does-mapping-and-translation-occur"&gt;Where Does Mapping and Translation Occur?&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Data transfer can occur in different layers. Data transfer triggers a website or API (presentation layer); the application layer requests external services via an infrastructure layer to transfer data to and from. I'm often asked where that mapping and translation source code should exist and in which project in the solution. It's important to remember that we're dealing with multiple layers. While a presentation layer is the most common layer for initialization (DI container configuration), the translation method must be visible in the layer where the data transfer occurs.&lt;/p&gt;
&lt;p&gt;Translation of web/API models can exist in the presentation layer because that's where &lt;em&gt;that&lt;/em&gt; data transfer occurs. However, invoking a service from the application layer can mean the translation method can't live in the presentation layer because the application layer cannot take a direct dependency on the presentation layer (it is the other way around.)&lt;/p&gt;
&lt;p&gt;When a build boundary separates a layer (e.g., separate projects and or binaries), both assemblies can't be dependent on each other—the initialization/DI can't both access the types in the different assembly &lt;strong&gt;and&lt;/strong&gt; be referenced by the other assembly to invoke &lt;code&gt;Map&lt;/code&gt;/&lt;code&gt;Adapt&lt;/code&gt;. So, the mapping configuration that accesses the source and target types involved in the translation must exist in the assembly referenced by the initialization/DI. This is typically done by creating the familiar &lt;a href="https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#register-groups-of-services-with-extension-methods"&gt;&lt;code&gt;Add{GROUP_NAME}&lt;/code&gt; extension method pattern&lt;/a&gt; for example, given an application layer implemented in a separate project, an extension method (sometimes in the &lt;code&gt;Microsoft.Extensions.Hosting&lt;/code&gt; namespace, &lt;a href="https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-usage#:%7E:text=don%27t%20place%20extension%20methods%20in%20the%20microsoft.extensions.dependencyinjection%20namespace%20unless%20you%27re%20authoring%20an%20official%20microsoft%20package."&gt;but not recommended&lt;/a&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class ApplicationExtensions
{
	public static IServiceCollection AddApplicationServices(this IServiceCollection services)
	{
		ArgumentNullException.ThrowIfNull(services);
		TypeAdapterConfig.GlobalSettings.Scan(typeof(ApplicationExtensions).Assembly);

		services.AddMapster();
		return services;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/MapsterMapper/Mapster/wiki/Custom-mapping"&gt;Mapster - Custom Mapping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/MapsterMapper/Mapster"&gt;Mapster repo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/Mapster.DependencyInjection"&gt;Mapster Nuget&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/mapping-translation.png" class="img-fluid" alt="Complicated translation"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/what-are-the-proposed-csharp-type-unions-and-how-do-they-relate-to-discriminated-unions</id>
		<title>What Are the Proposed C# Type Unions and How Do They Relate to Discriminated Unions?</title>
		<link href="http://blog.peterritchie.com/posts/what-are-the-proposed-csharp-type-unions-and-how-do-they-relate-to-discriminated-unions" />
		<updated>2024-08-13T00:00:00Z</updated>
		<content>&lt;!--what-are-the-proposed-csharp-type-unions-and-how-do-they-relate-to-discriminated-unions--&gt;
&lt;p&gt;&lt;img src="../assets/views-through-different-lenses.jpg" class="img-fluid" alt="views through different lenses" /&gt;&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/dotnet/csharplang/blob/18a527bcc1f0bdaf542d8b9a189c50068615b439/proposals/TypeUnions.md"&gt;rumor&lt;/a&gt; is that a &lt;em&gt;type union&lt;/em&gt; feature may make its way into the next version of C#. The next version of C# will be 13, and C# has been around since 2000. What do type unions mean to C#?&lt;/p&gt;
&lt;p&gt;The concepts behind type unions have probably been around as long as programming languages. Some languages refer to them with different terms. Ada, Pascal, and Modula-2 refer to them as &lt;em&gt;variant records&lt;/em&gt; (like &lt;em&gt;variants&lt;/em&gt; in COM), Algo refers to them as &lt;em&gt;united modes&lt;/em&gt;, F#, and CORBA refer to them as discriminated unions and other languages refer to them as tagged unions (like Python and TypeScript). Some languages have a discriminator (tag) support in their enumerations feature (like Swift, Rust, and Haxe). You might also see discriminated union-&lt;em&gt;like&lt;/em&gt; support in other technologies like Swagger and OpenAPI.&lt;/p&gt;
&lt;p&gt;If you're familiar with C/C++, you may be familiar with unions; they're similar--their data types that define the type (or a block of memory) can be one of multiple types. C/C++ unions don't have a tag or discriminator or track what the union's storage &lt;em&gt;means&lt;/em&gt;). So, the code that uses the union has to figure out how to access data in the union correctly. I.e., the code that uses a union C/C++ must have its own discriminator/tag.&lt;/p&gt;
&lt;p&gt;C# never truly had the concept of a C/C++ union because of increased memory safety—accessing memory in many different ways wasn't considered &lt;em&gt;safe&lt;/em&gt;. You can fake C/C++ style unions in C# with &lt;code&gt;StructLayoutAttribute&lt;/code&gt; and &lt;code&gt;LayoutKind.Explicit&lt;/code&gt;. But I, for one, wouldn't recommend implementing discriminated unions that way.&lt;/p&gt;
&lt;p&gt;There have been some quasi-discriminated union implementations out there like &lt;code&gt;Result&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;. I call these &lt;em&gt;quasi&lt;/em&gt; because they're very special-case. Most &lt;code&gt;Result&amp;lt;T&amp;gt;&lt;/code&gt; implementations are discriminated unions because of the &lt;code&gt;Status&lt;/code&gt; or &lt;code&gt;IsSuccess&lt;/code&gt; properties that allow a consumer of an instance to tell whether to access the success or the error information. &lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt; is like &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt; with a discriminator &lt;code&gt;HasValue&lt;/code&gt;, but more semantically aligned with an &lt;em&gt;optional value&lt;/em&gt; (that could also be nullable).&lt;/p&gt;
&lt;h2 id="will-c-get-discriminated-unions-or-type-unions"&gt;Will C# Get &lt;em&gt;Discriminated Unions&lt;/em&gt; or &lt;em&gt;Type Unions&lt;/em&gt;?&lt;/h2&gt;
&lt;p&gt;The proposal for C# uses &amp;quot;Type Union&amp;quot; because the discriminator isn't explicit. The union object (or, more accurately, the C# compiler) knows the instance type and allows the use of existing C# type-matching features (like &lt;code&gt;is&lt;/code&gt;). The proposed syntax for declaring a Type Union is similar to declaring a single-level inheritance hierarchy that cannot be inherited from and behaves as if it is &lt;em&gt;closed&lt;/em&gt;. In fact, BCL support for the concept will use a &lt;code&gt;ClosedAttribute&lt;/code&gt; to declare Type Unions in a Common Type System way.&lt;/p&gt;
&lt;p&gt;Without a Type Union feature, something with a discriminator (specifically something like &lt;a href="https://blog.nimblepros.com/blogs/getting-started-with-ardalis-result/"&gt;&lt;code&gt;Result&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, is used like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// makes use of predefined union &amp;quot;Result&amp;lt;T&amp;gt;&amp;quot;
public Result&amp;lt;Resource&amp;gt; GetResource(Guid id)
{
   var resource = _context.Resources.SingleOrDefault(e =&amp;gt; e.Id == id);
   if(resource == null) return new Result&amp;lt;Resource&amp;gt;.NotFound;
   return new Result&amp;lt;Resource&amp;gt;(resource);
}

//... 

var result = GetResource(id);
if(result.Status == ResultStatus.Ok)
{
  result.Value.Description = newDescription;
  UpdateResource(result.Value);
}
else
{
  CreateResource(new Resource(id){Description = newDescription};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the proposed C# syntax, you'd declare a type union something like this, and for the point of comparison, I'll do one possible, simplified Type Union implementation of &lt;code&gt;Result&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public union struct Result&amp;lt;TValue&amp;gt;
{
  Success(TValue value);
  Failure(ErrorCode errorCode);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a &lt;em&gt;Type Union&lt;/em&gt;, this declares a union &lt;code&gt;Result&lt;/code&gt; and member types &lt;code&gt;Success&lt;/code&gt; and &lt;code&gt;Failure&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Creating an instance is similar to:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Result&amp;lt;Resource&amp;gt; result = Succes(resource);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Result&amp;lt;Resource&amp;gt; result = Failure(ErrorCode.NotFound);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instantiating one of the types and assigning it to an instance of the union—much like assigning a subclass to an instance of the base class.&lt;/p&gt;
&lt;p&gt;And use the instance like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;if(result is Failure f) { /*...*/ }
&lt;/code&gt;&lt;/pre&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;NOTE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;These examples were written without access to the feature in the language. Based solely on documentation, expect syntax errors when the feature is released.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;This example is covered in some common patterns in the proposal and only covers a part of what's possible with Type Unions (that part is &lt;em&gt;struct unions&lt;/em&gt;.) What's nice about this proposed feature is that it also considers union classes, ad hoc unions, and a limited ability to create custom unions (e.g., &lt;code&gt;ClosedAttribute&lt;/code&gt; and &lt;code&gt;UnionAttribute&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;What's also nice about this proposal is that it considers records, refs, boxing, nullability, co-/contra-variance (with ad hoc unions), exhaustiveness, nullability, equivalence, and assignability. The proposal might only do &lt;em&gt;most&lt;/em&gt; of what you'd expect, but it does what is correct and useful.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/views-through-different-lenses.jpg" class="img-fluid" alt="views through different lenses"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/aspiring-links-2024-07-14</id>
		<title>Aspiring Links for Period Ending July 14, 2024</title>
		<link href="http://blog.peterritchie.com/posts/aspiring-links-2024-07-14" />
		<updated>2024-07-14T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/aspiring-links.png" class="img-fluid" alt="A made from chain links" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://visualstudiomagazine.com/Articles/2024/06/28/net-aspire.aspx"&gt;Visual Studio Magazine - Microsoft Making Big .NET Aspire Push, So What Is It?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/live/YXCqkJLL3XE?si=MmW-KmBtkQnXvmXi"&gt;YouTube - Learn C# with CSharpFritz: Basics of .NET Aspire - Part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/hTtlBlsy1WA?si=nQYJggHvNg4gNkXx"&gt;YouTube - What is Dev Time Orchestration in .NET Aspire?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/fYqnWmhR-HU?si=vQogEpoNDNbmawhc"&gt;YouTube - Meet .NET Aspire&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/qtUgntF21Uw?si=WsVnZ2UPBWPw3dN-"&gt;YouTube - What are .NET Aspire components?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/lCzQ2yQr6JE?si=b3WEiW1ZX6lYjVY0"&gt;YouTube - How to deploy .NET Aspire applications?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/_DzGe2DXrKk?si=hdIRJaoUKiJrSS6h"&gt;YouTube - What is .NET Aspire telemetry?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/DzUhBG7uKUk?si=Sto7FpG7-dG51-8n"&gt;YouTube - What are .NET Aspire service defaults?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/qT6AXCLrZtw?si=ADHbcJLQ9HoR3XM1"&gt;YouTube - Technology and Friends - Scott Hunter on .NET Aspire&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/live/PUCU9ZOOgQ8?si=OgYaSvjqYPDpAJMr"&gt;YouTube - Let's Learn .NET Aspire (Português)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/live/48CWnYfTZhk?si=cgzeQ7kiEBmvS-s_"&gt;YouTube - Let's Learn .NET: Aspire (Tiếng Việt)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.postsharp.net/aspire-caching-metalama"&gt;Metalama - Simplify Your .NET Aspire Caching With Metalama&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://jeffreyfritz.com/2024/07/adding-antivirus-to-net-aspire-systems/"&gt;Fritz on the Web - Adding Antivirus to .NET Aspire Systems&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/aspiring-links.png" class="img-fluid" alt="A made from chain links"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/aspiring-links-2024-06-14</id>
		<title>Aspiring Links for Week Ending June 14, 2024</title>
		<link href="http://blog.peterritchie.com/posts/aspiring-links-2024-06-14" />
		<updated>2024-06-14T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/aspiring-links.png" class="img-fluid" alt="A made from chain links" /&gt;&lt;/p&gt;
&lt;p&gt;Using PostgreSQL with .NET and Entra ID (Blog)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/using-postgre-sql-with-dotnet-and-entra-id/"&gt;https://devblogs.microsoft.com/dotnet/using-postgre-sql-with-dotnet-and-entra-id/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Official .NET Aspire Learning Path at Microsoft Learn (Site)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/training/paths/dotnet-aspire/"&gt;https://learn.microsoft.com/en-us/training/paths/dotnet-aspire/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;My First look at .NET Aspire. What's with the Hype? by CodeOpinion (Video)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://youtu.be/maVXnkYEDIE?si=7AkKulcvVOgnxmVz"&gt;https://youtu.be/maVXnkYEDIE?si=7AkKulcvVOgnxmVz&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Instant OpenTelemetry Dashboard for JavaScript Developers with Aspire (Video)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://youtu.be/YKraN1ZETpw?si=XZUWcnZMtpzl7ztT"&gt;https://youtu.be/YKraN1ZETpw?si=XZUWcnZMtpzl7ztT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;.NET Aspire: Your Gateway to Cloud-Native Success (Blog)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://riasolutionsgroup.com/2024/06/11/using-dynatrace-to-navigate-the-microservices-maze/"&gt;https://riasolutionsgroup.com/2024/06/11/using-dynatrace-to-navigate-the-microservices-maze/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Aspirant - Extensions for .NET Aspire (GitHub Repo)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/aspirant-project/aspirant"&gt;https://github.com/aspirant-project/aspirant&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/aspiring-links.png" class="img-fluid" alt="A made from chain links"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/new-and-proposed-changes-in-csharp-13-2024-jun-5</id>
		<title>New And Proposed Changes For C# 13 - June 5, 2024</title>
		<link href="http://blog.peterritchie.com/posts/new-and-proposed-changes-in-csharp-13-2024-jun-5" />
		<updated>2024-06-05T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/types-of-extensions.png" class="img-fluid" alt="Extensions, extensions, extensions" /&gt;&lt;/p&gt;
&lt;p&gt;C# 13 is shaping up to introduce some interesting and useful additions to the C# language. Let's look at what we know as of June 5, 2024.&lt;/p&gt;
&lt;h2 id="extension-types"&gt;Extension Types&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Extension Types&lt;/em&gt; (announced at Build 2024) are the latest proposed addition to C# 13. Microsoft introduced &lt;em&gt;Extension Methods&lt;/em&gt; in C# 3, and since C# 4, the concept of &amp;quot;Extension Everything&amp;quot; has been an anticipated addition. &lt;em&gt;Extension Methods&lt;/em&gt; added the ability to extend non-static classes with statically-defined methods in unrelated static classes. &lt;em&gt;Extension Types&lt;/em&gt; extend the extensibility that Extension Methods offer, a huge leap towards Extension Everything.&lt;/p&gt;
&lt;p&gt;Extension Methods syntax stays the same, but you can be clearer about the intent of your extension methods by declaring implicit extension classes.&lt;/p&gt;
&lt;p&gt;An extension method in C#3-C#12 may look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class StringExtensions
{
    public static bool IsNotNullOrEmpty(this string text)
    {
        return !string.IsNullOrEmpty(text);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code introduces the ability to do something like &lt;code&gt;myText.IsNotNullOrEmpty()&lt;/code&gt;. In C# 13, you can be more direct (I'm trying to avoid using the word &amp;quot;explicit&amp;quot;; you'll see why in a sec.) by declaring an &lt;em&gt;implicit extension&lt;/em&gt; class with what looks like an instance method &lt;code&gt;IsNotNullOrEmpty&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;implicit extension StringExtensions for string
{
    public bool IsNotNullOrEmpty()
    {
        return !string.IsNullOrEmpty(this);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This alternative way to re-implement an extension method implements an instance method on the extension class—which is how the extension method appears when used: a call to a method on an instance of a type (&lt;code&gt;string&lt;/code&gt; in our example.) We're not limited to extending the &lt;em&gt;instance&lt;/em&gt; of a type; we can also extend the type with static methods. &lt;code&gt;IsNotNullOrEmpty&lt;/code&gt; is looking to be the opposite of the static &lt;code&gt;string&lt;/code&gt; method &lt;code&gt;IsNullOrEmpty&lt;/code&gt;. With Extension Types we will be able to implement &lt;code&gt;IsNotNullOrEmpty&lt;/code&gt; as a static method on &lt;code&gt;string&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;implicit extension StringExtensions for string
{
    public static bool IsNotNullOrEmpty(string text)
    {
        return !string.IsNullOrEmpty(text);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code adds a &lt;strong&gt;static extension method&lt;/strong&gt; that allows for &lt;code&gt;string.IsNotNullOrEmpty(myText)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But, since the code will truly be in the context—or scope of—&lt;code&gt;string&lt;/code&gt;, I don't need to qualify the call to &lt;code&gt;IsNullOrEmpty&lt;/code&gt; with the type &lt;code&gt;string&lt;/code&gt;! So, we could do this instead:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;implicit extension StringExtensions for string
{
    public static bool IsNotNullOrEmpty(string text)
    {
        return !IsNullOrEmpty(text);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since this is &amp;quot;Extensions Types,&amp;quot; we will also have &lt;em&gt;extension properties&lt;/em&gt;. Continuing with my theme of IsNotNullOrEmpty (potentially in a controversial way), we could implement my original extension method as an extension property:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;implicit extension StringExtensions for string
{
    public bool IsNotNullOrEmpty =&amp;gt; !IsNullOrEmpty(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code allows us to write &lt;code&gt;myText.IsNotNullOrEmpty&lt;/code&gt;. (Feel free to comment that I'm mad for making a property on a potentially &lt;code&gt;null&lt;/code&gt; instance of a &lt;code&gt;string&lt;/code&gt;, this is just an example.)&lt;/p&gt;
&lt;p&gt;Extension Types isn't limited to extension methods and properties but also includes extension indexers. Stealing from Dustin and Mads' demo, let's say we want to provide access to individual bits with a &lt;code&gt;UInt64&lt;/code&gt;; I could write an implicit extension type like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public implicit extension Bits for Uint64)
{
    public bool this[int index]
    {
        get =&amp;gt; (this &amp;amp; Mask(index)) != 0;
        set =&amp;gt; this = value ? this | Mask(value) : this &amp;amp; !Mash(index);
    }
    
    static ulong Mask(int index) =&amp;gt; `ul &amp;lt;&amp;lt; index;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;... so I could obtain the first bit of an unsigned 64-bit number with &lt;code&gt;unsigned64BitNumber[0]&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;What's with &lt;code&gt;implicit&lt;/code&gt;? Like implicit operators that will be resolved to based on inferred scope or that it &lt;em&gt;implicitly&lt;/em&gt; applies to all cases of the underlying type (&lt;code&gt;... for &amp;lt;type&amp;gt;&lt;/code&gt;.) The keyword &lt;code&gt;explicit&lt;/code&gt; means a caller can only use the member in an explicitly-qualified scope. So, if I made my &lt;code&gt;StringExtensions&lt;/code&gt; class &lt;code&gt;explicit&lt;/code&gt; instead, the use of &lt;code&gt;IsNullOrEmpty&lt;/code&gt; would only be callable by qualifying with &lt;code&gt;StringExtensions&lt;/code&gt;: &lt;code&gt;(StringExtensions)myText.IsNotNullOrEmpty&lt;/code&gt;. At least, that's what's currently proposed.&lt;/p&gt;
&lt;p&gt;Extension Types is a work in progress, so some of these things may change—I expect details around &lt;code&gt;explicit&lt;/code&gt; usage to change.&lt;/p&gt;
&lt;h2 id="new-field-contextual-keyword"&gt;New &lt;code&gt;field&lt;/code&gt; Contextual Keyword&lt;/h2&gt;
&lt;p&gt;A feature that almost made it into C# 12 is the &lt;code&gt;field&lt;/code&gt; contextual keyword--contextual in autoproperties. &lt;code&gt;field&lt;/code&gt; is an &amp;quot;alias&amp;quot; got access the auto-generated backing field.&lt;/p&gt;
&lt;p&gt;Since you could declare a variable within the context of an autoproperty, &lt;code&gt;field&lt;/code&gt; is technically a breaking change.&lt;/p&gt;
&lt;h2 id="params-collections"&gt;&lt;code&gt;params&lt;/code&gt; Collections&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;params&lt;/code&gt; has existed in C# since the start as a means of declaring a method that takes a variable number of arguments. Generic types were not available at the time, so &lt;code&gt;params&lt;/code&gt; only works with &lt;em&gt;arrays&lt;/em&gt;, for example, &lt;code&gt;void Method(params string[] args)&lt;/code&gt; or &lt;code&gt;void Method(params int[] numbers)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This means that &lt;code&gt;ReadOnlySpan&amp;lt;T&amp;gt;&lt;/code&gt; may be used with &lt;code&gt;params&lt;/code&gt; to realize the performance improvements of spans.&lt;/p&gt;
&lt;h2 id="system.threading.lock-type-and-lock"&gt;&lt;code&gt;System.Threading.Lock&lt;/code&gt; Type and &lt;code&gt;lock&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;.NET 9 introduces an improved lock type &lt;code&gt;System.Threading.Lock&lt;/code&gt;. &lt;code&gt;System.Threading.Lock&lt;/code&gt; offers improvements over &lt;code&gt;Monitor&lt;/code&gt; in that &lt;code&gt;Lock&lt;/code&gt; supports a narrower locking scope and avoids the overhead of SyncBlock.&lt;/p&gt;
&lt;p&gt;C# 13 &lt;code&gt;lock&lt;/code&gt; recognizes if the target is &lt;code&gt;System.Threading.Lock&lt;/code&gt; and uses its updated API.&lt;/p&gt;
&lt;h2 id="new-escape-sequence-for-esc-character"&gt;New Escape Sequence For &lt;kbd&gt;Esc&lt;/kbd&gt; Character&lt;/h2&gt;
&lt;p&gt;You can now enter &lt;kbd&gt;Esc&lt;/kbd&gt; as a string/character literal with &lt;code&gt;'\e'&lt;/code&gt;. Prior to C# 13, having the &lt;kbd&gt;Esc&lt;/kbd&gt; character in a string would require typing &lt;code&gt;\u001b&lt;/code&gt; (or &lt;code&gt;\x1b&lt;/code&gt;, but that's not recommended.) I believe this accepts the existing Regular Expression character sequence of &lt;code&gt;\e&lt;/code&gt; as an escape for &lt;kbd&gt;Esc&lt;/kbd&gt;.&lt;/p&gt;
&lt;h2 id="improved-overload-resolution-for-method-groups"&gt;Improved Overload Resolution For Method Groups&lt;/h2&gt;
&lt;p&gt;C# 13 will improve overload resolution of method groups when determining the method group's natural type. Oversimplication: instead of generating all possible candidate methods and selecting the best candidate, candidates will be constructed scope by scope. If, after pruning all the candidates at one scope, candidates at the next scope are constructed and considered. If you're interested at that level, see &lt;a href="https://github.com/dotnet/roslyn/issues/69222"&gt;Generic constraints should prune out candidates for method group natural type&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="index-operator-now-available-in-object-initializer-expressions"&gt;Index operator &lt;code&gt;^&lt;/code&gt; Now Available In Object Initializer Expressions&lt;/h2&gt;
&lt;p&gt;You can now use the &amp;quot;From the end&amp;quot; operator in object initializer expressions. e.g.:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var countdown = new TimerRemaining()
{
    buffer =
    {
        [^1] = 0,
        [^2] = 1,
        [^3] = 2,
        [^4] = 3,
        [^5] = 4,
        [^6] = 5,
        [^7] = 6,
        [^8] = 7,
        [^9] = 8,
        [^10] = 9
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="caveat"&gt;Caveat&lt;/h2&gt;
&lt;p&gt;&amp;quot;C# 13&amp;quot; is a work in progress, and the above was accurate when it was published. Hopefully we'll get everything detailed above but we may not. We may not get some of these features or we may get more!&lt;/p&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/roslyn/issues/11159"&gt;Language Feature: Extension Everything&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/csharplang/issues/5497"&gt;[Proposal]: Extensions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/csharplang/issues/140"&gt;Proposal: Semi-Auto-Properties; field keyword&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/params-collections"&gt;&lt;code&gt;params&lt;/code&gt; Collections Feature Proposal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/lock-object"&gt;Lock Object Feature Specification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/csharplang/issues/7400"&gt;[Proposal]: String/Character escape sequence \e as a short-hand for \u001b (&amp;lt;ESCAPE&amp;gt;)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/method-group-natural-type-improvements"&gt;Method group natural type improvements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/csharplang/issues/7429"&gt;[Proposal]: Method group natural type improvements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/csharplang/issues/7684"&gt;Open issue: evaluation of implicit indexers in object initializers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/types-of-extensions.png" class="img-fluid" alt="Extensions, extensions, extensions"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/dealing-with-primitive-obsession-with-entity-framework-core</id>
		<title>Dealing with Primitive Obsession with Entity Framework Core</title>
		<link href="http://blog.peterritchie.com/posts/dealing-with-primitive-obsession-with-entity-framework-core" />
		<updated>2024-05-22T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/obsessed-with-primitive-shapes.png" class="img-fluid" alt="obsessed only with creating with primitive shapes" /&gt;&lt;/p&gt;
&lt;p&gt;Unlike object-oriented languages, serialization and data transfer are limited to a small set of primitive types. These primitive types are often text, numbers (integers, floating point), booleans, arrays, etc. Sometimes, you're fortunate enough to have a more modern framework and have fancy types like date, time, and date/time, UUID/GUID, monetary, or binary data.&lt;/p&gt;
&lt;p&gt;Primitive types are &lt;em&gt;value types&lt;/em&gt;—they don't have identity semantics, and their equality/equivalence is based on their &lt;em&gt;value&lt;/em&gt;. Entity Framework Core supports &lt;em&gt;value types&lt;/em&gt; as attributes but only insomuch as what the underlying provider supports. Any complex types are &amp;quot;entities&amp;quot; in Entity Framework, despite not having an &amp;quot;identity&amp;quot;.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Note&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Every type that Entity Framework is configured to recognize is an &lt;em&gt;Entity&lt;/em&gt; (e.g., via &lt;code&gt;ModelBuilder.Entity&amp;lt;T&amp;gt;()&lt;/code&gt; or &lt;code&gt;IEntityTypeConfiguration&amp;lt;T&amp;gt;&lt;/code&gt;), despite an entity traditionally (English definition, philosophically, ontologically, or even entity-relationship diagrams) being an individual/instance with an independent (of its attributes) existence.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Domains invariably have many value types. Some may be complex (multiple attributes), and some may be simple (subsets of primitive types.) Even &lt;em&gt;simple&lt;/em&gt; domain value types have unique semantics—that constrain value validity. A common value type &lt;em&gt;Name&lt;/em&gt;, for example, is textual and thus can be implemented with a textual primitive type (like &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;VARCHAR&lt;/code&gt;.) A textual primitive type like &lt;code&gt;string&lt;/code&gt; is a sequence of characters up to 2,146,483,647 characters of any value. This is unrealistic for a &amp;quot;name&amp;quot; in most domains: e.g., a name over 2 billion characters in length or containing characters like &lt;code&gt;%'&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;&lt;/code&gt; is problematic. Unlike how an integer is not a valid text value, and there exists no way to assign an integer to a string (e.g., &lt;code&gt;string text = 1;&lt;/code&gt; is not valid and cannot be compiled and thus never be executed), re-using a primitive type for &lt;em&gt;domain types&lt;/em&gt; with validity (consistency) constraints means instances of these domain values may not be valid (e.g., &lt;code&gt;name = &amp;quot;%&amp;quot;&lt;/code&gt; or &lt;code&gt;name = new string('&amp;lt;', int.MaxValue);&lt;/code&gt;) until being checked. Enter &lt;strong&gt;Primitive Obsession&lt;/strong&gt;.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Hint&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Entity Framework &amp;quot;entities&amp;quot; are not the same as Domain-Driven Design &amp;quot;entities.&amp;quot; Despite being based on relational entities, Entity Framework considers groups of nested (owned) attributes to be entities even if they don't map to their own table (with key.)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="primitive-obsession"&gt;Primitive Obsession&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Primitive Obsession&lt;/em&gt; is a type of code smell&lt;span title="Fowler, M. (2018). &amp;quot;Refactoring: Improving the Design of Existing Code&amp;quot; "&gt;&lt;sup&gt;&lt;a href="https://amzn.to/3KkcnDT"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/span&gt; where—in an object-oriented context—something that realistically  has unique behavior and semantics has been implemented with a primitive type that doesn't guard that concept's invariants. Primitive Obsession recommends that invariants be abstracted within a unique type so that invalid or inconsistent instances of that type cannot exist.&lt;/p&gt;
&lt;h3 id="value-object-mapping-in-entity-framework"&gt;Value Object Mapping in Entity Framework&lt;/h3&gt;
&lt;p&gt;Fortunately, Entity Framework Core supports mapping from domain-specific value types to database primitive types. The domain-specific types then maintain their consistency, and correct usage is enforced.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Note&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;The converse is also important; not all uses of primitive types need to be abstracted away within a custom domain type. For example, a domain type may have attributes that realistically won't have values outside a specific range, but a type does not need to be created to abstract a primitive type. For example, making a &lt;code&gt;Length&lt;/code&gt; value type that wraps an integer value that provides no added value increases complexity rather than reduces it.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;I've encountered some complex domains that treat identity very specifically. In cases like this, custom value types like &lt;em&gt;Identifier&lt;/em&gt; that may use one of many primitive types are created to abstract the underlying primitive type. For example, a high-level view of an Identifier class (that doesn't include details like validation, parsing, etc.):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public record Identifier&amp;lt;T&amp;gt; where T : struct, IEquatable&amp;lt;T&amp;gt;
{
    private readonly T _value;
    public Identifier(T value) =&amp;gt; _value = value;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Implemented as a &lt;code&gt;record&lt;/code&gt;, &lt;code&gt;Identifer&amp;lt;T&amp;gt;&lt;/code&gt; operates as a value type (&lt;code&gt;struct&lt;/code&gt;, at the runtime level to implement a domain-level &lt;em&gt;value type&lt;/em&gt;) and provides equality and isolation (&lt;code&gt;Identifier&amp;lt;int&amp;gt;&lt;/code&gt; is not the same as &lt;code&gt;Identifier&amp;lt;Guid&amp;gt;&lt;/code&gt;. They cannot be equal, or compared.)&lt;/p&gt;
&lt;p&gt;Inferring the mapping of instances of this type to primitive database column types isn't possible (and EF will let you know with an &lt;code&gt;InvalidOperationException&lt;/code&gt; detailing &lt;em&gt;The 'Identifier' property 'ShippingCompany.Identifier' could not be mapped because the database provider does not support this type.&lt;/em&gt; We need to tell Entity Framework Core how to map to a type the database provider supports. This is done with the &lt;code&gt;PropertyBuilder&amp;lt;TProperty&amp;gt;.HasConversion&lt;/code&gt; method when configuring the containing entity type.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder
        .Entity&amp;lt;ShippingCompany&amp;gt;()
        .Property(e =&amp;gt; e.Identifer)
        .HasConversion(identifier =&amp;gt; identifer.Value, value =&amp;gt; new Identifier&amp;lt;Guid&amp;gt;(value));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above shows how you can address Primitive Obsession when using Entity Framework but, it assumes that you're directly persisting domain objects through Entity Framework. Focusing on behavior over attributes in a domain may not make all domain objects persistable by Entity Framework. Still, you can at least push off the mapping of non-primitive value types to Entity Framework if you don't want to introduce another layer of mapping (treating the types persisted via Entity Framework as persistence DTOs).  You could still have a non-primitive-DTO (e.g., &lt;code&gt;IdentifierDto&lt;/code&gt;) persisted through Entity Framework.  I'll leave it up to you to decide if that's &amp;quot;proper&amp;quot; for your domain.&lt;/p&gt;
&lt;h3 id="references"&gt;References&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;[1]: &lt;a href="https://amzn.to/3KkcnDT"&gt;Refactoring: Improving the Design of Existing Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.c2.com/?ReplaceDataValueWithObject"&gt;Replace Data Value With Object Refactoring&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/obsessed-with-primitive-shapes.png" class="img-fluid" alt="obsessed only with creating with primitive shapes"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/contributing-to-many-git-repos</id>
		<title>A tool to help contributing to many Git repos</title>
		<link href="http://blog.peterritchie.com/posts/contributing-to-many-git-repos" />
		<updated>2023-11-30T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/contributing-to-many-git-repos.jpg" class="img-fluid" alt="Source code from many sources" /&gt;&lt;/p&gt;
&lt;p&gt;I've contributed to many Git repos over the years. Doing this means I work in a code base for a little while, switch to another, and often eventually switch back.&lt;/p&gt;
&lt;h2 id="collaborating-with-others"&gt;Collaborating with Others&lt;/h2&gt;
&lt;p&gt;In the repos that I work in, many have multiple contributors. The contributions to those repos can be prolific, and if the repo is using a workflow that uses feature or topic branches, branches come and go quite often. &lt;code&gt;git fetch&lt;/code&gt; by default (or with no other options) gets all branches so you'll have other team members' branches after a fetch--which can be used to do a deep dive on a PR.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;You could choose not to use the &lt;code&gt;git fetch&lt;/code&gt; defaults and have it only get a particular branch. This can typically be done with &lt;code&gt;git fetch origin main&lt;/code&gt; (depending on how you've named your remotes and your branches.)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;p&gt;I work with many organizations and rarely is there one repo (yes, I know, there's this thing called a &amp;quot;monorepo&amp;quot;; but I find that organizations that can make this work need to be very technically savy, with products/technologies geared towards developers, and only a few of the organizations I work with are at that level.) With remote work being what it is (I'm often working at a different time than other contributors), when I return to work with an organization's code, I usually need to update several repos.&lt;/p&gt;
&lt;p&gt;|Why not do a &lt;code&gt;git pull&lt;/code&gt; instead of &lt;code&gt;git fetch&lt;/code&gt;?|
|:-:|
What I'm contributing to, what I may be reviewing, and whether I'm connected, are variable enough that I've built a habit only to pull when I'm ready to merge and deal with potential conflicts. If I have conflicts, I must resolve them (or abort: &lt;code&gt;git merge --abort&lt;/code&gt; or &lt;code&gt;git fetch origin&lt;/code&gt; and &lt;code&gt;git reset --hard origin&lt;/code&gt;) before doing anything else. This means I must commit to resolving those conflicts before switching to another branch to review or work with it. (Yes, I could re-clone in a different place, but frequent-fetch&amp;gt;abort&amp;gt;clone in terms of effort and risk.)}&lt;/p&gt;
&lt;h1 id="a-tool-to-help"&gt;A tool to help&lt;/h1&gt;
&lt;p&gt;When I re-start work (or maybe I'm coming off a vacation), going to each repo dir to perform &lt;code&gt;git fetch&lt;/code&gt; is tedious. I've developed a Powershell script to do that. I'll walk through the script after the code (commented code available &lt;a href="https://github.com/peteraritchie/pri.powershell/blob/main/git/fetch-all.ps1"&gt;here&lt;/a&gt;.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;using namespace System.IO;
param (
    [switch]$WhatIf,
    [switch]$Verbose,
    [switch]$Quiet
    )
$currentDir = (get-location).Path;

if($Verbose.IsPresent) {
    $VerbosePreference = &amp;quot;Continue&amp;quot;;
}

function Build-Command {
    $expression = 'git fetch';
    if($Quiet.IsPresent) {
        $expression += ' -q';
    }
    if($Verbose.IsPresent) {
        $expression += ' -v --progress';
    }
    if($WhatIf.IsPresent) {
        $expression += ' --dry-run';
    }
    $expression += &amp;quot; origin&amp;quot;;
    return $expression;
}

foreach($item in $([Directory]::GetDirectories($currentDir, '.git', [SearchOption]::AllDirectories);)) {
    $dir = get-item -Force $item;
    Push-Location $dir.Parent;
    try {
        Write-Verbose &amp;quot;fetching in $((Get-Location).Path)...&amp;quot;;
        $expression = Build-Command;

        Invoke-expression $expression;

    } finally {
        Pop-Location;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, I'm translating the PowerShell idioms &lt;code&gt;WhatIf&lt;/code&gt;, &lt;code&gt;Verbose&lt;/code&gt;, and &lt;code&gt;Quiet&lt;/code&gt; to common Git options &lt;code&gt;--dry-run&lt;/code&gt;, &lt;code&gt;--verbose&lt;/code&gt; (&lt;code&gt;-v&lt;/code&gt;), and &lt;code&gt;--quiet&lt;/code&gt; (&lt;code&gt;-q&lt;/code&gt;). The &lt;code&gt;Build-Command&lt;/code&gt; builds up the expression we want to use to invoke git. I've included the &lt;code&gt;--progress&lt;/code&gt; option with &lt;code&gt;git fetch&lt;/code&gt; to display progress when&lt;code&gt;-Verbose&lt;/code&gt; is specified. Next, I'm looping through all directories, looking for a &lt;code&gt;.git&lt;/code&gt; directory. I'm using &lt;code&gt;System.IO.GetDirectories&lt;/code&gt; instead of &lt;code&gt;Get-ChildItem&lt;/code&gt; because it's much faster. For each directory that contains a &lt;code&gt;.git&lt;/code&gt; subdirectory, Git &lt;code&gt;fetch&lt;/code&gt; is invoked. This allows me to fetch several Git repos within the hierarchy of the current directory.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: center;"&gt;Organizaing Code Locally&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: center;"&gt;I work with my code (spikes, libraries, experiments, etc.), open-source projects, and multiple clients. All these diverge from one another at one level in my directory structure. e.g. I may have a &lt;code&gt;src&lt;/code&gt; subdiretory in my home directory; and &lt;code&gt;oss&lt;/code&gt;, &lt;code&gt;experiments&lt;/code&gt;, and &lt;code&gt;client&lt;/code&gt; subdirectories within &lt;code&gt;src&lt;/code&gt;, so I can choose to fetch from all the repos recursively in each of those subdirectories--if I'm returning to work on an OSS project after being away from OSS for a while, I just &lt;code&gt;fetch-all.ps&lt;/code&gt; within the &lt;code&gt;oss&lt;/code&gt; subdirectory.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;By default (or with no other options), &lt;code&gt;git fetch&lt;/code&gt; does not delete corresponding local branches that have been removed from a remote. So, new branches will be downloaded, but those that were removed will remain.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;To also remove local branches removed from the remote, you can include a purge option with &lt;code&gt;git fetch&lt;/code&gt;: &lt;code&gt;git fetch --prune&lt;/code&gt; or &lt;code&gt;git fetch -p&lt;/code&gt;.&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;p&gt;If I'm reviewing a PR, I don't necessarily want removed remote branches to be removed locally &lt;em&gt;all the time&lt;/em&gt;. So, I like pruning separately from fetching. The following is the script for that (other than Build-Command, it has the same structure and flow as &lt;code&gt;fetch-all.ps1&lt;/code&gt; (so I won't walk through this snippet.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-PowerShell"&gt;using namespace System.IO;
param (
    [switch]$WhatIf,
    [switch]$Verbose
    )
$currentDir = (get-location).Path;

if($Verbose.IsPresent) {
    $VerbosePreference = &amp;quot;Continue&amp;quot;;
}

function Build-Command {
    $expression = 'git remote';
    if($Verbose.IsPresent) {
        $expression += ' -v';
    }
    $expression += ' prune';
    if($WhatIf.IsPresent) {
        $expression += ' --dry-run';
    }
    $expression += ' origin';
    return $expression;
}

foreach($item in $([Directory]::GetDirectories($currentDir, '.git', [SearchOption]::AllDirectories);)) {
    $dir = get-item -Force $item;
    Push-Location $dir.Parent;
    try {
        Write-Verbose &amp;quot;pruning in $((Get-Location).Path)...&amp;quot;;
        $expression = Build-Command;

        Invoke-expression $expression;
    } finally {
        Pop-Location;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Separating pruning from fetching also allows me to prune at a wider scope than fetching. e.g. &lt;code&gt;c:\Users\peter\src\client .\fetch-all.ps1&lt;/code&gt; and &lt;code&gt;c:\Users\peter\src .prune-all.ps1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I look forward to your feedback and comments.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/contributing-to-many-git-repos.jpg" class="img-fluid" alt="Source code from many sources"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/entity-framework-in-aspire</id>
		<title>Entity Framework in .NET Aspire</title>
		<link href="http://blog.peterritchie.com/posts/entity-framework-in-aspire" />
		<updated>2023-11-29T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/entity-framework-in-aspire.jpg" class="img-fluid" alt="A path through the infrastructure" /&gt;&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;.NET Aspire is an opinionated, cloud ready stack for building observable, production ready, distributed applications.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://learn.microsoft.com/en-us/dotnet/aspire/get-started/aspire-overview"&gt;.NET Aspire&lt;/a&gt; is currently in preview and focuses on &lt;em&gt;simplifying the developer experience&lt;/em&gt; with &lt;em&gt;orchestration&lt;/em&gt; and &lt;em&gt;automatic service discovery&lt;/em&gt; features. There's a huge potential for .NET Aspire beyond this initial valuable feature set.&lt;/p&gt;
&lt;p&gt;Being in preview, .NET Aspire may not yet support all the scenarios or workloads you may be comfortable with. It's an opinionated framework, which means differences of opinion are natural and expected. Currently, one of those opinions seems to be a focus on containers. The sample solutions that the new &lt;code&gt;dotnet&lt;/code&gt; templates provide are a great example of the benefits of containerization. The .NET Aspire starter solution that &lt;code&gt;dotnet new --use-redis-cache --output AspireStarter&lt;/code&gt; generates, out of the box, is something that, when debugged, will download, run, and utilize a Docker Redis image. (I've worked with teams where getting each member productive in a development environment has ended up being days of work.) The AppHost component of a .NET Aspire solution codifies abstract aspects of the architectural decisions that automates the generation and deployment of a development environment&amp;lt;(!--and configuration provides the details from future decisions about other environments--&amp;gt;.)&lt;/p&gt;
&lt;p&gt;A container focus is empowered by .NET Aspire's &lt;em&gt;orchestration&lt;/em&gt; features. An independent orchestration responsibility enables better separation of &lt;em&gt;release and deploy&lt;/em&gt; concerns from &lt;em&gt;build and test&lt;/em&gt; concerns; &lt;em&gt;shifting right&lt;/em&gt; those decisions that release and deploy depend on. (i.e., the ability to develop, execute, and evaluate solutions are discernibly &lt;em&gt;left&lt;/em&gt; of release and operation.) Containers are an established method of componentizing a distributed system with independent servers (sometimes called &amp;quot;tiers.&amp;quot;) This provides flexibility to deploy and execute in a development environment even before architectural decisions about a production topology have been considered. For example, debugging the .NET Aspire starter app automatically spins up a Redis container in Docker, but it's extremely unlikely that's how it will be deployed in production. In production, will there be one only Redis instance? If you have many instances, what sort of gateway or reverse proxy to that pool of instances will be utilized? Will it be on-prem or cloud? Will it be Azure, AWS, or Google Cloud? The beauty of Aspire's orchestration feature is that it doesn't matter yet; you can configure orchestration to &lt;em&gt;figure it out at run-time&lt;/em&gt;, one environment at a time!&lt;/p&gt;
&lt;p&gt;But, with every decision comes compromise. Technologies that depend on the physical resources that come from those decisions (that we're now effectively deferring) introduce some challenges with some existing software development idioms. A chicken-and-egg situation: if how to connect to physical resources may only be known at run-time, what happens to design-time technologies that depend on that connection information?&lt;/p&gt;
&lt;p&gt;One popular technology in .NET, Entity Framework, suffers one of those challenges in .NET Aspire (Possibly only in &lt;em&gt;code-first&lt;/em&gt; scenarios. Many Entity Framework examples detail adding Entity Framework support to an existing component (resource, like console app, ASP.NET Core web API, Razor app, etc.), creating a circular dependency between its project and the existence of an executing database (i.e., a valid database connection string.) In database-first, you have an existing application with existing physical databases and practices to utilize them in a development environment. With .NET Aspire, developers are &lt;em&gt;shifted left&lt;/em&gt; from the decisions that provide the resources that things like &lt;code&gt;migrations add &amp;lt;migration-name&amp;gt;&lt;/code&gt; and &lt;code&gt;dotnet ef database update&lt;/code&gt; require to function properly.&lt;/p&gt;
&lt;p&gt;To be clear, the way .NET Aspire works is that the orchestration (AppHost) executes, figures out the various connection strings, and overrides the &lt;code&gt;appsettings&lt;/code&gt; by setting environment variables before running the other components. The premise behind this means that at run-time, whatever is in &lt;code&gt;appsettings&lt;/code&gt; is ignored. &lt;code&gt;dotnet ef&lt;/code&gt; command doesn't execute at run-time; it effectively runs at design-time and gets its configuration from &lt;code&gt;appsettings&lt;/code&gt;, so it's out of sync with reality.&lt;/p&gt;
&lt;p&gt;The basic guidance is to &lt;em&gt;abstract those types of dependencies as .NET Aspire resources&lt;/em&gt;. Nothing new conceptually, but this might be an application of the principles of abstraction at a level less commonly applied. Refining that guidance to using Entity Framework: &lt;em&gt;the database should be an independent resource&lt;/em&gt;. Independent resources are modeled in .NET as either separate projects or separate solutions. Luckily, an &lt;a href="https://github.com/dotnet/aspire-samples/tree/main/samples/eShopLite"&gt;.NET Aspire sample&lt;/a&gt; addresses this. Let's look into the details.&lt;/p&gt;
&lt;p&gt;The structure of the eShopLite sample overlaps with the .NET Aspire starter &lt;code&gt;dotnet new&lt;/code&gt; template. It has a Blazor web frontend, a web API, an Aspire AppHost, and an Aspire service defaults project. Additionally, there is a shopping cart service (BasketService), and the catalog database (CatalogDb) project is an abstraction of the database resource.&lt;/p&gt;
&lt;p&gt;The CatalogDb looks very similar to what you'd end up with following &lt;a href="https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-8.0&amp;amp;tabs=visual-studio"&gt;Tutorial: Create a web API with ASP.NET Core&lt;/a&gt;: an ASP.NET Core web API that leverages Entity Framework, and is effectively a gateway to a backend database. Although, that tutorial uses Entity Framework &lt;em&gt;in-memory&lt;/em&gt; rather than via PostgreSQL. The way eShopLite supports Entity Framework is through the CatalogDb project. CatalogDb is like a stub project to the rest of the solution: Aspire doesn't execute it, but CatalogService depends upon it for the database model classes and &lt;code&gt;DbContext&lt;/code&gt; (utilized more like a class library.)  Nothing connects to the CatalogDb &lt;em&gt;web API&lt;/em&gt;. The CatalogDb project contains all the Entity Framework design-time details and references, allowing you to utilize Entity Framework's features like &lt;code&gt;migrations add &amp;lt;migration-name&amp;gt;&lt;/code&gt; and &lt;code&gt;dotnet ef database update&lt;/code&gt;. The target of Entity Framework operations like migration add and database update would depend on the configuration in &lt;code&gt;appsettings.json&lt;/code&gt;. Initialization/seeding of the data is handled in &lt;code&gt;CatalogDbInitializer&lt;/code&gt; within CatalogDb, as well as migrations at run-time (startup). CatalogDb &lt;code&gt;appsettings&lt;/code&gt; connection strings must be in sync with the run-time values for &lt;code&gt;ef&lt;/code&gt; commands to work.&lt;/p&gt;
&lt;p&gt;In summary, if you want to utilize Entity Framework in a basic .NET Aspire application, &lt;a href="https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-8.0&amp;amp;tabs=visual-studio"&gt;adding a project&lt;/a&gt; to contain the entity models, context, and Entity Framework references and supporting a database engine container is a recommended place to get started. I suspect this guidance may be refined as .NET Aspire evolves.&lt;/p&gt;
&lt;p&gt;I'm still wrapping my head around how .NET Aspire can support other non-containerized workloads like Azure SQL. Still, a containerized design melds nicely with the idea of independent resources (or nodes) in .NET Aspire.  .NET Aspire also helps to more clearly delineate concerns like design, build, test, release, and deploy. As with .NET Aspire, containerization is an easier starting point for someone interested in distributed applications.&lt;/p&gt;
&lt;p&gt;I look forward to how .NET Aspire evolves.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/entity-framework-in-aspire.jpg" class="img-fluid" alt="A path through the infrastructure"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/etags-in-aspdotnet-core</id>
		<title>ETags in ASP.NET Core</title>
		<link href="http://blog.peterritchie.com/posts/etags-in-aspdotnet-core" />
		<updated>2023-06-28T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/farside-etags-in-asp-dot-net.jpg" class="img-fluid" alt="lots of things going on at the same time, in the style of Farside" /&gt;&lt;/p&gt;
&lt;p&gt;A good software architect doesn't just provide expectations of structure; they also work with developers to give feedback and guidance for implementation. It's easy to say, &amp;quot;Use ETags for entity concurrency control in a Web API,&amp;quot; it's another to empower teams to accomplish the objectives of entity versioning.&lt;/p&gt;
&lt;p&gt;To review: entity-tags (Etags) are a method of implementing Optimistic Concurrency Control. Optimistic Concurrency Control is a means to avoid distributed locking in situations when two or more potentially concurrent operations rarely interfere with each other. You can see cases like this on the Web when multiple processes or people are not normally working on the same data simultaneously. With the Web, there are rare situations where a single process or single person can (usually inadvertently) modify data from two places at the same time. It's rare case like this where the low overhead of optimistic concurrency can avoid accidental overwrites.&lt;/p&gt;
&lt;p&gt;Entity-tags are a moniker of a particular incarnation of an entity. The tag is opaque, so it shouldn't need to be interpretable by a requestor to your service. With opaque data, you want to make the value itself as unobvious as possible.&lt;/p&gt;
&lt;p&gt;The value, of course, could be an incrementing integer if you could reliably and efficiently increment an integer in a distributed environment (remember, we're addressing the possibility of two distributed transactions interfering with one another, the same transactions mechanisms that would be used to increment an integer.)  But, before choosing to increment an integer (an ordinal number), consider &lt;a href="https://www.rfc-editor.org/rfc/rfc9110#field.etag"&gt;RFC 9110 ETags&lt;/a&gt; and why ordinal version numbers are not specified.&lt;/p&gt;
&lt;p&gt;| If you think an ordinal number will work, do you need entity-tags at all?&lt;/p&gt;
&lt;p&gt;A time-stamp is something to consider, in which case, prefer the &lt;code&gt;Last-Modified&lt;/code&gt; header field validator. Or in conjunction with entity-tags. If a time-stamp is reliable, &lt;code&gt;Last-Modified&lt;/code&gt; offers better interoperability options than re-inventing the wheel. Also, be thoughtful when considering time-stamps, especially their granularity; per-second time-stamp granularity can only partially solve the problem of concurrent writes.&lt;/p&gt;
&lt;p&gt;So, how do you reliably generate an entity-tag value? The first thing to consider is what you want to accomplish. Do you want to prevent accidental overwrites, or do you want entity versioning? If you said, &amp;quot;I want entity versioning,&amp;quot; to what end? If a client gets version 1, and another client updates it to version 2, what action do you want to perform when the first client requests to update the entity? You don't need &lt;em&gt;versioning&lt;/em&gt; to prevent that first client from updating the entity. If you want to merge with version 2, you probably want versioning; in this case, you can stop reading now; I won't get into detail like that in this post.&lt;/p&gt;
&lt;p&gt;If we're interested in preventing accidental overwrites, on the server side, we only really care about the current entity and the basis for the current request to update it. It doesn't matter if the basis is the previous version or ten versions behind; we only care that it's not based on the current version.&lt;/p&gt;
&lt;p&gt;Another thing to consider is that entity-tags are also used in HTTP caching, which requires that an entity-tag be unique per encoding (e.g., a gzipped response should have a different entity-tag than a non-gzipped response.) The encoding value is often postfixed to the entity-tag to make it unique per encoding. But be careful to parse that out when checking for semantically identical entities. That's out of the scope of this post.&lt;/p&gt;
&lt;p&gt;With an understanding of those constraints, a common method of generating an entity-tag is to use a hash of the entity representation.&lt;/p&gt;
&lt;p&gt;Let's look at an example controller that tries to isolate the implementation detail of how the entity-tag is calculated. For my examples, I'm choosing to use controllers over minimal APIs; the controller class attributes make some of what is required easier. For clarity, my examples are stripped of error responses unrelated to conditional requests and exception middleware. For complete source, see &lt;a href="https://github.com/peteraritchie/Examples.Etag"&gt;this repo&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[ApiController] [Route(&amp;quot;[controller]&amp;quot;)]
public class AppointmentController : ControllerBase
{
	[HttpGet(Name = &amp;quot;GetAppointmentRequests&amp;quot;)]
	[ProducesResponseType(typeof(WebCollectionElement&amp;lt;AppointmentRequestDto&amp;gt;[]),
		StatusCodes.Status200OK, MediaTypeNames.Application.Json)]
	public async Task&amp;lt;IActionResult&amp;gt; GetMany(CancellationToken cancellationToken = default)
	{
		var resource = appointmentRequestService.GetRequests(cancellationToken);

		List&amp;lt;WebCollectionElement&amp;lt;AppointmentRequestDto&amp;gt;&amp;gt; items = new();
		foreach (var (dto, guid, concurrencyToken) in await resource.ToListAsync(cancellationToken: cancellationToken))
		{
			items.Add(
				new WebCollectionElement&amp;lt;AppointmentRequestDto&amp;gt;(dto, Url.Action(nameof(GetById),
					new { id = guid })!, etag: concurrencyToken));
		}

		return base.Ok(items);
	}

	[HttpGet(&amp;quot;{id}&amp;quot;, Name = &amp;quot;GetAppointmentRequest&amp;quot;)]
	[ProducesResponseType(typeof(AppointmentRequestDto), StatusCodes.Status200OK, MediaTypeNames.Application.Json)]
	[ProducesResponseType(typeof(AppointmentRequestDto), StatusCodes.Status304NotModified)]
	public async Task&amp;lt;IActionResult&amp;gt; GetById(Guid id, [FromHeader(Name = &amp;quot;If-None-Match&amp;quot;)] string? ifNoneMatch,
		CancellationToken cancellationToken = default)
	{
		var (resource, concurrencyToken) = string.IsNullOrWhiteSpace(ifNoneMatch) 
			? await appointmentRequestService.GetRequest(id, cancellationToken) 
			: await appointmentRequestService.GetRequest(id, ifNoneMatch, cancellationToken);

		HttpContext.Response.Headers.Add(HeaderNames.ETag, concurrencyToken);

		return Ok(resource);
	}

	[HttpPost(Name = &amp;quot;CreateAppointmentRequest&amp;quot;)]
	[Consumes(MediaTypeNames.Application.Json)]
	[ProducesResponseType(StatusCodes.Status201Created)]
	public async Task&amp;lt;IActionResult&amp;gt; Create([FromBody] AppointmentRequestDto appointmentRequest,
		CancellationToken cancellationToken = default)
	{
		var (id, concurrencyToken) = await appointmentRequestService.CreateRequest(appointmentRequest, cancellationToken);

		HttpContext.Response.Headers.Add(HeaderNames.ETag, concurrencyToken);

		return CreatedAtAction(nameof(GetById), routeValues: new { id }, value: null);
	}

	[HttpPut(&amp;quot;{id}&amp;quot;, Name = &amp;quot;ReplaceAppointmentRequest&amp;quot;)]
	[Consumes(MediaTypeNames.Application.Json)]
	[ProducesResponseType(StatusCodes.Status204NoContent)]
	public async Task&amp;lt;IActionResult&amp;gt; Replace(Guid id, [FromBody] AppointmentRequestDto appointmentRequest,
		[FromHeader(Name = &amp;quot;If-Match&amp;quot;)] string? ifMatch, CancellationToken cancellationToken = default)
	{
		var concurrencyToken = string.IsNullOrWhiteSpace(ifMatch)
			? await appointmentRequestService.ReplaceRequest(
				id, appointmentRequest, cancellationToken)
			: await appointmentRequestService.ReplaceRequest(
				id, appointmentRequest, ifMatch, cancellationToken);

		HttpContext.Response.Headers.Add(HeaderNames.ETag, concurrencyToken);

		return NoContent();
	}

	[HttpPatch(&amp;quot;{id:guid}&amp;quot;, Name = &amp;quot;UpdateAppointmentRequest&amp;quot;)]
	[ProducesResponseType(typeof(AppointmentRequestDto), StatusCodes.Status200OK, MediaTypeNames.Application.Json)]
	[Consumes(&amp;quot;application/json-patch+json&amp;quot;)]
	public async Task&amp;lt;IActionResult&amp;gt; Update(Guid id, JsonPatchDocument&amp;lt;AppointmentRequestDto&amp;gt; patchDocument,
		[FromHeader(Name = &amp;quot;If-Match&amp;quot;)] string? ifMatch, CancellationToken cancellationToken = default)
	{
		var (result, concurrencyToken) = string.IsNullOrWhiteSpace(ifMatch)
			? await appointmentRequestService.UpdateRequest(id, patchDocument, cancellationToken)
			: await appointmentRequestService.UpdateRequest(id, patchDocument, ifMatch, cancellationToken);

		HttpContext.Response.Headers.Add(HeaderNames.ETag, concurrencyToken);

		return Ok(result);
	}

	[HttpDelete(&amp;quot;{id}&amp;quot;, Name = &amp;quot;RemoveAppointmentRequest&amp;quot;)]
	[ProducesResponseType(StatusCodes.Status204NoContent)]
	public async Task&amp;lt;IActionResult&amp;gt; Remove(Guid id, [FromHeader(Name = &amp;quot;If-Match&amp;quot;)] string? ifMatch,
		CancellationToken cancellationToken = default)
	{
		if(string.IsNullOrWhiteSpace(ifMatch))
			await appointmentRequestService.RemoveRequest(id, cancellationToken);
		else
			await appointmentRequestService.RemoveRequest(id, ifMatch, cancellationToken);

		return NoContent();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;There are inherent complexities in a Web API. It needs to present an interface usable on the Web and utilizes open standards as much as possible. You'll notice that the &lt;code&gt;AppointmentController&lt;/code&gt; PATCH implementation uses &lt;code&gt;JsonPatchDocument&lt;/code&gt;, an implementation of the &lt;a href="https://jsonpatch.com/"&gt;JSON Patch&lt;/a&gt; (IETF RFC 6902) standard. This standard is specific to the Web, specific to JSON, and deals with operations intended to be specifically applied to JSON representations equivalent to the model defined in the interface (i.e., the model, not what is represented in the database or an in-memory representation of a domain object.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This controller is isolated from the collaboration with the database and delegates that interaction to an Application Service via the &lt;code&gt;appointmentRequestService&lt;/code&gt; field (declaration removed for readability). In state-modifying HTTP methods (PUT, DELETE, PATCH), the actions have an &lt;code&gt;ifMatch&lt;/code&gt; parameter passed in through the &lt;code&gt;If-Match&lt;/code&gt; HTTP request header. When present, it is passed along to the application service for optimistic concurrency. This example shows an &lt;em&gt;optional&lt;/em&gt; use of &lt;code&gt;If-Match&lt;/code&gt;; it's plausible that another implementation might &lt;em&gt;require&lt;/em&gt; the &lt;code&gt;If-Match&lt;/code&gt; header and respond with status code 428 Precondition Required.&lt;/p&gt;
&lt;p&gt;Of note is that this controller abstracts etag header values as &lt;em&gt;concurrency token&lt;/em&gt; text so that nothing else has to deal with HTTP headers.&lt;/p&gt;
&lt;p&gt;Let's look at the MVC model (I prefer to refer to it as a Data Transfer Object).&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class AppointmentRequestDto
{
	[Required]
	public DateTime? CreationDate { get; set; }
	public IEnumerable&amp;lt;string&amp;gt;? Categories { get; set; }
	[Required]
	public string? Description { get; set; }
	public string? Notes { get; set; }
	[Required]
	public AppointmentRequestStatus? Status { get; set; }
	[Required]
	public MeetingDuration? Duration { get; set; }
	[Required]
	public IEnumerable&amp;lt;string&amp;gt;? Participants { get; set; }
	[Required]
	public IEnumerable&amp;lt;DateTime&amp;gt;? ProposedStartDateTimes { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since we're delegating serialization to ASP.NET (which requires writable properties), the properties are nullable but annotated with &lt;code&gt;RequiredAttribute&lt;/code&gt; to signal to the framework what properties are required. There is no identifier in the &lt;code&gt;AppointmentRequestDto&lt;/code&gt; class because we don't want to duplicate it there and in the resource's URI.&lt;/p&gt;
&lt;p&gt;Azure Cosmos has implemented optimistic concurrency control and stores an ETag per document. I'll use Azure Cosmos for the database implementation to show how this can be re-used in your WebAPI.&lt;/p&gt;
&lt;h2 id="azure-cosmos-example"&gt;Azure Cosmos Example&lt;/h2&gt;
&lt;p&gt;In Azure Cosmos, each document has several mandatory properties: &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;_rid&lt;/code&gt;, &lt;code&gt;_self&lt;/code&gt;, &lt;code&gt;_etag&lt;/code&gt;, &lt;code&gt;_attachements&lt;/code&gt;, and &lt;code&gt;_ts&lt;/code&gt;. These are implementation details of the database that we don't want to leak into our API as body content. When we use the &lt;a href="https://www.nuget.org/packages/Microsoft.Azure.Cosmos"&gt;Azure Cosmos SDK&lt;/a&gt;, we need serialization classes to serialize the data to and from a container. Let's see an example with a fictitious appointment request resource:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class AppointmentRequestEntity : CosmosEntityBase
{
    [JsonProperty(PropertyName = &amp;quot;id&amp;quot;)]
    public Guid Id { get; set; }
    [JsonProperty(PropertyName = &amp;quot;_rid&amp;quot;)]
    public string? ResourceId { get; set; }
    [JsonProperty(PropertyName = &amp;quot;_self&amp;quot;)]
    public Uri? SelfUri { get; set; }
    [JsonProperty(PropertyName = &amp;quot;_etag&amp;quot;)]
    public string? ETag{ get; set; }
    [JsonProperty(PropertyName = &amp;quot;_ts&amp;quot;)]
    public int? TimestampText{ get; set; }
	public DateTime? CreationDate { get;  set; }
	public IEnumerable&amp;lt;string&amp;gt;? Categories { get; set; }
	public string? Description { get;  set; }
	public string? Notes { get;  set;  }
	public AppointmentRequestStatus? Status { get;  set; }
	public MeetingDuration? Duration { get;  set; }
	public IEnumerable&amp;lt;string&amp;gt;? Participants { get; set; }
	public IEnumerable&amp;lt;DateTime&amp;gt;? ProposedStartDateTimes { get;  set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice the first five properties that are necessary to access the Azure Cosmos implementation details. (in &lt;a href="https://github.com/peteraritchie/Examples.Etag"&gt;this repo&lt;/a&gt; this is split out into a &lt;code&gt;CosmosEntityBase&lt;/code&gt; class.)&lt;/p&gt;
&lt;p&gt;For my example, I'm going to draw on Domain-Driven design patterns and use a Repository implementation in the database collaboration. I want to delegate all the logic related to database-specific details to the repository implementation. This includes encapsulating the use of the database entity &lt;em&gt;serialization&lt;/em&gt; class (translation to/from the database entity class), associating an identifier and etag with the resource, etc. To separate the existence of the database entity class from clients of the repository, we'll define a generic interface that I'll name &lt;code&gt;IOptimisticallyConcurrentRepository&lt;/code&gt; that works with different types of domain entity classes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public interface IOptimisticallyConcurrentRepository&amp;lt;TDomainEntity&amp;gt;
{
    Task&amp;lt;TDomainEntity&amp;gt; Get(Guid id, CancellationToken cancellationToken = default);
    IAsyncEnumerable&amp;lt;TDomainEntity&amp;gt; Get(CancellationToken cancellationToken = default);
	Guid GetId(TDomainEntity entity);

	bool TryGetIfModified(Guid id, string concurrencyToken, out TDomainEntity? entity);
	string GetConcurrencyToken(TDomainEntity entity);

    Task&amp;lt;Guid&amp;gt; Add(TDomainEntity entity, CancellationToken cancellationToken = default);
    Task Remove(Guid id, CancellationToken cancellationToken = default);
    Task Replace(Guid id, TDomainEntity entity, CancellationToken cancellationToken = default);

    Task RemoveIfMatch(Guid id, string token, CancellationToken cancellationToken = default);
    Task ReplaceIfMatch(Guid id, TDomainEntity entity, string token, CancellationToken cancellationToken = default);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next is a generic repository class to support Azure Cosmos that deals with arbitrary domain (&lt;code&gt;TDomainEntity&lt;/code&gt;) and database serialization classes (&lt;code&gt;TDbEntity&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class CosmosOptimisticallyConcurrentRepository&amp;lt;TDomainEntity, TDbEntity&amp;gt; 
	: IOptimisticallyConcurrentRepository&amp;lt;TDomainEntity&amp;gt;
	where TDomainEntity : class
	where TDbEntity : CosmosEntityBase
{
	private class EntityContext
	{
		public EntityContext(Guid id, string concurrencyToken)
		{
			Id = id;
			ConcurrencyToken = concurrencyToken;
		}

		public Guid Id { get; }
		public string ConcurrencyToken { get; }
	}

	private readonly Container container;
	private readonly ITranslator&amp;lt;TDomainEntity, TDbEntity&amp;gt; dbEntityTranslator;
	private readonly Action&amp;lt;TDbEntity, Guid&amp;gt; setDbEntityId;

	protected CosmosOptimisticallyConcurrentRepository(Container container, ITranslator&amp;lt;TDomainEntity, TDbEntity&amp;gt; dbEntityTranslator,
		Action&amp;lt;TDbEntity, Guid&amp;gt; setDbEntityId)
	{
		this.container = container;
		this.dbEntityTranslator = dbEntityTranslator;
		this.setDbEntityId = setDbEntityId;
	}

	public async Task&amp;lt;Guid&amp;gt; Add(TDomainEntity entity, CancellationToken cancellationToken = default)
	{
		var id = Guid.NewGuid();
		var dbEntity = dbEntityTranslator.ToData(entity);
		setDbEntityId(dbEntity, id);

		try
		{
			var result = await container.CreateItemAsync(dbEntity, new PartitionKey(id.ToString(&amp;quot;D&amp;quot;)), cancellationToken: cancellationToken);
			conditionalWeakTable.Add(entity, new EntityContext(id, result.ETag));
			return id;
		}
		catch (CosmosException ex) when(ex.StatusCode == HttpStatusCode.PreconditionFailed)
		{
			throw new ConcurrencyException();
		}
	}

	public bool TryGetIfModified(Guid id, string concurrencyToken, out TDomainEntity? entity)
	{
		var idText = id.ToString(&amp;quot;D&amp;quot;);
		try
		{
			var result = container.ReadItemAsync&amp;lt;TDbEntity&amp;gt;(
					idText,
					new PartitionKey(idText),
					requestOptions: new ItemRequestOptions() { IfNoneMatchEtag = concurrencyToken })
				.Result;

			entity = dbEntityTranslator.ToDomain(result.Resource);
			conditionalWeakTable.Add(entity, new EntityContext(id, result.ETag));
			return true;
		}
		catch (AggregateException aggregateException) when (aggregateException.InnerExceptions.Count == 1 &amp;amp;&amp;amp;
		                                                    aggregateException.InnerExceptions.Single() is
			                                                    CosmosException
			                                                    {
				                                                    StatusCode: HttpStatusCode.NotModified
			                                                    })
		{
			entity = default;
			return false;
		}
		catch (AggregateException aggregateException) when (aggregateException.InnerExceptions.Count == 1 &amp;amp;&amp;amp;
		                                                    aggregateException.InnerExceptions.Single() is
			                                                    CosmosException
			                                                    {
				                                                    StatusCode: HttpStatusCode.NotFound
			                                                    })
		{
			throw new EntityNotFoundException(id);
		}
		catch (CosmosException ex) when(ex.StatusCode == HttpStatusCode.NotFound)
		{
			throw new EntityNotFoundException(id);
		}
	}

	public async IAsyncEnumerable&amp;lt;TDomainEntity&amp;gt; Get([EnumeratorCancellation] CancellationToken cancellationToken = default)
	{
		var iterator = container.GetItemQueryIterator&amp;lt;TDbEntity&amp;gt;();
		while (iterator.HasMoreResults)
		{
			var set = await iterator.ReadNextAsync(cancellationToken);
			foreach (var e in set)
			{
				var entity = dbEntityTranslator.ToDomain(e);
				conditionalWeakTable.Add(entity, new EntityContext(e.Id, e.ETag!));
				yield return entity;
			}
		}
	}

	public async Task&amp;lt;TDomainEntity&amp;gt; Get(Guid id, CancellationToken cancellationToken = default)
	{
		var idText = id.ToString(&amp;quot;D&amp;quot;);
		try
		{
			var result = await container.ReadItemAsync&amp;lt;TDbEntity&amp;gt;(idText, new PartitionKey(idText), cancellationToken: cancellationToken);
			var entity = dbEntityTranslator.ToDomain(result.Resource);
			conditionalWeakTable.Add(entity, new EntityContext(id, result.ETag));
			return entity;
		}
		catch (CosmosException ex) when(ex.StatusCode == HttpStatusCode.NotFound)
		{
			throw new EntityNotFoundException(id);
		}
	}

	public async Task Replace(Guid id, TDomainEntity entity, CancellationToken cancellationToken = default)
	{
		var dbEntity = dbEntityTranslator.ToData(entity);
		setDbEntityId(dbEntity, id);

		try
		{
			_ = await container.UpsertItemAsync(dbEntity, cancellationToken: cancellationToken);
		}
		catch (CosmosException ex) when(ex.StatusCode == HttpStatusCode.NotFound)
		{
			throw new EntityNotFoundException(id);
		}
	}

	public async Task ReplaceIfMatch(Guid id, TDomainEntity entity, string token, CancellationToken cancellationToken = default)
	{
		var idText = id.ToString(&amp;quot;D&amp;quot;);
		var dbEntity = dbEntityTranslator.ToData(entity);
		setDbEntityId(dbEntity, id);

		var requestOptions = new ItemRequestOptions { IfMatchEtag = token };
		try
		{
			_ = await container.ReplaceItemAsync(dbEntity, idText, new PartitionKey(idText), requestOptions: requestOptions, cancellationToken: cancellationToken);
		}
		catch (CosmosException ex) when (ex.StatusCode == HttpStatusCode.PreconditionFailed)
		{
			throw new ConcurrencyException();
		}
		catch (CosmosException ex) when(ex.StatusCode == HttpStatusCode.NotFound)
		{
			throw new EntityNotFoundException(id);
		}
	}

	public async Task Remove(Guid id, CancellationToken cancellationToken = default)
	{
		var idText = id.ToString(&amp;quot;D&amp;quot;);

		try
		{
			_ = await container.DeleteItemAsync&amp;lt;TDbEntity&amp;gt;(idText, new PartitionKey(idText), cancellationToken: cancellationToken);
		}
		catch (CosmosException ex) when(ex.StatusCode == HttpStatusCode.NotFound)
		{
			throw new EntityNotFoundException(id);
		}
	}

	public async Task RemoveIfMatch(Guid id, string token, CancellationToken cancellationToken = default)
	{
		var idText = id.ToString(&amp;quot;D&amp;quot;);

		var requestOptions = new ItemRequestOptions { IfMatchEtag = token };
		try
		{
			_ = await container.DeleteItemAsync&amp;lt;TDbEntity&amp;gt;(idText, new PartitionKey(idText), requestOptions: requestOptions, cancellationToken: cancellationToken);
		}
		catch (CosmosException ex) when (ex.StatusCode == HttpStatusCode.PreconditionFailed)
		{
			throw new ConcurrencyException();
		}
		catch (CosmosException ex) when(ex.StatusCode == HttpStatusCode.NotFound)
		{
			throw new EntityNotFoundException(id);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a reminder, a &amp;quot;concurrency token&amp;quot; is synonymous with an &amp;quot;etag&amp;quot; in the context of the repository.&lt;/p&gt;
&lt;p&gt;The persistence needs of an application are independent of a domain entity, so the domain entity is isolated from web/database identifiers, concurrency tokens, HTTP, etags, etc. So, the repository needs to translate from a domain object to the serialization object, which is performed mostly by an &lt;code&gt;ITranslator&amp;lt;TDomain, TData&amp;gt;&lt;/code&gt; implementation but also with the assignment of the identifier to the serialization object. To keep the non-domain details isolated from the domain object, I've used the &lt;code&gt;ConditionalWeakTable&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; type to associate database persistence details (ID and etag/concurrency token, as abstracted by &lt;code&gt;EntityContext&lt;/code&gt;) to the object without too much management logic.&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;&lt;code&gt;ConditionalWeakTable&lt;/code&gt; is like a dictionary that associates a value with another object. It differs from a traditional dictionary in that when the key is no longer referenced, the associated value is freed/destroyed. This allows us to get associated data with minimal memory impact easily.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;An implementation of the repository now just requires the type to use for the database serialization class, the domain entity type, and how to assign an identifier to the Azure Cosmos &lt;code&gt;id&lt;/code&gt; property:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public sealed class CosmosAppointmentRequestRepository : CosmosOptimisticallyConcurrentRepository&amp;lt;AppointmentRequest, AppointmentRequestEntity&amp;gt;
{
    public CosmosAppointmentRequestRepository(Container container, ITranslator&amp;lt;AppointmentRequest, AppointmentRequestEntity&amp;gt; appointmentRequestEntityTranslator)
        : base(container, appointmentRequestEntityTranslator, (entity, guid) =&amp;gt; entity.Id = guid)
    {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only remaining part is the implementation of the application/database collaboration, the &lt;em&gt;application service&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class AppointmentRequestService
{
	private readonly AppointmentRequestDtoTranslator appointmentRequestDtoTranslator;
	private readonly IOptimisticallyConcurrentRepository&amp;lt;AppointmentRequest&amp;gt; repository;

	public AppointmentRequestService(AppointmentRequestDtoTranslator appointmentRequestDtoTranslator, IOptimisticallyConcurrentRepository&amp;lt;AppointmentRequest&amp;gt; repository)
	{
		this.appointmentRequestDtoTranslator = appointmentRequestDtoTranslator;
		this.repository = repository;
	}

	public async Task&amp;lt;(Guid, string)&amp;gt; CreateRequest(AppointmentRequestDto appointmentRequest, CancellationToken cancellationToken = default)
	{
		var entity = appointmentRequestDtoTranslator.AppointmentRequestDtoToAppointmentRequest(appointmentRequest);
		var guid = await repository.Add(entity, cancellationToken);

		return (guid, repository.GetConcurrencyToken(entity));
	}

	public async Task&amp;lt;(AppointmentRequestDto, string)&amp;gt; GetRequest(Guid id, CancellationToken cancellationToken = default)
	{
		var appointmentRequest = await repository.Get(id, cancellationToken);
		return (appointmentRequestDtoTranslator.AppointmentRequestToAppointmentRequestDto(appointmentRequest), repository.GetConcurrencyToken(appointmentRequest));
	}

	public Task&amp;lt;(AppointmentRequestDto, string)&amp;gt; GetRequest(Guid id, string etag, CancellationToken _ = default)
	{
		if(repository.TryGetIfModified(id, etag, out var appointmentRequest))
		{ 
			return Task.FromResult((appointmentRequestDtoTranslator.AppointmentRequestToAppointmentRequestDto(appointmentRequest!), repository.GetConcurrencyToken(appointmentRequest!)));
		}

		throw new ConcurrencyException();
	}

	public async IAsyncEnumerable&amp;lt;(AppointmentRequestDto, Guid, string)&amp;gt; GetRequests([EnumeratorCancellation] CancellationToken cancellationToken = default)
	{
		var result = repository.Get(cancellationToken);
		await foreach (var item in result.WithCancellation(cancellationToken))
		{
			yield return (appointmentRequestDtoTranslator.AppointmentRequestToAppointmentRequestDto(item), repository.GetId(item),
				repository.GetConcurrencyToken(item));
		}
	}

	public async Task RemoveRequest(Guid id, CancellationToken cancellationToken = default)
	{
		await repository.Remove(id, cancellationToken);
	}

	public async Task RemoveRequest(Guid id, string etag, CancellationToken cancellationToken = default)
	{
		await repository.RemoveIfMatch(id, etag, cancellationToken);
	}

	internal async Task&amp;lt;string&amp;gt; ReplaceRequest(Guid id, AppointmentRequestDto appointmentRequest,
		CancellationToken cancellationToken = default)
	{
		var entity = appointmentRequestDtoTranslator.AppointmentRequestDtoToAppointmentRequest(appointmentRequest);
		await repository.Replace(id, entity, cancellationToken);

		return repository.GetConcurrencyToken(entity);
	}

	internal async Task&amp;lt;string&amp;gt; ReplaceRequest(Guid id, AppointmentRequestDto appointmentRequest, string etag,
		CancellationToken cancellationToken = default)
	{
		var entity = appointmentRequestDtoTranslator.AppointmentRequestDtoToAppointmentRequest(appointmentRequest);
		await repository.ReplaceIfMatch(id, entity, etag, cancellationToken);

		return repository.GetConcurrencyToken(entity);
	}

	public async Task&amp;lt;(AppointmentRequestDto, string)&amp;gt; UpdateRequest(Guid id, JsonPatchDocument&amp;lt;AppointmentRequestDto&amp;gt; patchDocument,
		CancellationToken cancellationToken = default)
	{
		var current = await repository.Get(id, cancellationToken);
		var currentDto = appointmentRequestDtoTranslator.AppointmentRequestToAppointmentRequestDto(current);
		patchDocument.ApplyTo(currentDto);
		await repository.Replace(id, appointmentRequestDtoTranslator.AppointmentRequestDtoToAppointmentRequest(currentDto), cancellationToken);
		return (currentDto, repository.GetConcurrencyToken(current));
	}

	public async Task&amp;lt;(AppointmentRequestDto, string)&amp;gt; UpdateRequest(Guid id, JsonPatchDocument&amp;lt;AppointmentRequestDto&amp;gt; patchDocument,
		string etag, CancellationToken cancellationToken = default)
	{
		var current = await repository.Get(id, cancellationToken);
		var currentDto = appointmentRequestDtoTranslator.AppointmentRequestToAppointmentRequestDto(current);
		patchDocument.ApplyTo(currentDto);
		await repository.ReplaceIfMatch(id, appointmentRequestDtoTranslator.AppointmentRequestDtoToAppointmentRequest(currentDto), etag, cancellationToken);
		return (currentDto, repository.GetConcurrencyToken(current));
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;AppointmentRequestService&lt;/code&gt; contains the interaction logic specific to the application and the repository. Since there&lt;/p&gt;
&lt;p&gt;Dealing with translation to and from DTO, domain, and serialization classes is made less of a chore with tools like &lt;a href="https://github.com/riok/mapperly"&gt;Mapperly&lt;/a&gt;. &lt;a href="https://github.com/riok/mapperly"&gt;Mapperly&lt;/a&gt; will generate translation code based on property names. To create a translator to/from two types is easy as creating a partial class with a &lt;code&gt;MapperAttribute&lt;/code&gt; attribute with partial methods that take one type as parameter and the other as a return:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Mapper]
public partial class AppointmentRequestDtoTranslator
{
	public partial AppointmentRequest AppointmentRequestDtoToAppointmentRequest(AppointmentRequestDto dto);
	public partial AppointmentRequestDto AppointmentRequestToAppointmentRequestDto(AppointmentRequest entity);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;AppointmentRequestDtoTranslator&lt;/code&gt; translates &lt;code&gt;AppointmentRequestDto&lt;/code&gt; instances to/from &lt;code&gt;AppointmentRequest&lt;/code&gt; domain entity instances. And to translate to/from &lt;code&gt;AppointmentRequestEntity&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Mapper]
public partial class AppointmentRequestEntityTranslator : ITranslator&amp;lt;AppointmentRequest, AppointmentRequestEntity&amp;gt;
{
	[MapperIgnoreSource(nameof(AppointmentRequestEntity.Id))]
	[MapperIgnoreSource(nameof(AppointmentRequestEntity.ResourceId))]
	[MapperIgnoreSource(nameof(AppointmentRequestEntity.ETag))]
	[MapperIgnoreSource(nameof(AppointmentRequestEntity.SelfUri))]
	[MapperIgnoreSource(nameof(AppointmentRequestEntity.TimestampText))]
	public partial AppointmentRequest ToDomain(AppointmentRequestEntity data);

	[MapperIgnoreTarget(nameof(AppointmentRequestEntity.Id))]
	[MapperIgnoreTarget(nameof(AppointmentRequestEntity.ResourceId))]
	[MapperIgnoreTarget(nameof(AppointmentRequestEntity.ETag))]
	[MapperIgnoreTarget(nameof(AppointmentRequestEntity.SelfUri))]
	[MapperIgnoreTarget(nameof(AppointmentRequestEntity.TimestampText))]
	public partial AppointmentRequestEntity ToData(AppointmentRequest domain);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since &lt;code&gt;AppointmentRequestEntity&lt;/code&gt; has some Azure Cosmos implementation details, we use Mapprerly's &lt;code&gt;MapperIgnoreTargetAttribute&lt;/code&gt; and &lt;code&gt;MapperIgnoreSourceAttribute&lt;/code&gt; to tell &lt;a href="https://github.com/riok/mapperly"&gt;Mapperly&lt;/a&gt; that not all properties need translation.&lt;/p&gt;
&lt;p&gt;Dealing with concurrency issues and implementing concurrency control can be intimidating. In this post, I make it less intimidating by clarifying some specifics by showing an example implementation with ASP.NET Core and Azure Cosmos DB. Additionally, the Domain-Driven Design patterns Repository and Application Service are used to isolate etag implementation details from the Web API to delegate that to Azure Cosmos.&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;There are multiple ways of implementing optimistic concurrency; HTTP ETags are but one way. If you can't abide by the expectations set out by the HTTP standards, don't use Etags. There's nothing that forces you to use HTTP precondition header fields. But, remember, the means exist in HTTP, and embracing it will promote interoperability and reliability (to implement something different than something introduced at least 26 years ago fails to recognize the huge amount of validation and verification that's gone into making it correct.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In a future post, I will show an example of a repository implementation that uses Entity Framework and its expectations for concurrency tokens.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/farside-etags-in-asp-dot-net.jpg" class="img-fluid" alt="lots of things going on at the same time, in the style of Farside"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/http-and-etag-header-fields</id>
		<title>HTTP and ETag Header Fields</title>
		<link href="http://blog.peterritchie.com/posts/http-and-etag-header-fields" />
		<updated>2023-06-15T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="../assets/accidental-overwrite.jpg" class="img-fluid" alt="A stuffed tiger corrupted appearance due to accidental overwrite" /&gt;&lt;/p&gt;
&lt;p&gt;Update: corrected mention of &lt;code&gt;412&lt;/code&gt; in the context of &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;If-Modified-Since&lt;/code&gt; to &lt;code&gt;304&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Over the last four-plus years, I have been almost exclusively working on some sort of *-as-a-Service (*aaS)—for example, Mortgage Origination as a Service, Insurance Claims as a Service. I always see a couple of things when implementing Web (HTTP) services: the &lt;em&gt;reinvention of the wheel&lt;/em&gt; and recognizing the problem ETags solves after publishing a specification (sometimes both).&lt;/p&gt;
&lt;p&gt;With *aaS as a Web API, the intention is to have multiple API clients providing access to representations of shared resources. Early in projects like this involves an initial (single) client, so the chances of a client having a stale resource representation are slim. When another client starts to use the API and an update gets accidentally overwritten, things get needlessly complicated.&lt;/p&gt;
&lt;p&gt;I've seen teams address this problem in a number of ways, often involving a date-time stamp. With multiple clients on an API, scalability is an issue, and a date-time stamp can mean different things to different servers (as we'll see below). You need a single authority for a resource's last modified date-time to avoid exchanging one problem for another. See &lt;a href="https://datatracker.ietf.org/doc/html/rfc7232#section-2.2.2"&gt;Last-Modified/Comparison&lt;/a&gt; for more details.&lt;/p&gt;
&lt;p&gt;The creators of HTTP encountered this issue and added features to HTTP to deal with this (I assume that's why they added these features). I don't know when these features were devised, but they proposed them in 1997. So, they've been in the wild for at least 25 years with the entire web as a test bed. So, many brilliant people either created or scrutinized the solution. i.e., it's a wheel.&lt;/p&gt;
&lt;p&gt;The HTTP features are &lt;em&gt;ETags&lt;/em&gt; and &lt;em&gt;conditional requests&lt;/em&gt; and enable &lt;em&gt;optimistic concurrency&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id="etags"&gt;ETags&lt;/h2&gt;
&lt;p&gt;An &lt;a href="https://datatracker.ietf.org/doc/html/rfc7232#section-2.3"&gt;ETag&lt;/a&gt; (AKA entity-tag) addresses the &amp;quot;lost update&amp;quot; problem where there are two clients of an API that have received the representation of a version of an entity. Still, another client updates the entity before the other: the second update causes the first the be &amp;quot;lost.&amp;quot; See the following diagram for a visualization:&lt;/p&gt;
&lt;p&gt;&lt;img src="./assets/lost-update-sequence.png" class="img-fluid" alt="Lost-update" /&gt;&lt;/p&gt;
&lt;p&gt;An ETag addresses accidental overwrite by &lt;em&gt;versioning&lt;/em&gt; the resource with an entity-tag (a hash of the representation, a version, etc.). When a client requests a resource, the server may include an ETag validator header field with an entity-tag value in the response. The URI of the resource, along with that entity-tag, constitutes an identifier for a particular version of an entity.&lt;/p&gt;
&lt;p&gt;When a client requests a change to the entity, it includes the entity-tag as a basis version with a conditional header field (like &lt;code&gt;If-Match&lt;/code&gt;.)  The server responds with &lt;code&gt;412 (Precondition Failed)&lt;/code&gt;, and the client can retrieve the latest version, re-apply their change, and re-send. See the following diagram for a visualization:&lt;/p&gt;
&lt;p&gt;&lt;img src="./assets/lost-update-solution-sequence.png" class="img-fluid" alt="Lost-update" /&gt;&lt;/p&gt;
&lt;h2 id="falling-back-to-date-and-time"&gt;Falling back to date and time&lt;/h2&gt;
&lt;p&gt;Even if you use date and time, &lt;strong&gt;HTTP also covers you with other precondition header fields involving modification date&lt;/strong&gt;. The &lt;code&gt;If-Unmodified-Since&lt;/code&gt; and &lt;code&gt;If-Modified-Since&lt;/code&gt; precondition header fields allow you to pass modification date preconditions to make a request conditional. When the precondition isn't met, a &lt;code&gt;412 (Precondition Failed)&lt;/code&gt; status code will be in the response, or for &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt;, a &lt;code&gt;304 (Not Modified)&lt;/code&gt; status code will be in the response.&lt;/p&gt;
&lt;p&gt;The initial GET of a resource that supports modification dates in conditional requests will include a &lt;code&gt;Last-Modified&lt;/code&gt; header field validator. The &lt;code&gt;Last-Modified&lt;/code&gt; validator is in the form of an &lt;a href="https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1"&gt;HTTP-date&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="being-successful"&gt;Being Successful&lt;/h2&gt;
&lt;p&gt;RFC 7232, the HTTP 1.1 specification, section 2.3 describes the &lt;em&gt;entity-tag&lt;/em&gt;:&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;An entity-tag is an opaque validator for differentiating between multiple representations of the same resource, regardless of whether those multiple representations are due to resource state changes over time, content negotiation resulting in multiple representations being valid at the same time, or both.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This means that the ETag value depends on the content-type, so two &lt;strong&gt;different representations of the same resource should have different ETag values&lt;/strong&gt; (e.g., one gzip encoded, one not.)&lt;/p&gt;
&lt;p&gt;This also means that the ETag value is opaque to requestors but does point out that one of the intents of ETags to be &lt;strong&gt;an alternative to using a date-time stamp due to lack of accuracy&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id="patch"&gt;PATCH&lt;/h3&gt;
&lt;p&gt;Using &lt;code&gt;PATCH&lt;/code&gt; with something like &lt;a href="https://jsonpatch.com/"&gt;JSONPatch&lt;/a&gt; may seem to help alleviate conflicts by providing more granularity in what is changing. Technically true, to implement this would be non-trivial. The ETag specifics a tag of that edition of the entire resource, not any one field. While comparing a change against a delta between two editions of a resource (keeping in mind those editions may not be adjacent) might be one technique for dealing with that, &lt;strong&gt;creating deltas between arbitrary versions of the same resource is non-trivial&lt;/strong&gt;. You could introduce that sort of thing. Something like event-sourcing might enable that. But remember that there may be interdependencies between properties of a resource, and just because the current request changes a property that hasn't changed since the resource was retrieved doesn't mean there isn't still a conflict.&lt;/p&gt;
&lt;h3 id="last-modified"&gt;Last-Modified&lt;/h3&gt;
&lt;p&gt;Remember that &lt;code&gt;Last-Modified&lt;/code&gt; uses &lt;a href="https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1"&gt;HTTP-date&lt;/a&gt; format, so &lt;strong&gt;&lt;code&gt;Last-Modified&lt;/code&gt; only supports second granularity&lt;/strong&gt;. With multiple origin servers, more than second granularity may be needed to be accurate 100% of the time.&lt;/p&gt;
&lt;h4 id="if-unmodified-since"&gt;If-Unmodified-Since&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt; is used with state-changing methods like PUT, POST, DELETE, and PATCH to avoid accidental overrides (lost updates). &lt;code&gt;If-Unmodified-Since&lt;/code&gt; imposes the precondition &lt;em&gt;update this entity only if it hasn't changed since the provided date-time&lt;/em&gt;. &lt;strong&gt;Use &lt;code&gt;If-Unmodified-Since&lt;/code&gt; to avoid lost update problems when second granularity is not a problem&lt;/strong&gt;.&lt;/p&gt;
&lt;h4 id="if-modified-since"&gt;If-Modified-Since&lt;/h4&gt;
&lt;p&gt;When used with &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt;, the &lt;code&gt;If-Modified-Since&lt;/code&gt; header field imposes the precondition &lt;em&gt;respond with &lt;code&gt;304 (Not Modified)&lt;/code&gt; and not with an entity representation if the modification date of the identified resource is not more recent than the date provided&lt;/em&gt;. &lt;strong&gt;Use &lt;code&gt;If-Modified-Since&lt;/code&gt; to avoid re-transferring the same data&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id="conflict"&gt;&lt;code&gt;409 (Conflict)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;409 (Conflict)&lt;/code&gt; may sound like an appropriate response to a conditional PUT/POST/PATCH request, except that &lt;code&gt;412 (Precondition Failed)&lt;/code&gt; is expected. &lt;strong&gt;Response status code &lt;a href="https://datatracker.ietf.org/doc/html/rfc7231#section-6.5.8"&gt;&lt;code&gt;409&lt;/code&gt;&lt;/a&gt; should be used when something about the current state of the resource means that the server cannot change it&lt;/strong&gt;. Also, if you have chosen not to use HTTP precondition features and have included something &lt;em&gt;in the representation of the entity&lt;/em&gt; for versioning (like last-modified-date, see above), then &lt;code&gt;409 (Conflict)&lt;/code&gt; is appropriate to signify a potential accidental overwrite or lost update.&lt;/p&gt;
&lt;h3 id="leveraging-existing-implementations"&gt;Leveraging Existing Implementations&lt;/h3&gt;
&lt;p&gt;Azure Cosmos DB implements ETags and &lt;code&gt;Last-Modified&lt;/code&gt; to be leveraged to support the versioning of resources in your Web API. Technically the ETag is a version of the representation that Cosmos DB provides, so consider generating a new ETag based on what Cosmos DB provides, especially if you support more than one content-type (like XML). Suppose you have the concept of a database DTO or database models different from your MVC models. In that case, you should consider custom entity-tag generation based on the Cosmos-supplied entity-tag.&lt;/p&gt;
&lt;p&gt;To leverage the Cosmos-supplied entity-tag, retain it and re-send it in any state-changing requests to Cosmos in the &lt;code&gt;If-Match&lt;/code&gt; header field. If the entity-tags do not match, Cosmos DB will respond with &lt;code&gt;412&lt;/code&gt;, and the Cosmos DB library will throw a &lt;code&gt;CosmosException&lt;/code&gt; with &lt;code&gt;StatusCode&lt;/code&gt; == &lt;code&gt;HttpStatusCode.PreconditionFailed&lt;/code&gt;.&lt;/p&gt;
&lt;!--
title Lost Update Problem

participant "Client 1" as Client1
participant "Client 2" as Client2
participant API

Client1-&gt;API:""GET /resource/123""
activate Client1
Client1&lt;--API:""200 OK""\n//resource v1 representation//

create Client2
Client2-&gt;API:""GET /resource/123""
activate Client2
Client2&lt;--API:""200 OK""\n//resource v1 representation//
Client1-&gt;API:""PUT /resource/123""
Client1&lt;--API:""200 OK""\n//resource v2 representation//
deactivateafter Client1
destroyafter Client1

Client2-#red&gt;API:""PUT /resource/123""
note over Client1,API#pink:Client 2 is updating the resource based from **v1**, not **v2**:\n&lt;align:center&gt;the v2 update is "lost" to //Client 2//&lt;/align&gt;
Client2&lt;--API:""200 OK""\n//resource v3 representation//

--&gt;
&lt;!--
title Lost Update Solution

participant "Client 1" as Client1
participant "Client 2" as Client2
participant API

Client1-&gt;API:""GET /resource/123""
activate Client1
Client1&lt;--API:""200 OK""\n//resource v1 representation//

create Client2
Client2-&gt;API:""GET /resource/123""
activate Client2
Client2&lt;--API:""200 OK""\n//resource v1 representation//
Client1-&gt;API:""PUT /resource/123\nIf-Match: v1""
Client1&lt;--API:""200 OK""\n//resource v2 representation//
deactivateafter Client1
destroyafter Client1

Client2-&gt;API:""PUT /resource/123\nIf-Match: v1""

Client2&lt;--API:&lt;color:#red&gt;""412 Precondition Failed\nBasis version of resource is out of date""&lt;/color&gt;
--&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="../assets/accidental-overwrite.jpg" class="img-fluid" alt="A stuffed tiger corrupted appearance due to accidental overwrite"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/Being-Successful-With-Domain-Driven-Design--Minimal-Complexity-Part-3</id>
		<title>Being Successful with Domain-Driven Design: Minimal Complexity, Part 3</title>
		<link href="http://blog.peterritchie.com/posts/Being-Successful-With-Domain-Driven-Design--Minimal-Complexity-Part-3" />
		<updated>2023-06-12T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="/assets/complex-relationships.jpg" class="img-fluid" alt="complex-relationships" /&gt;&lt;/p&gt;
&lt;p&gt;With a name like &amp;quot;Domain-Driven Design,&amp;quot; it should be no surprise there is a major focus on the domain and has a huge influence on implementation. We've focused mostly on strategic design patterns and practices like Ubiquitous Language, Bounded Context, etc. But I've also covered a bit of tactical design and implementation. I've transitioned from strategical patterns--that deal with being explicit with domain concepts (Ubiquitous Language, Bounded Contexts)--to tactical patterns that have focused on directly translating domain concepts into code structure or coding patterns (like Services and Aggregates.)&lt;/p&gt;
&lt;p&gt;The concepts and their consistency boundaries are only a couple of things that contribute to the complexity of non-trivial domains. For example, the work required to implement a domain is independent of its concepts and consistency boundaries. Additionally, the system's quality attributes and technical constraints are major influencers on the internal structure of that system. The next set of Domain-Driven Design patterns I'll get into (&lt;em&gt;tactical&lt;/em&gt; patterns) aid in this respect. As we get closer to implementation, the focus turns more towards isolating domain complexity from implementation complexities.&lt;/p&gt;
&lt;p&gt;As with many things in Domain-Driven Design, &lt;em&gt;x&lt;/em&gt; for the sake of &lt;em&gt;x&lt;/em&gt; is not the intention. Many things in most methodologies can be regurgitated and used by rote, providing little to no value. The principles and practices in Domain-Driven Design are best utilized with purpose and intent. Architectural layering is a good example. Each layer needs a reason for being (a purpose) with unidirectional  independence of its concepts from another layer's concepts. Just any two groupings won't do; without the purposeful intent of having two layers with a unidirectional dependency, you'll never gain the benefits of layering. You end up with the added burden of managing a structure that does not give you any layered benefits.&lt;/p&gt;
&lt;p&gt;The minimum complexity for layers is that two groups of concepts (contexts) are uni-directionally interdependent. In Domain-Driven Design, those layers focus on isolating the concerns of a User Interface, Application, Domain, and Infrastructure.&lt;/p&gt;
&lt;p&gt;The Application layer may seem unique to Domain-Driven Design. There are few patterns/methodologies that isolates the concern that the application layer deals with. Ports and Adapters (Hexagonal) and, by extension, Clean Architecture recognize and isolate high-level &lt;em&gt;use cases&lt;/em&gt; from both the domain and the implementation details of a UI. This is the role of the Application layer in Domain-Driven Design to further isolate the domain from how any use case uses the domain (a use case &lt;em&gt;applies&lt;/em&gt; or &lt;em&gt;realizes&lt;/em&gt; the domain). In Ports and Adapters, uses-cases (or, as Cockburn describes, uses-cases) are sequences of interactions between the system and users/actors. With the recognition of these interactions, they can now be isolated as collaborations within the Application layer.&lt;/p&gt;
&lt;p&gt;There are other patterns that isolate interaction behavior structurally within collaborations like the Adapter pattern, but I'll save that for another day.&lt;/p&gt;
&lt;p&gt;A UI may have to deal with different form factors, communication protocols, execution contexts, etc. A loosely coupled UI involves designing an interface that takes all of those things into consideration to be successful. A web-based UI requires a backend that supports open protocols and standards. Protocols and standards relating to implementation or delivery are merely constraints on how a system is implemented. At some level, the domain needs to operate correctly regardless of those constraints.&lt;/p&gt;
&lt;p&gt;Layers are like different team roles, all working together simultaneously to accomplish specific types of goals. Bounded contexts are also like multiple teams, sometimes like a night shift and a day shift or an on-shore and an off-shore team. These types of teams work with some level of independence: shifts may never work together simultaneously, and on- and off-shore teams only work together for a brief time with much more structured communication.&lt;/p&gt;
&lt;p&gt;Recognizing and planning for how teams contribute to the same goals is key for these teams to be effective. It's the recognition that different parts of a larger system need different levels of independence. With teams, this is to utilize resources effectively: like how shifts can use limited resources (human skills) across more of the day (e.g., 24 hours instead of 8.)  Conway's law is just an observation (i.e., a reality). A team (or teams) structure imposes a means and cadence to communication. How often and the way inter-team communications occurs has implicit limits on that communication.&lt;/p&gt;
&lt;p&gt;Recognizing and working with that communications structure can make teams much more successful. Domain-Driven Design makes domains and sub-domains first-class citizens within the practices. Many aspects of architectural and social boundaries can affect the release of a product. A Bounded Context is more than a consistency boundary or scope of a domain model. A Bounded Context also involves work products (deployments, deliverables) and team organization.&lt;/p&gt;
&lt;p&gt;For example, the consistency boundary of a mortgage loan application becoming complete and submitted is a fairly obvious boundary and context. Still, the amount of work involved to support that might be fairly large. The number of people implementing and supporting that context might amount to several teams. The complexity of dealing with several teams of people to deliver parts of the same system can be enormous. Domain-Driven Design also gives us some patterns and practices to address those complexities. You may need to split a domain into more bounded contexts because one context is too complex for a single team to manage. When we start to talk about separating work across teams, we're still talking about bounded contexts. For similar reasons, you may need to split a domain into more bounded contexts (and thus &amp;quot;sub-domains&amp;quot;) simply because of an existing team or reporting structure.&lt;/p&gt;
&lt;p&gt;For delivery to be more successful, it's important to recognize the different teams, reporting structures, team motivations, and missions within the strategic design of the Bounded Contexts. How two teams and how the work product of those two teams interact is unique. Fortunately, there are some patterns to address the dependencies between two teams and their work products that help us address their inherent complexities. I'm assuming there's always some degree of interdependency and independence, and I'm ignoring mutually independent (Separate Ways) and Big Ball of Mud relationships/structures.&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;It's worth noting that as soon as two contexts are recognized the need to translate between the two becomes a reality. As context become complex to the point of being bounded context so too does the need to recognize and isolate translation. Much of what we do in Domain-Driven Design is the isolation of concepts, concerns, responsibilities, etc. The need for a translation layer is no different.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There is a spectrum to the degree of independence of two teams and or the independence of their work products. The teams are very dependent on one end, while the other is extremely independent. With Domain-Driven Design, very dependent teams exhibit a lot of domain overlap. With a lot of domain overlap, you can have an interdependence where teams work as equals or partners. This partnership can manifest in an early re-org of people working on existing or legacy systems. That partnership may start with different teams working on separate parts of the codebase. This partnership may only be one step in the evolution of the teams; the next step is often to organize teams toward the Shared Kernel model.&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;A spectrum of options is a synonym for &lt;em&gt;infinite combinations&lt;/em&gt;. It's nice to have flexibility, but an endless set of possibilities is hard to map to a finite set of patterns, and it's hard to use established practices if every situation is novel. There are some ideas and structures that Domain-Driven Design details to add some granularity to the domain we're modeling so that we can more easily map complexity to the patterns and practices that address them.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the Shared Kernel model, the team carves off a separate shared codebase or a shared component to contain all the things that two or more teams will always or almost always mutually require. A Shared Kernel model involves organizational behavior, like specific responsibilities, code areas, accountability, etc. But Shared Kernel is a fairly casual relationship. With more formality between two teams or components, you usually see an Upstream/Downstream relationship form. It is easy to view the users of the Shared Kernel downstream dependents and evolve to a more formal Upstream/Downstream relationship. A Customer/Supplier model may emerge in cases like this.&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;A shared codebase is more casual than a shared component, but a shared component promotes more independence. At the component level, it's important to ensure that autonomy hasn't allowed the teams to deviate from a shared plot, which Continuous Integration is intended to address. The component should be integrated with client code at every opportunity. The intent of a Published Language is for all contexts to be on the same page in understanding that domain. It's not that all contexts will adopt the published language as their domain, but they know how to translate in and out of their domain.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the Customer/Supplier model, one team owns a component the other uses as the consumer of the component's capabilities. The team that owns the component is the Supplier, and the team that uses it is the Customer. With this model comes organizational behavior with more specific responsibilities, more planning, and scheduling. With this increased independence, the supplier team has very specific goals in which the customer team has a stake and influence, represented in a release cadence and a roadmap. The Customer is usually the driver of what capabilities the component provides next. The integration model of Customer/Supplier is usually a web service.&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;In a Upstream/Downstream model, there will almost always be some form of Published Language--usually more formal than just a description, often a specification. Translation becomes more formal in a Upstream/Downstream model, often resulting in a translation layer. If the Upstream/Downstream relationship is between two Bounded Contexts with a high degree of independence an Anticorruption Layer is used on one side to manage the differences communicating between the two domains.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Shared kernel and two-team customer/supplier relationships often exist due to the reporting structure or that reporting structure was created to split work across two teams. In a more product-focused organization, you may have a Customer/Supplier model with more than one customer. Multi-customer relationships can be witnessed in larger organizations with things like shared libraries. The customers are still driving the capabilities that the component and team provide them, but it can become more formal to manage the unique requirements of different customers. The supplier team is often more organized or formal and may have more of a product strategy with a product vision and mission that helps guide their work.&lt;/p&gt;
&lt;blockquote class="blockquote"&gt;
&lt;p&gt;With more formal relationships come more formal expectations. Those expectations may come in the form of specifications and processes. Continuous Integration is an example of a process that continuously validates integrability. Potentially less formal than a specification may be a Published Language--which in its simplest form is a description of the concepts of a domain. (more complex forms would be varying degrees of specifications.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Communications with a customer/supplier model within the same organization can be informal. What the team is working on and how they interact with customers might be more like partnerships; teams may work closely together to implement and integrate components. The number of customers or distance from customers can impact this informalness. The further away a customer is (different division, different organization, different company) may impose more formality to the relationship. The work product of the supplier team may be viewed more like a product. And while customers may drive that product, it may be much more formal to the point where the component is independent of any single customer. This type of relationship may be structured more like a service with a very specific or well-specified interface. Moving towards a well-specified interface is the intent of an Open Host Service where the component is remotely accessed (a service) with a specified protocol and interface.&lt;/p&gt;
&lt;p&gt;As a customer has less influence on a service, they may become completely dependent on the supplier team to provide the capabilities they require. They accept the risk that the supplier team may not provide the necessary capabilities in the future. This is extreme, and either no organization would accept this risk, or it is a temporary relationship. In reality, the different models aren't mutually exclusive, but there is a tendency towards one of them. e.g., a relationship tends to be less like a customer/supplier relationship and more like one completely conforming to another. The recognition of this relationship is called the Conformist model.&lt;/p&gt;
&lt;p&gt;highlight: Recognize change will happen but don't try to create a design that accommodates all change.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="/assets/complex-relationships.jpg" class="img-fluid" alt="complex-relationships"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/Being-Successful-With-Domain-Driven-Design--Minimal-Complexity-Part-2</id>
		<title>Being Successful with Domain-Driven Design: Minimal Complexity, Part 2</title>
		<link href="http://blog.peterritchie.com/posts/Being-Successful-With-Domain-Driven-Design--Minimal-Complexity-Part-2" />
		<updated>2023-05-29T00:00:00Z</updated>
		<content>&lt;p&gt;In part one, I talked about the complexity in the language used to communicate the domain. Domain-Driven Design (DDD) deals with that complexity by isolating the concepts in a clear language that domain experts understand. Ubiquitous Language helps form the basis of all the other patterns and practices in Domain-Driven Design through the clear isolation of domain &lt;em&gt;concepts&lt;/em&gt;. The DDD pattern language context map provides a good example of isolating concepts (in this case, Domain-Driven Design concepts):&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/ddd-pattern-language.png" class="img-fluid" alt="ddd-pattern-language" /&gt;&lt;/p&gt;
&lt;p&gt;Isolating individual concepts, naming them, and detailing how they relate allows each to be thought about independently.  We can focus on parts of &amp;quot;Domain-Driven Design&amp;quot; because a Context Map details that isolation.&lt;/p&gt;
&lt;p&gt;I'll dig deeper into the Aggregate and Service patterns in this part two. Aggregate and Service enable and embody major domain concepts.&lt;/p&gt;
&lt;p&gt;An aggregate is the realization of a logical consistency boundary and the operations contributing to that consistency. An aggregate is a composition of several domain objects: At least one entity object and usually several value objects. Each domain object maintains its own consistency (it has invariants.) A date is a composition of a day, month, and year, but February 31, 1981 is not a valid date.  We differentiate an aggregate from any grouping of domain objects because of the invariants and rules beyond that of simply a collection of consistent domain objects. An aggregate models that cross-object consistency requirement.&lt;/p&gt;
&lt;p&gt;Aggregates map to major domain concepts and significant domain behavior associated with a particular domain object (the root). The root is the object of behavior and acts as a gateway to the other objects the aggregate comprises. The root takes on the responsibility of maintaining the consistency of the entire aggregate. The complexity of that composition and the consistency are separated from complexities outside the natural boundary of the aggregate.&lt;/p&gt;
&lt;p&gt;An aggregate is not a design choice; it is a natural role that a major domain entity plays in the domain that requires recognition in a domain model. Some domain entities naturally take on certain behavior that affects other domain objects. All the behavior must happen in certain ways and have expectedly consistent results. Those consistent results (or state) abide by rules and invariants--it's consistent &lt;em&gt;because&lt;/em&gt;... With a loan application, for example, there's no such thing as having negative assets (particularly: it's not a consistent loan application when it contains assets with negative value.) If you &lt;em&gt;owe&lt;/em&gt; money, that's a liability.&lt;/p&gt;
&lt;p&gt;When understanding and modeling a domain, I like to accurately map behavior to domain concepts that logically have that (or any) behavior. Sometimes it's easy to mis-associate behavior with static concepts when those are the major concepts in the domain. A loan, for example, is a major concept in many financial domains, but it does not exhibit behavior; it's static. A loan is the subject of many behaviors in a financial domain but is just a contract (or a specification.) We know we have complexity to deal with. Mis-associating behavior reduces clarity, making things needlessly more complex.&lt;/p&gt;
&lt;p&gt;Starting out understanding a domain, I find focusing primarily on behavior and activities useful. Everything else in a domain is ultimately the subject of a behavior or activity, so I don't model them explicitly. For example, the role of underwriter &lt;em&gt;approves&lt;/em&gt; a loan application. A loan application can be approved when the following rules are satisfied: a) the Debt-To-Income Ratio is below 43%, and b) etc... Debt-To-Income Ratio is modeled as an attribute of a loan application and covered in the activity of Approving a Loan. Information that isn't the object of a behavior also adds needless complexity.&lt;/p&gt;
&lt;p&gt;When certain logic doesn't require a single object or doesn't require a &lt;em&gt;particular state&lt;/em&gt; and requires &lt;em&gt;particular objects&lt;/em&gt;, it might not be accurate to model the logic as part of an &lt;em&gt;aggregate&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;A Service is the realization of a collaboration between several objects. The concept of that service exists because it is not the natural behavior of a domain &lt;em&gt;entity&lt;/em&gt;. A Domain Service is the realization of a collaboration between one or more domain entities. It involves business logic and or business rules that may affect the state of those domain entities. An application service is the realization of a collaboration between one or more domain services, domain objects, and an infrastructure service. And an infrastructure service is a collaboration with a framework or the &amp;quot;outside.&amp;quot;  The Service pattern recognizes complexity by isolating logic that is otherwise unrelated.&lt;/p&gt;
&lt;p&gt;Look again at the Domain-Driven Design pattern language. If we always had to deal with all the complexities detailed in that diagram, it would be much harder to get things done promptly. The fact that the concepts are delineated and we can deal with them in isolation simplifies working with them. Separating interaction-only logic into a separate service from the object behavior affecting their state means we can think about and work with those concepts in isolation. Those concepts are now more loosely-coupled, and we obtain the benefits of loose coupling.&lt;/p&gt;
&lt;p&gt;These definitions are easy enough to understand but can be confusing when it comes time to put them into practice. Sometimes the confusion stems from a backward approach to implementing software systems. Teams work backward from patterns when looking for the opportunity to use patterns. It's more successful in understanding the domain and then matching domain concepts to patterns and practices. For example, I've seen people approach a domain with questions like &amp;quot;What are all the entities?&amp;quot; or &amp;quot;What are all the services?&amp;quot;  While we might be able to answer those questions after we've understood the domain and started to design solutions, approaching it from that perspective at that stage of understanding can pervert the interpretation of the domain. Services can be hard to recognize and implement when the domain concepts are not yet clearly isolated.&lt;/p&gt;
&lt;p&gt;Sometimes it can be easy to delineate interaction logic in a collaboration from the business logic; often, it is not. In a financial domain, &lt;em&gt;transferring funds&lt;/em&gt; as a capability can be easily viewed as the behavior of an account, for example. It involves accounts, obviously, so why would it not be an &lt;em&gt;account behavior&lt;/em&gt;? But what happens when transferring funds? The situation's complexity comes from the fact that more than one account is involved, and the consistency of each account needs to be managed independently of the other(s).  A funds transfer succeeds or fails, but has no state of its own--any change in state is encapsulated in the objects participating in the collaboration.&lt;/p&gt;
&lt;p&gt;A clear understanding of the domain concepts is vital to project the isolation of those concepts into design elements more accurately. Modeling domain knowledge requires the delineation and understanding of the concepts as well as correctly associating all the behavior and attributes of those concepts. Maintaining this model is a process of managing complexity, but it only happens in stages. Managing these complexities is an ongoing and iterative process. The more complex a domain is, knowledge fragmentation amongst domain experts is more likely. It's highly unlikely that a single person completely understands the domain. This knowledge fragmentation is one reason we model the domain iteratively, recognizing that understanding evolves over time.&lt;/p&gt;
&lt;p&gt;The Aggregate and Service patterns model parts of the domain similarly but provide a means to recognize separate parts of the domain: independent of the level at which they apply as well as how they affect state.  Service operates at a higher level to model an activity, a collaboration of objects.  An aggregate is the composition of several domain objects that must abide by the same invariants and be consistent in the presence of each other.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;In part one, I talked about the complexity in the language used to communicate the domain. Domain-Driven Design (DDD) deals with that complexity by isolating the concepts in a clear language that domain experts understand. Ubiquitous Language helps form the basis of all the other patterns and practices in Domain-Driven Design through the clear isolation of domain &lt;em&gt;concepts&lt;/em&gt;. The DDD pattern language context map provides a good example of isolating concepts (in this case, Domain-Driven Design concepts):&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/Being-Successful-With-Domain-Driven-Design--Minimal-Complexity-Part-1</id>
		<title>Being Successful With Domain-Driven Design: Minimal Complexity, Part 1</title>
		<link href="http://blog.peterritchie.com/posts/Being-Successful-With-Domain-Driven-Design--Minimal-Complexity-Part-1" />
		<updated>2023-05-19T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="/assets/concepts-contexts-and-boundaries.jpg" class="img-fluid" alt="Concepts, Context, and Boundaries. Abstract Thought" /&gt;
The Domain-Driven Design book (the &amp;quot;Blue Book&amp;quot;) includes &amp;quot;Tackling complexity at the heart of software&amp;quot; in the title. While &amp;quot;complexity&amp;quot; can be subjective, the takeaway is that Domain-Driven Design intends to address complex software systems. The principles and practices in Domain-Driven Design have their complexities, so for Domain-Driven Design to add value, it needs to address existing/expected complexity and attempt to be net-positive for simplicity.&lt;/p&gt;
&lt;p&gt;Interestingly, the title of the Blue Book alludes to questions about &lt;em&gt;what&lt;/em&gt; complexity is at the heart of software. Subjectively subjective, but we can look to the intent of some of the patterns and practices to deduce some types of complexity that Domain-Driven Design adequately addresses in the design of software systems.&lt;/p&gt;
&lt;p&gt;For this series, I'll tranche away some of the patterns as essential complexity (essential complexity of &lt;em&gt;both&lt;/em&gt; Domain-Driven design and the design of almost all software design):  Entities, Value Objects, Modules, Layered Architecture, Factories, and Repositories. Any modular software system must deal with identity, value, creation, and storage. There's nothing new about layered architecture, but Domain-Driven Design does detail the isolation of specific responsibilities (like Domain and Infrastructure) that I'll cover. Practices like Side-Effect Free Functions, Standalone Classes, Intention-Revealing Interfaces, Continuous Integration, Assertions, and Declarative Style are aspects of long-championed techniques like cohesion, loose-coupling, naming standards, or functional programming (in my opinion).&lt;/p&gt;
&lt;p&gt;None of what I've tranched off are unimportant, but they have been tried and true before Domain-Driven Design, and I want to focus on added value in Domain-Driven Design. To that end, I'll focus on Ubiquitous Language, Bounded Context, Context Map, Aggregates, Services, Domain Layer, Generic Subdomains, Segregated Core, Anti-Corruption Layer, and Core Domain; and touch on Evolving Order.&lt;/p&gt;
&lt;h3 id="clean-concepts-contexts-and-boundaries"&gt;Clean Concepts, Contexts, and Boundaries&lt;/h3&gt;
&lt;p&gt;If I had to distill the intent of Domain-Driven Design to a single statement, it might be &amp;quot;be explicit.&amp;quot;  Or, more explicitly: &amp;quot;Be explicit with boundaries.&amp;quot;  Software systems are not the only source (or victim) of complexity. There's a whole science devoted to it: Complex Adaptive Systems. Not to oversimplify Complex Adaptive Systems, but systems with sufficient complexity are inherently unpredictable and exhibit &lt;em&gt;emergent behavior&lt;/em&gt;, among other things. Meaning that complex systems will do what they're going to do, and we can only sometimes predict what they will do. Sometimes that emergent behavior is beneficial; sometimes, it isn't. To make systems more predictable (and get the benefits that provides), we have to reduce complexity. The complexity of complex systems arises from the number of dependencies, relationships, and interactions. Each unbounded interconnection increases complexity exponentially.&lt;/p&gt;
&lt;p&gt;Complex adaptive systems theory is why explicit boundaries are a major aspect of how Domain-Driven Design combats complexity in software to produce more reliable and robust systems. Explicitness is important here; we're not looking for any-old boundaries. We're looking to constrain and isolate areas of the system based on purpose, meaning, and intent. We could chalk this up as simply an exercise in cohesion, but Domain-Driven Design focuses on getting to and clarifying that purpose, meaning, and intent.&lt;/p&gt;
&lt;p&gt;Explicitness starts with unambiguous concepts, descriptions, and terms. If people aren't communicating the same concept things aren't going to get simpler. I speak about &lt;em&gt;Naming Things&lt;/em&gt;, and part of what makes that difficult, I've decided, is language (or English). Stemming from human nature, we try to classify an ever-increasing set of concepts with a finite set of words, syntax, and semantics. The first step to explicit boundaries is the agreement on what they are: agreement on the concepts and to which explicit context they apply—the Ubiquitous Language.&lt;/p&gt;
&lt;p&gt;The value of Ubiquitous Language isn't just that there is an agreed-upon vocabulary. The added value to a Ubiquitous Language is what it accounts for. The Ubiquitous Language recognizes classifications of concepts, classifications common to most software systems. Classifications that the Ubiquitous Language fosters and isolates: individuals, invariants and consistency rules, operations, processes, collaborations, commands, events, views, and values/properties. By &amp;quot;individuals,&amp;quot; I don't just mean people, but anything that exhibits individuality (aka &amp;quot;entity.&amp;quot;)&lt;/p&gt;
&lt;p&gt;Imagine an amorphous &amp;quot;loan&amp;quot; concept in the financial industry. People apply for loans, obtain loans, and pay back loans. Getting a loan involves evaluating personal information (credit rating, assets, liabilities, etc.). Paying back a loan consists of a term, an interest rate, a payment schedule, etc. Credit rating, assets, liabilities, term, interest rate, and payment schedule are six interconnected concepts. With six concepts (with each having five interconnections to the others), there are 30 interconnections. Or 30 complexity points. But, if we think of these six concepts as two different semi-independent contexts: &amp;quot;loan application&amp;quot; and &amp;quot;loan servicing,&amp;quot; we end up with two contexts (and one interconnection) with three concepts (or three interconnections) totaling six interconnections. We've gone from 30 complexity points to 6 simply by defining the actual contexts better. In other words, we're being more explicit.&lt;/p&gt;
&lt;p&gt;Explicitness like this--delineating elements of a set into two groups connected by a specific relationship--is creating a boundary between two contexts. This is a very simple example of Bounded Context. As the name implies, Bounded Context is an explicit contextual boundary: where one context ends and another begins. This is a domain's macro level, recognizing that Loan Servicing can only happen after Loan Application is successful. This particular boundary is based on a temporal or procedural boundary. Phases or steps are a good way of organizing domains into bounded contexts.&lt;/p&gt;
&lt;p&gt;In these two contexts, the word &amp;quot;loan&amp;quot; exists in both. The word &amp;quot;loan&amp;quot; is used in the application context as well as in the servicing context. But, in the application context, the meaning is really &amp;quot;loan application,&amp;quot; and in the servicing context, it really means &amp;quot;serviced loan&amp;quot;. Understanding that servicing depends on an approval event in a loan application phase (or activity) allows us to realize an explicit boundary. Sometimes it's as easy as this, but often it's not. There are other ways of teasing out boundaries (or contexts), almost always involving vocabulary elements.&lt;/p&gt;
&lt;p&gt;Sometimes you've got overloaded terms like &amp;quot;loan&amp;quot;; sometimes, you have different terms like different &lt;em&gt;rules&lt;/em&gt;. Different rules are typically applied in different scenarios or involve different parameters. Different rules offer a window into recognizing different contexts with a boundary in-between. You may recognize concepts like this (events, operations, rules/invariants) from the larger list I mentioned above. A Ubiquitous Language can also account for individuals and entities, commands (often related to an activity), views (reports, screens, results), collaborations, and attributes or properties attributed to individuals and entities. Additionally, attributes or properties can be involved in criteria, and categories or subtypes may group individuals and entities.&lt;/p&gt;
&lt;p&gt;Working towards a Ubiquitous Language is working towards concepts more independent from each other. Independent concepts are themselves individual contexts. Any defined concept has a defined context with understandable boundaries. Keeping the complexity of one context bound from others keeps the essential complexity within that context and reduces the accidental complexity that arises from blended contexts.&lt;/p&gt;
&lt;p&gt;Domain-Driven Design adds value when you have a minimal complexity, when a subject matter has multiple terms per classification. Terms can be classified as entities, processes, phases, events, rules, views, etc. The focus of this post was a level of complexity where boundaries are recognizable in the nuances of the vocabulary. In future posts, I'll dig deeper into different the subject matter (or domain) classifications, how you can isolate the complexities of each, and the parts of Domain-Driven Design that apply.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="/assets/concepts-contexts-and-boundaries.jpg" class="img-fluid" alt="Concepts, Context, and Boundaries. Abstract Thought"&gt;
The Domain-Driven Design book (the "Blue Book") includes "Tackling complexity at the heart of software" in the title. While "complexity" can be subjective, the takeaway is that Domain-Driven Design intends to address complex software systems. The principles and practices in Domain-Driven Design have their complexities, so for Domain-Driven Design to add value, it needs to address existing/expected complexity and attempt to be net-positive for simplicity.&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/installing-dotnet-framework-4-5-targeting-pack</id>
		<title>Installing .NET Framework 4.5 Targeting Pack</title>
		<link href="http://blog.peterritchie.com/posts/installing-dotnet-framework-4-5-targeting-pack" />
		<updated>2023-02-05T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="/assets/DALL%C2%B7E-2023-02-05-13.14.52--ludites-frustration-with-errors-in-integrated-development-environments-(IDE)-pencil-and-watercolor.png" class="img-fluid" alt="When working in an IDE seems like working with crayons" /&gt;&lt;/p&gt;
&lt;p&gt;Something came up with a client around Live Dependency Validation in Visual Studio recently.  Digging into it I ran into several issues, one of which was the error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Severity	Code	Description	Project	File	Line	Suppression State
Error		The reference assemblies for .NETFramework,Version=v4.5 were not found. To resolve this, install the Developer Pack (SDK/Targeting Pack) for this framework version or retarget your application. You can download .NET Framework Developer Packs at https://aka.ms/msbuild/developerpacks	DependencyValidation	C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin\amd64\Microsoft.Common.CurrentVersion.targets	1229	
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;.NET Framework 4.5 has been out of support since 2016, so its targetting pack isn't available for download.  I found a couple blogs posts about editing the modelproj file to add things like &lt;code&gt;ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch&lt;/code&gt; or a &lt;code&gt;PackageReference&lt;/code&gt; to &lt;code&gt;microsoft.netframework.referenceassemblies.net45&lt;/code&gt; but neither worked.&lt;/p&gt;
&lt;p&gt;One of the features of Visual Studio Installers is that they can be a one-stop-shop for all the things you're going to need to develop software (with or without Visual Studio).  One of these features is to install .NET targeting packs!  Although the latest version of Visual Studio doesn't include out-of-support components, prior versions of Visual Studio are available.  Visual Studio 2019 came out before .NET Framework 4.5 was completely unsupported (i.e. still had the option of paid support) so it offers the ability to install some targetting packs that are currently out of support.&lt;/p&gt;
&lt;p&gt;You can download older versions of Visual Studio via &lt;a href="https://bit.ly/vs-old"&gt;https://visualstudio.microsoft.com/vs/older-downloads/&lt;/a&gt;, which seems to redirect you eventually to Visual Studio Subscriptions downloads.  For our purposes, Visual Studio Community Editions works fine.&lt;/p&gt;
&lt;p&gt;To install, run the Visual Studio installer that you've downloaded (if you already have 2019 installed, run the already installed Visual Studio Installer and click &lt;strong&gt;Modify&lt;/strong&gt;) then click &lt;strong&gt;Continue&lt;/strong&gt; to go past the &lt;em&gt;set up a view things&lt;/em&gt; dialog. (if you have VS 2022 installed, this seems to do nothing.)&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Make sure you don't change any of the &lt;em&gt;workloads&lt;/em&gt; (if you have Visual Studio 2019 install already, some may be checked--don't uncheck them, that will uninstall them).&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src="/assets/vs2019-installer-45-targetting-pack.png" class="img-fluid" alt="Visual Studio Installer" /&gt;&lt;/p&gt;
&lt;p&gt;Click on the &lt;strong&gt;Individual Components&lt;/strong&gt; tab at the top (to the right of &lt;em&gt;Workloads&lt;/em&gt; and to the left of &lt;em&gt;Language packs&lt;/em&gt;.)  In the .NET section, find an check &lt;strong&gt;.NET Framework 4.5 targetting pack&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Click &lt;strong&gt;Install&lt;/strong&gt; or &lt;strong&gt;Install while downloading&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Once completed, you now have the .NET Framework 4.5 targetting pack.  If you're doing this in response to a .NET Framework 4.5 targetting pack error message in Visual Studio, exit and re-start Visual Studio--the error should go away (it does with the modelproj error.)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Incidentally, the other issues I encountered are:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Full solution analysis for C# is currently disabled. You may not be seeing all possible dependency validation issues in C# projects. Options... Don't show again 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;... with no way to enable full solution analysis in a way that this notice recognizes and goes away.&lt;/p&gt;
&lt;p&gt;I'd appreciate any advice to resolve that that doesn't involve clicking &lt;strong&gt;Don't show again&lt;/strong&gt;.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="/assets/DALL%C2%B7E-2023-02-05-13.14.52--ludites-frustration-with-errors-in-integrated-development-environments-(IDE)-pencil-and-watercolor.png" class="img-fluid" alt="When working in an IDE seems like working with crayons"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/things-i-learned-attempting-azure-administrator-associate-part-2</id>
		<title>Things I Learned Attempting Azure Administrator Associate - Part 2 - Storage</title>
		<link href="http://blog.peterritchie.com/posts/things-i-learned-attempting-azure-administrator-associate-part-2" />
		<updated>2022-12-22T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="/assets/DALL%C2%B7E-2022-12-22-17.03.40--distributed-cloud-data-storage-in-the-style-of-salvator-dali.png" class="img-fluid" alt="distributed cloud data storage" /&gt;&lt;/p&gt;
&lt;p&gt;Azure Administrator Associate certification is about the skills required to be an Azure account, subscription, tenant, etc., administrator. If your end goal is to develop applications on Azure, that involves a lot of &lt;em&gt;administration&lt;/em&gt; of Azure resources. Regardless of your plan, storage administration is nuanced. This post focuses on some of those nuances, nuances that may not be apparent in the documentation.&lt;/p&gt;
&lt;h3 id="overview"&gt;Overview&lt;/h3&gt;
&lt;!--capabilities--&gt;
&lt;p&gt;Azure provides storage services for Files, Blobs, Queues, and Tables. Files are blobs that support access via SMB protocol, AKA File Shares. Blobs are web resources that support access via a URI (HTTP). Blob Storage supports two types of blobs: block blobs and page blobs. Table Storage supports key-based relational and document access. Queues support access to ephemeral messages.&lt;/p&gt;
&lt;p&gt;Azure Files has a File Sync feature that supports file-level replication across Windows Servers. The Azure File endpoint is also called the Cloud Endpoint and is part of a Sync Group that includes one or more Windows Server file shares.&lt;/p&gt;
&lt;p&gt;There are two performance options for Storage Accounts: Standard (general purpose v2) and Premium (for low latency.)&lt;/p&gt;
&lt;!--tiers/skus--&gt;
&lt;p&gt;Storage has a couple of storage tiers: Standard and Premium. Storage tiers provide different functionality at different costs. Blob Storage has several access tiers: Hot, Cool, and Archive. Access tiers offer a way to communicate the frequency and type of data access to reduce storage costs. Access tiers can be used to implement a lifecycle for data, moving to lower-cost tiers over time to reduce cost.&lt;/p&gt;
&lt;!--durability/high-availability--&gt;
&lt;p&gt;Storage supports data redundancy that makes copies of data to avoid loss due to infrastructure failure. There are several options: Locally-Redundant Storage (LRS), Zone-Redundant storage (ZRS), Geo-Redundant Storage (GRS), and Geo-Zone-Redundant Storage (GZRS). LRS stores three copies of the data asynchronously within a single data center. ZRS duplicates those 3 LRS copies across three availability zones (clusters) in a region. GRS duplicates those 3 LRS asynchronously to a single zone in a secondary region. GZRS duplicates the ZRS data across zones within the secondary region.&lt;/p&gt;
&lt;!--data protection--&gt;
&lt;p&gt;Recovery Services is the service responsible for storing backups and recovery points. Recovery Services stores data within Recovery Services Vaults.&lt;/p&gt;
&lt;p&gt;Encryption scopes logically group blobs or containers and assign an encryption key specific to that scope.&lt;/p&gt;
&lt;!--access control--&gt;
&lt;p&gt;There are a couple options for controlling access to data: Azure AD accounts/groups or Shared Access Signatures (SAS). Azure AD Groups provide a more manageable way to control Azure AD account access to data (than simply Azure AD accounts). SAS provides a granular means to provide delegate access to external entities.&lt;/p&gt;
&lt;h3 id="notable-information"&gt;Notable information &lt;!--TIL--&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;LRS protects against rack-level hardware failure (so, if you want data-center-wide failure protection, LRS is insufficient).&lt;/li&gt;
&lt;li&gt;LRS is supported for Standard File and Standard Block Blob account types (otherwise, GRS is the default.)&lt;/li&gt;
&lt;li&gt;ZRS protects against data loss due to data center failure (so, if you want region-wide failure protection, ZRS is insufficient)&lt;/li&gt;
&lt;li&gt;GRS protects against region failure.&lt;/li&gt;
&lt;li&gt;GRS and GZRS secondary regions are pre-defined, forcing your data into a specific region.&lt;/li&gt;
&lt;li&gt;GZRS protects against region failure and simultaneous data center failure in the secondary region.&lt;/li&gt;
&lt;li&gt;When defining a data lifecycle, in the case of a tie, the option that results in the least cost will be chosen.&lt;/li&gt;
&lt;li&gt;Migrating from LRS to GRS is supported with a feature called &amp;quot;Live Migration.&amp;quot; Migration from LRS in other scenarios (e.g. to ZRS) must be done manually. Since Premium Storage accounts do not support LRS, Live Migration does not support Premium Storage accounts.&lt;/li&gt;
&lt;li&gt;Live migration supports the use case of a storage account failure of GRS-replicated data. GRS is a second LRS in a secondary region. If a region fails, GRS reduces to LRS, so recovering means using Live Migration.&lt;/li&gt;
&lt;li&gt;Durability is not backup; it provides access to data when infrastructure recoverability isn't an option. Apart from Live Migration, &lt;em&gt;restoration&lt;/em&gt; is limited to manually copying live data when needed.&lt;/li&gt;
&lt;li&gt;Durability does not protect against application-level failure; use backups or custom (application-level) durability in those scenarios.&lt;/li&gt;
&lt;li&gt;Encryption scopes are useful for providing logical data tenancy.&lt;/li&gt;
&lt;li&gt;Files added/modified in a File Share are only detected and replicated to the Windows Server file shares once every 24 hours (i.e., only visible after 24 hours).&lt;/li&gt;
&lt;li&gt;Adding a file share to a Sync Group acts like all the files and folders within the file share were just added, replicating to the cloud endpoint and any other file shares.&lt;/li&gt;
&lt;li&gt;When applying &lt;em&gt;least privilege&lt;/em&gt; to storage accounts, the &lt;strong&gt;Reader&lt;/strong&gt; role is also required on the Azure AD account if the Azure AD account needs to navigate storage resources in the Azure Portal.&lt;/li&gt;
&lt;li&gt;Asynchronous data redundancy options introduce the possibility of data loss. If the asynchronous duplication to the secondary region did not complete, it is out of sync with the last state of the primary region. Application-level logic is required to prevent loss of data in this scenario.&lt;/li&gt;
&lt;li&gt;The Archive tier does not have immediate access; it must be &lt;em&gt;rehydrated&lt;/em&gt; to a cool/hot tier first (usually with a Copy Blob operation of up to 15 hours completion time).&lt;/li&gt;
&lt;li&gt;File Share storage may be backed up to Recover Service vaults, but Blob Storage may not.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This table summarizes the types of storage accounts and the features/redundancy that each support.&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Account&lt;/th&gt;
&lt;th&gt;Redundancy&lt;/th&gt;
&lt;th style="text-align: center;"&gt;block blob&lt;/th&gt;
&lt;th style="text-align: center;"&gt;page blob&lt;/th&gt;
&lt;th style="text-align: center;"&gt;append blob&lt;/th&gt;
&lt;th style="text-align: center;"&gt;file share&lt;/th&gt;
&lt;th style="text-align: center;"&gt;queue&lt;/th&gt;
&lt;th style="text-align: center;"&gt;table&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Standard account&lt;/td&gt;
&lt;td&gt;LRS&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Standard account&lt;/td&gt;
&lt;td&gt;GRS&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Standard account&lt;/td&gt;
&lt;td&gt;GAZRS&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Standard account&lt;/td&gt;
&lt;td&gt;RA-GZRS&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Premium Block blobs account&lt;/td&gt;
&lt;td&gt;LRS&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Premium Block blobs account&lt;/td&gt;
&lt;td&gt;ZRS&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Premium File shares account&lt;/td&gt;
&lt;td&gt;LRS&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Premium File shares account&lt;/td&gt;
&lt;td&gt;ZRS&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Premium Page blobs account&lt;/td&gt;
&lt;td&gt;LRS&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Premium Page blobs account&lt;/td&gt;
&lt;td&gt;ZRS&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☑&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;td style="text-align: center;"&gt;☐&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="/assets/DALL%C2%B7E-2022-12-22-17.03.40--distributed-cloud-data-storage-in-the-style-of-salvator-dali.png" class="img-fluid" alt="distributed cloud data storage"&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<id>http://blog.peterritchie.com/posts/things-i-learned-attempting-azure-administrator-associate</id>
		<title>Things I Learned Attempting Azure Administrator Associate - Part 1</title>
		<link href="http://blog.peterritchie.com/posts/things-i-learned-attempting-azure-administrator-associate" />
		<updated>2022-12-20T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;img src="/assets/DALL%C2%B7E-2022-12-20-15.03.33---A-woman-going-through-the-process-of-certifying-knowledge.png" class="img-fluid" alt="person going through the process of certifying knowledge" /&gt;&lt;/p&gt;
&lt;p&gt;I recently earned certification for Azure Administrator Associate.  My goal is to make my experience and skills more verifiable in areas like application solution architecture.  Azure Administrator Associate is a prerequisite for Azure Solutions Architect Expert and DevOps Engineer Expert (I imagine it's a prerequisite for all Azure * {Expert|Associate} certs.)&lt;/p&gt;
&lt;p&gt;Certifications aren't perfect, &amp;quot;certification&amp;quot; has different meanings to the observer and the certification itself. Most certifications bring with them an expected minimum understanding of the subject.  Does it mean the earner will do everything perfectly with the subject?  Of course not, but it gives the person a certain vocabulary to communicate more efficiently on the subject.&lt;/p&gt;
&lt;p&gt;The road to Azure Administrator Associate was interesting, and sharing some notable information would be helpful for others.&lt;/p&gt;
&lt;h2 id="making-the-implicit-explicit"&gt;Making The Implicit Explicit&lt;/h2&gt;
&lt;p&gt;The key to good communication is clearly understanding a subject and eliminating assumptions and misunderstandings. While understanding what is expected of a certified Azure Administrator Associate, I noticed some knowledge that I realized is typically implicit. Another way of looking at the following is that each starts with &amp;quot;It may seem obvious, but...&amp;quot;.&lt;/p&gt;
&lt;p&gt;Implicit knowledge is knowledge obtained through incidental activities; knowledge gained without awareness of learning is occurring.&lt;/p&gt;
&lt;h3 id="line-of-business-lob-applications"&gt;Line of Business (LoB) Applications&lt;/h3&gt;
&lt;p&gt;Line of Business (LoB) applications is ubiquitous in the computing industry.  Everyone knows what it &lt;em&gt;means&lt;/em&gt;, but if you ask two people to define it, you'll get more than one answer.  While agreement/standardization on what a LoB application is isn't going to happen any time soon, there are certain truths about LoB applications:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An in-house, custom web application&lt;/li&gt;
&lt;li&gt;Not accessible via the Internet, either behind a firewall or strict access control (authentication and authorization)&lt;/li&gt;
&lt;li&gt;Access &lt;em&gt;may&lt;/em&gt; occur via an application gateway or load balancer&lt;/li&gt;
&lt;li&gt;Specific to the company, business area, or industry&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="azcopy"&gt;AzCopy&lt;/h3&gt;
&lt;p&gt;AzCopy works with Azure storage but only Azure Blob Storage and Azure Files.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;There are many areas of clarification with Azure Administrator Associate.  Future posts on the subject will address clarifications involving important explicit limits, restrictions, constraints, rules, etc.&lt;/p&gt;
&lt;p&gt;Are there other implicit aspects of Azure administration that can be made explicit?&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;img src="/assets/DALL%C2%B7E-2022-12-20-15.03.33---A-woman-going-through-the-process-of-certifying-knowledge.png" class="img-fluid" alt="person going through the process of certifying knowledge"&gt;&lt;/p&gt;</summary>
	</entry>
</feed>