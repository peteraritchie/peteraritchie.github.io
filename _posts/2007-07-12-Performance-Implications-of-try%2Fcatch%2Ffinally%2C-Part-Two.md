---
layout: post
title: Performance Implications of try/catch/finally, Part Two
date: 2007-07-11 20:00:00 -0400
categories: ['.NET 2.0', '.NET Development', 'C#', 'Design/Coding Guidance']
tags:
- msmvps
---
[Source](http://blogs.msmvps.com/peterritchie/2007/07/12/performance-implications-of-try-catch-finally-part-two/ "Permalink to Performance Implications of try/catch/finally, Part Two")

# Performance Implications of try/catch/finally, Part Two

In a previous blog entry [Performance Implications of try/catch/finally][1] I outlined that the conventional wisdom that there are no performance implications to try blocks unless an exception is thrown is false.  I have some clarifications and details to add.

My original tests used academic sample code like this:

  

        public int Method( )

        {

            int i = 10;

            try

            {

                i = 20;

                i = 30;

                Thread.Sleep(i);

            }

            finally

            {

                Thread.Sleep(i);

            }

            return i;

        }

As written, the optimized instructions generated by the JIT (Just-In-Time compiler) was showing that no optimizations were occurring in the try block in that the only obvious optimization–the assignment of _20_ to _i–_wasn't optimized away.

But, I've loaded-the-deck, so to speak.  Let's consider what exception handling needs to be able to do.  In this case, I've explicitly said I need to do something in the event of an exception in the block of code I've wrapped with try{}.  The JIT takes me at my word and assumes every line in that block could throw an exception.  In order for the finally block to get accurate values for the current state–in the event of that exception–it can't optimize any variables that are used in or past the finally block. In this case _10_ must first be assigned to _i_, then _20_ must be assigned to _i_ then _30_ must be assigned to _i_ in the sequence specified in the source code; because if those assignments threw an exception, the finally block would need one of the values: _10_, _20_, or _30_.

As you might be able to tell, I've loaded-the-deck because I don't have much outside the try block and everything in the try block is used outside of it as well.  I haven't given the JIT much to work with.  So, the "no optimizations are performed in try blocks" isn't entirely accurate.  Obviously, in this case, the assignment of _10_ to _i_ wasn't optimized as well.  But, the JIT _is_ smart enough to attempt to optimize within the try block.  If we change the sample slightly to this:

  

        public int Method( )

        {

            int i = 10;

            try

            {

  

**                int c = 2;**

**                c = 3;**

                i = 20;

                i = 30;

**                Thread.Sleep(c);**

            }

            finally

            {

                Thread.Sleep(i);

            }

            return i;

        }

…the JIT knows that _c_ is not used outside the try block and proceeds to optimize it away and converts the Sleep statement into _Sleep(3)_.  Essentially it's if I had written:

  

        public int Method( )

        {

            int i = 10;

            try

            {

                i = 20;

                i = 30;

                Thread.Sleep(3);

            }

            finally

            {

                Thread.Sleep(i);

            }

            return i;

        }

 

Okay, things aren't that dire; at least the JIT is doing what it can within the try block.  But what about outside the try block; how drastic are the lack of optimizations there?  Again, the JIT is smart enough to do what it can. If we change our original sample slightly again:

 

  

        public int Method( )

        {

            int i = 10;

**            int b = 9;**

**            b = 7;**

            try

            {

                i = 20;

                i = 30;

                Thread.Sleep(i);

            }

            finally

            {

                Thread.Sleep(i);

            }

**            return b;**

        }

We see that the JIT is smart enough to attempt to optimize what's outside the try block, and essentially results in this:

  

        public int Method( )

        {

            int i = 10;

            int b = 7;

            try

            {

                i = 20;

                i = 30;

                Thread.Sleep(i);

            }

            finally

            {

                Thread.Sleep(i);

            }

            return b;

        }

Better, it's coalesced the writes (_7_ and _9_) to b into a single write (_7_); but for some reason it still forces the assignment of _7_ to _b_ before the try block.  There's nothing that could see _b_ until the return, so it should be able to optimize it a bit further to this:

  

        public int Method( )

        {

            int i = 10;

            try

            {

                i = 20;

                i = 30;

                Thread.Sleep(i);

            }

            finally

            {

                Thread.Sleep(i);

            }

            return 7;

        }

So, while my previous statement wasn't entirely accurate, I think what the JIT can optimize is neither better nor worse than "no optimizations are performed in try blocks", just different. You should still pay close attention to what you're doing in and around try blocks.

Also, an apples-to-oranges comparison; but methods with try/catch/finally blocks won't be inlined.

Having described what the JIT appears to be doing, and the implication that optimizations to variables used before and after will result in only coalesce-ations prior to the try block (i.e. we've observed that it won't optimize away a variable declared before a try block that is not used within the try or the finally); you should not rely on those side-effects.  As far a I'm concerned the JIT is free to perform that last optimization I described, and probably many others.

[1]: http://msmvps.com/blogs/peterritchie/archive/2007/06/22/performance-implications-of-try-catch-finally.aspx

