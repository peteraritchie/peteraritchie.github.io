

<!DOCTYPE HTML>
<!--
	Solid State by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Peter Ritchie&#x27;s Blog - &#x201C;Virtual method call from constructor&#x201D; What Could Go Wrong?</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<!--[if lte IE 8]><script src="/assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="/assets/sass/main.css" />
		<!--[if lte IE 9]><link rel="stylesheet" href="/assets/sass/ie9.css" /><![endif]-->
		<!--[if lte IE 8]><link rel="stylesheet" href="/assets/sass/ie8.css" /><![endif]-->
        

	</head>
	<body>

		<!-- Page Wrapper -->
			<div id="page-wrapper">
				
				<!-- Header -->
				<header id="header">
					<h1><a href="/">Peter Ritchie&#x27;s Blog</a></h1>
					<nav>
						<a href="#menu">Menu</a>
					</nav>
				</header>

				<!-- Menu -->
				<nav id="menu">
					<div class="inner">
						<h2>Menu</h2>
						<ul class="links">
							        <li><a href="/posts">Archive</a></li>
        <li><a href="/tags">Tags</a></li>
        <li><a href="/about">About</a></li>

						</ul>
						<a href="#" class="close">Close</a>
					</div>
				</nav>


    
<section id="banner">
  <div class="inner">
    <h2>&#x201C;Virtual method call from constructor&#x201D; What Could Go Wrong?</h2>
            <p><em>Published on Wednesday, April 25, 2012</em></p>
                    <a role="button" href="/tags/NET-Development" class="button small">.NET Development</a>
                <a role="button" href="/tags/April-2012" class="button small">April 2012</a>
                <a role="button" href="/tags/C%23" class="button small">C#</a>
                <a role="button" href="/tags/Code-Analysis/FxCop-Warning-Resolutions" class="button small">Code Analysis/FxCop Warning Resolutions</a>
                <a role="button" href="/tags/DevCenterPost" class="button small">DevCenterPost</a>
                <a role="button" href="/tags/msmvps" class="button small">msmvps</a>
                <a role="button" href="/tags/Software-Development" class="button small">Software Development</a>
                <a role="button" href="/tags/Software-Development-Guidance" class="button small">Software Development Guidance</a>
                <a role="button" href="/tags/Visual-Studio" class="button small">Visual Studio</a>
  </div>
</section>

				<!-- Main -->
				<section id="wrapper">
					<section class="wrapper style2">
						<div class="inner">
							

<p><a href="http://blogs.msmvps.com/peterritchie/2012/04/25/virtual-method-call-from-constructor-what-could-go-wrong/" title="Permalink to “Virtual method call from constructor” What Could Go Wrong?">Source</a></p>
<h1 id="virtual-method-call-from-constructor-what-could-go-wrong">“Virtual method call from constructor” What Could Go Wrong?</h1>
<p>If you've used any sort of static analysis on source code you may have seen a message like &quot;Virtual method call from constructor&quot;. In FxCop/Visual-Studio-Code-Analysis it's CA2214 &quot;Do not call overridable methods in constructors&quot;. It's &quot;syntactically correct&quot;; some devs have said &quot;what could go wrong with that&quot;. I've seen this problem in so many places, I'm compelled to write this post.</p>
<p>I won't get into one of my many pet peeves about ignoring messages like that and not educating yourself about ticking time bombs and continuing in ignorant bliss; but, I will try to make it more clear and hopefully shine some light on this particular class of warnings that arguably should never have made it into object-oriented languages.</p>
<p>Let's have a look at a simple, but safe, example of virtual overrides:</p>
<pre><code>publicclassBaseClass {
	public BaseClass() {
	}
 
	protectedvirtualvoid ChangeState() {
		// do nothing in base **TODO: consider abstract**
	}
 
	publicvoid DoSomething() {
		ChangeState();
	}
}
 
publicclassDerivedClass : BaseClass {
	privateint value = 42;
	privatereadonlyint seed = 13;
 
	public DerivedClass() {
	}
 
	publicint Value { get { return value; } }
 
	protectedoverridevoid ChangeState() {
		value = newRandom(seed).Next();
	}
}
</code></pre>
<p>With a unit test like this:</p>
<pre><code>[TestMethod]
publicvoid ChangeStateTest() {
	DerivedClass target = newDerivedClass(13);
 
	target.DoSomething();
	Assert.AreEqual(1111907664, target.Value);
}
</code></pre>
<p>A silly example that has a virtual method that is used within a public method of the base class. Let's look at how we might evolve this code into something that causes a problem.</p>
<p>Let's say that given what we have now, we wanted our derived class to be &quot;initialized&quot; with what ChangeState does (naïvely: it's there, it does what we want, and we want to &quot;reuse&quot; it in the constructor); so, we modify BaseClass to do this:</p>
<pre><code>publicclassBaseClass {
	public BaseClass() {
		DoSomething();
	}
 
	protectedvirtualvoid ChangeState() {
		// do nothing in base **TODO: consider abstract**
	}
 
	privatevoid DoSomething() {
		ChangeState();
	}
}
 
publicclassDerivedClass : BaseClass {
	privateint value = 42;
	privatereadonlyint seed = 13;
 
	public DerivedClass() {
	}
 
	publicint Value { get { return value; } }
 
	protectedoverridevoid ChangeState() {
		value = newRandom(seed).Next();
	}
}
</code></pre>
<p>and we modify the tests to remove the call to DoSomething, as follows:</p>
<pre><code>[TestMethod]
publicvoid ConstructionTest() {
	DerivedClass target = newDerivedClass();
 
	Assert.AreEqual(1111907664, target.Value);
}
</code></pre>
<p>…tests still pass, all is good.</p>
<p>But, now we want to refactor our derived class. We realize that seed is really a constant and we can get rid of the value field if we use an auto property; so, we go ahead and modify BaseClass as follows:</p>
<pre><code>publicclassDerivedClass : BaseClass {
	privateconstint seed = 13;
 
	public DerivedClass() {
		Value = 42;
	}
 
	publicint Value { get; privateset; }
 
	protectedoverridevoid ChangeState() {
		Value = newRandom(seed).Next();
	}
}
</code></pre>
<p>Looks good; but now we having a failing test: Assert.AreEqual failed. Expected:&lt;1111907664&gt;. Actual:&lt;42&gt;.</p>
<p>&quot;Wait, what?&quot; you might be thinking…</p>
<p>What's happening here is that field initializers are executed before the base class constructor is called which, in turn, is called before the derived class constructor body is executed. Since we've effectively changed the initialization of the &quot;field&quot; (now a hidden backing field for the auto-prop) we've switched it from a field initializer to a line in the derived constructor body: trampling all over what the base class constructor did when calling the virtual method. Similar things happen in other OO languages; but, this particular order might be different.</p>
<p>Now, imagine if we didn't have a unit test to catch this; you'd have to run the application through some set of specific scenarios to find this error. Not so much fun.</p>
<p>Unfortunately, the only real solution to this is to not make virtual method calls from your base constructor. One solution to this is to separate the invocation of ChangeState from the invocation of the constructor. One way is basically reverting back to what we started with and adding a call to ChangeState in the same code that invokes the constructor. Without reverting our refactoring, we can change BaseClass to what it was before and invoke the DoSomething method in the test, resulting in the following code:</p>
<pre><code>publicclassBaseClass {
	public BaseClass() {
	}
 
	protectedvirtualvoid ChangeState() {
		// do nothing in base **TODO: consider abstract**
	}
 
	publicvoid DoSomething() {
		ChangeState();
	}
}
 
publicclassDerivedClass : BaseClass {
	privateconstint seed = 13;
 
	public DerivedClass() {
		Value = 42;
	}
 
	publicint Value { get; privateset; }
 
	protectedoverridevoid ChangeState() {
		Value = newRandom(seed).Next();
	}
}


[TestMethod]
publicvoid ChangeStateTest() {
	DerivedClass target = newDerivedClass();
 
	target.DoSomething();
	Assert.AreEqual(1111907664, target.Value);
}
</code></pre>
<p>Issues with virtual member invocations from a constructor are very subtle; if you're using Code Analysis, I recommend not disabling CA2214 and promoting it to and error. Oh, and write unit tests so you can catch these things as quickly as possible.</p>


<div id="disqus_thread"></div>  
<!--
    '%E2%80%9CVirtual-method-call-from-constructor%E2%80%9D-What-Could-Go-Wrong%3F'
    '&#x201C;Virtual method call from constructor&#x201D; What Could Go Wrong?'
    'http://blog.peterritchie.com/posts/%E2%80%9CVirtual-method-call-from-constructor%E2%80%9D-What-Could-Go-Wrong%3F'
-->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */

    var fromJekyllDate = new Date('Wed Feb 01 2022');
    var publishedDate = new Date('4/25/2012');
    console.info('%E2%80%9CVirtual-method-call-from-constructor%E2%80%9D-What-Could-Go-Wrong%3F');

    var disqus_identifier = '';
    var disqus_shortname = 'peterritchiesblog'; // required: replace example with your forum shortname
    var disqus_title = '&#x201C;Virtual method call from constructor&#x201D; What Could Go Wrong?';
    var disqus_url = 'http://blog.peterritchie.com/posts/%E2%80%9CVirtual-method-call-from-constructor%E2%80%9D-What-Could-Go-Wrong%3F';

    if(publishedDate < fromJekyllDate)
    {
        disqus_url = disqus_url.replace('/posts', '');
        disqus_url = disqus_url + '/';
    }
    else
    {
        //var disqus_identifier = '%E2%80%9CVirtual-method-call-from-constructor%E2%80%9D-What-Could-Go-Wrong%3F';
    }
    console.info(disqus_identifier);

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
						</div>
					</section>
				
				</section>
				
				<!-- Footer -->
                <footer id="footer">
                    <div class="container">
        <div class="row">
                <div class="col-md-12 text-center">
                    <p class="copyright text-muted">
                        Copyright © Peter Ritchie&#x27;s Blog 2022
                        <br />
                            <a href="/feed.xml"><i class="fa fa-rss"></i> RSS Feed</a>
                        |
                            <a href="/feed.atom"><i class="fa fa-rss"></i> Atom Feed</a>
                        <br />
                        <strong><a href="https://wyam.io">Generated by "Wyam"</a></strong>
                    </p>
                </div>
        </div>
</div>
                </footer>
			</div>

		<!-- Scripts -->
			<script src="/assets/js/skel.min.js"></script>
			<script src="/assets/js/jquery.min.js"></script>
			<script src="/assets/js/jquery.scrollex.min.js"></script>
			<script src="/assets/js/util.js"></script>
            <!--[if lte IE 8]><script src="/assets/js/ie/respond.min.js"></script><![endif]-->
            <script src="/assets/js/main.js"></script>

	</body>

</html>