

<!DOCTYPE HTML>
<!--
	Solid State by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Peter Ritchie&#x27;s Blog - The Religion of Class Member Prefixing</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<!--[if lte IE 8]><script src="/assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="/assets/sass/main.css" />
		<!--[if lte IE 9]><link rel="stylesheet" href="/assets/sass/ie9.css" /><![endif]-->
		<!--[if lte IE 8]><link rel="stylesheet" href="/assets/sass/ie8.css" /><![endif]-->
        

	</head>
	<body>

		<!-- Page Wrapper -->
			<div id="page-wrapper">
				
				<!-- Header -->
				<header id="header">
					<h1><a href="/">Peter Ritchie&#x27;s Blog</a></h1>
					<nav>
						<a href="#menu">Menu</a>
					</nav>
				</header>

				<!-- Menu -->
				<nav id="menu">
					<div class="inner">
						<h2>Menu</h2>
						<ul class="links">
							        <li><a href="/posts">Archive</a></li>
        <li><a href="/tags">Tags</a></li>
        <li><a href="/about">About</a></li>

						</ul>
						<a href="#" class="close">Close</a>
					</div>
				</nav>


    
<section id="banner">
  <div class="inner">
    <h2>The Religion of Class Member Prefixing</h2>
            <p><em>Published on Sunday, June 17, 2007</em></p>
                    <a role="button" href="/tags/C%23" class="button small">C#</a>
                <a role="button" href="/tags/Design/Coding-Guidance" class="button small">Design/Coding Guidance</a>
                <a role="button" href="/tags/June-2007" class="button small">June 2007</a>
                <a role="button" href="/tags/msmvps" class="button small">msmvps</a>
                <a role="button" href="/tags/Software-Development" class="button small">Software Development</a>
  </div>
</section>

				<!-- Main -->
				<section id="wrapper">
					<section class="wrapper style2">
						<div class="inner">
							

<p><a href="http://blogs.msmvps.com/peterritchie/2007/06/17/the-religion-of-class-member-prefixing/" title="Permalink to The Religion of Class Member Prefixing">Source</a></p>
<h1 id="the-religion-of-class-member-prefixing">The Religion of Class Member Prefixing</h1>
<p>The periodic identifier naming/prefixing/Hungarian-notation religious discussion <a href="http://blogs.msdn.com/ericgu/archive/2007/06/15/to-m-or-no-to-m-that-is-the-question.aspx">reared</a> its head recently on<a href="http://blogs.msdn.com/ericgu/default.aspx"> Eric Gunnerson's blog</a>.</p>
<p>This particular discussion revolves around the Microsoft-based guideline/anti-guidance of prefixing class member names with &quot;m_&quot; to denote that they are members. I've contributed to many of these discussions over the years and thought it about time to encapsulate my separate remarks to which I and others can refer to.</p>
<p>For the most part I accept this habit with my programmers for a variety of reasons: isn't guaranteed to do any harm, it's habit, refactoring tools make it easy to remove &quot;m_&quot;, etc.</p>
<p>When I switched from C++ to C#, I too brought along the &quot;m_&quot; prefix baggage where members can't be scoped by &quot;this&quot; everywhere (see intializer lists). I quickly realized it was unnecessary in C#, and haven't turned back.</p>
<p>Kent Beck's and Martin Fowler's Refactoring principles brought us the concept of &quot;Code Smell&quot;. Code smells are hints (I'm a pragmatist) that something might be wrong with code. &quot;m_&quot; to me is a bad smell.</p>
<p>When I ask a programmer why &quot;m_&quot; is used the practical answer is invariably &quot;well, the code is too hard to understand without it&quot; (the non-practical answers are usually &quot;Because of the coding guidelines&quot;, or &quot;It's just habit&quot;, but those don't answer the &quot;But, why?&quot;). And this, to me, is a bad code smell.</p>
<p>How complex does a class need to be in order for &quot;m_&quot; to make a difference? Clearly too complex. Is the class cohesive? Does the class and it's methods follow generally accepted cohesiveness design principles like <a href="http://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter</a> or <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a>? Is the class in inappropriately coupled to other classes? Have the meaningful-names guidelines been followed? I've never seen a class implementation where a member needed to be so complex (without violating one of the previously mentioned principles) to warrant the need for &quot;m_&quot;. Occasionally the need to scope a member with &quot;this.&quot; is required; but that's usually very infrequent, much less frequent than having to type &quot;m_&quot; on <em>every</em> member.</p>
<p>If a class <em>is</em> simple, why should complexity idioms be forced upon it? &quot;m_&quot; only works if you use it everywhere; if you don't use it in some places it makes it pointless. If I'm not sure the programmer just didn't forget &quot;m_&quot;, and I still have to refer to the class–the task that &quot;m_&quot; is supposed to ensure isn't needed. Similarin principle to using<a href="http://en.wikipedia.org/wiki/Const">const-correctness</a>, something missing from C# programming for the lack of enforcing it consistently.</p>
<p>The topic of consistency is one of the main reasons why I'm not a proponent of &quot;m_&quot;. There's no way to enforce use of &quot;m_&quot;, which leaves it up to the programmer. I've dealt with thousands of lines of code from hundreds of other programmers, more often than not inconsistent use of &quot;m_&quot; actually cuased &quot;m_&quot; to make the code much <em>harder to read</em>. Even the birthplace of &quot;m_&quot; has inconsistent usage of the idiom. Abram's and Cwalina's <em>Framework Design Guidelines</em> (the tome by which all Microsoft code is supposed to abide), as enforced by FxCop and Code Analysis (CA), suggests not using underscore or prefixes (other than &quot;I&quot; for interfaces); yet Eric is a proponent of &quot;m_&quot;. Much code that comes out of Microsoft (including the .NET Framework) occasionally uses &quot;m_&quot;, often inconsistently. Using &quot;m_&quot; can cause as many as 4 CA different warnings if the complex rules of &quot;m_&quot; are not followed. Porting code is a great source for that.</p>
<p>I call it a religious discussion because those who religiously follow the &quot;m_&quot; habit will not be swayed by logic or reason and invariably counter with some edge/corner case that could have made &quot;m_&quot; equally as useful as &quot;this.&quot;, or some logical fallacy, or an <em>appeal to authority</em> they've convinced themselves proves their case.</p>
<p><em>&quot;m</em>&quot; is less typing than &quot;this.&quot;_ is a great logical fallacy. This is a fallacy because it's only true in <em>that</em> sentence. Yes, if you have to type &quot;m_&quot; once instead of typing &quot;this.&quot; once, you've saved 3 keystrokes (at my typing speed that works out to saving about 300ms). With the &quot;m_&quot; prefix, that's now part of the name of the identifier, you <strong>_must _type it <em>every</em> time you type the name of that identifier</strong>. With &quot;this.&quot;, its necessity is based on context, or scope, so its use is optional in most cases and mandatory in some (backed-up with a compiler error, to which you should all agree compile-time checks should be used whenever possible). An identifier's un-obviousness of being a member doesn't occur with every instance of it. With an effective IDE it can infer the context in which you are typing and suggest what you're likely typing (Intellisense in Visual Studio). When using the &quot;m_&quot; prefix you must type at least 3 characters for every single private member of a class (assuming that's the guideline) for the suggested completion to be useful. In cases where &quot;this.&quot; isn't necessary, you only need to type one character for it to be equally useful. If you took the average class and analyzed how many keystrokes would be required for &quot;m_&quot; compared to no prefix and &quot;this.&quot; when needed, you'd find that using &quot;m_&quot; is actually _more <em>typing. Ironically, any time that could have been saved using or not using &quot;m</em>&quot; has been <em>far less</em> than the time spent discussing it.</p>
<p>Other reasons why &quot;m_&quot; isn't a solution every time it's used:</p>
<ul>
<li><p>It's English-centric. As such, it becomes more and more arbitrary with speakers of other languages.</p>
</li>
<li><p>It's typically C++-based. VB programmers have a whole different set of prefixing rules.</p>
</li>
<li><p>It's usage ends up being very contextual. In C++ &quot;m_&quot;could bemandated all member fields, in C# it could be mandated on only private instance members that aren't const (and I've never seen a clear description of the mandate for example Juval Lowy's IDesign C# Coding standard is seeminly contradictory: &quot;UsePascal Case for … constants&quot; providing aexample of a private member const named_DefaultSize_and &quot;prefix private member variables with m_&quot;.<br />
Yes, it's clear that DefaultSizeis not <em>variable</em> in nature but the junior programmers to which these guidelines are directed usually don't pick up on that nuance).</p>
</li>
</ul>
<p>Some discussions on the topic often sway between the &quot;m_&quot; prefix and just an underscore (&quot;<em>&quot;) prefix. Some argue that &quot;m</em>&quot; stands out more than &quot;_&quot;. Another great logical fallacy because a &quot;Member&quot; suffix should be preferred because it stands out even more.</p>
<p>Regardless of whether prefixing is used, most guidelines mandate that identifiers have meaningful names. If meaningful names are used, it's highly unlikely that it will be unclear in the code that a particular identifier is or is not a member of the class. More meaningful names <a href="http://blogs.msdn.com/ericlippert/archive/2007/06/12/bad-names.aspx">help in more areas</a> that just distinquishing members from non-members.</p>
<p>For me, my generalidioms are: use meaningful identifier names, prefer suffixes to prefixes, don't use underscores, use Camel Case for field members, and Pascal Case for non-field members (methods, types, constants, namespaces, etc.). Easy to understand, easy to follow, easy to qualify and enforce…</p>


<div id="disqus_thread"></div>  
<!--
    'The-Religion-of-Class-Member-Prefixing'
    'The Religion of Class Member Prefixing'
    'http://blog.peterritchie.com/posts/The-Religion-of-Class-Member-Prefixing'
-->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */

    var fromJekyllDate = new Date('Wed Feb 01 2022');
    var publishedDate = new Date('6/17/2007');
    console.info('The-Religion-of-Class-Member-Prefixing');

    var disqus_identifier = '';
    var disqus_shortname = 'peterritchiesblog'; // required: replace example with your forum shortname
    var disqus_title = 'The Religion of Class Member Prefixing';
    var disqus_url = 'http://blog.peterritchie.com/posts/The-Religion-of-Class-Member-Prefixing';

    if(publishedDate < fromJekyllDate)
    {
        disqus_url = disqus_url.replace('/posts', '');
        disqus_url = disqus_url + '/';
    }
    else
    {
        //var disqus_identifier = 'The-Religion-of-Class-Member-Prefixing';
    }
    console.info(disqus_identifier);

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
						</div>
					</section>
				
				</section>
				
				<!-- Footer -->
                <footer id="footer">
                    <div class="container">
        <div class="row">
                <div class="col-md-12 text-center">
                    <p class="copyright text-muted">
                        Copyright © Peter Ritchie&#x27;s Blog 2022
                        <br />
                            <a href="/feed.xml"><i class="fa fa-rss"></i> RSS Feed</a>
                        |
                            <a href="/feed.atom"><i class="fa fa-rss"></i> Atom Feed</a>
                        <br />
                        <strong><a href="https://wyam.io">Generated by "Wyam"</a></strong>
                    </p>
                </div>
        </div>
</div>
                </footer>
			</div>

		<!-- Scripts -->
			<script src="/assets/js/skel.min.js"></script>
			<script src="/assets/js/jquery.min.js"></script>
			<script src="/assets/js/jquery.scrollex.min.js"></script>
			<script src="/assets/js/util.js"></script>
            <!--[if lte IE 8]><script src="/assets/js/ie/respond.min.js"></script><![endif]-->
            <script src="/assets/js/main.js"></script>

	</body>

</html>