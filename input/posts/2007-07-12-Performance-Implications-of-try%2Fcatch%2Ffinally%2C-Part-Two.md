---
layout: post
title: 'Performance Implications of try/catch/finally, Part Two'
tags: ['.NET 2.0', '.NET Development', 'C#', '.NET', 'Design/Coding Guidance', 'msmvps']
---
[Source](http://blogs.msmvps.com/peterritchie/2007/07/12/performance-implications-of-try-catch-finally-part-two/ "Permalink to Performance Implications of try/catch/finally, Part Two")

# Performance Implications of try/catch/finally, Part Two

In a previous blog entry [Performance Implications of try/catch/finally][1]I outlined that the conventional wisdom that there are no performance implications to try blocks unless an exception is thrown is false. I have some clarifications and details to add.

My original tests used academic sample code like this:

  

  public int Method( )

  {

   int i = 10;

   try

   {

    i = 20;

    i = 30;

 Thread.Sleep(i);

   }

   finally

   {

    Thread.Sleep(i);

   }

   return i;

  }

Aswritten, theoptimized instructions generated by the JIT (Just-In-Time compiler) was showing that no optimizations were occurring in the try blockin that the only obvious optimization–the assignment of_20_ to _i–_wasn't optimizedaway.

But,I've loaded-the-deck, so to speak.Let's consider what exception handling needs to be able to do. In this case,I've explicitly said I need to do something in the event of an exception in the block of code I've wrapped withtry{}.The JIT takes me at my word and assumes every line inthat block couldthrow an exception. In order for thefinally block to getaccuratevalues for the current state–in the event ofthat exception–it can't optimizeany variables that are used in or past the finally block.In this case _10_ must first be assigned to _i_, then _20_ must be assigned to _i_ then _30_ must be assigned to _i_ in the sequence specified in the source code; because if those assignments threw an exception, the finally block would need one of the values: _10_, _20_, or _30_.

As you might be able to tell, I've loaded-the-deck because I don't have much outside the try block and everything in the try block is used outside of it as well. I haven't given the JIT much to work with. So, the "no optimizations are performed in try blocks" isn't entirely accurate. Obviously, in this case, the assignment of _10_ to _i_ wasn't optimized as well. But, the JIT _is_ smart enough to attempt to optimize within the try block. If we change the sample slightly to this:

  

  public int Method( )

  {

   int i = 10;

   try

   {

  

**    int c = 2;**

**    c = 3;**

 i = 20;

    i = 30;

** Thread.Sleep(c);**

   }

   finally

   {

    Thread.Sleep(i);

   }

   return i;

  }

…the JIT knows that _c_ is not used outside thetry block and proceeds to optimize it away and converts the Sleep statement into _Sleep(3)_. Essentially it's if I had written:

  

  public int Method( )

  {

   int i = 10;

   try

   {

    i = 20;

    i = 30;

    Thread.Sleep(3);

   }

   finally

   {

    Thread.Sleep(i);

   }

   return i;

  }



Okay, things aren't that dire; at least the JIT is doing what it can within the try block. But what about outside the try block; how drastic are the lack of optimizations there? Again, the JIT is smart enough to do what it can. If we change our original sample slightly again:



  

  public int Method( )

  {

   int i = 10;

**   int b = 9;**

**   b = 7;**

   try

   {

    i = 20;

    i = 30;

    Thread.Sleep(i);

   }

   finally

   {

    Thread.Sleep(i);

   }

**   return b;**

  }

We see that the JITis smart enough toattempt to optimize what'soutside the try block, and essentially results in this:

  

  public int Method( )

  {

   int i = 10;

   int b = 7;

   try

   {

    i = 20;

    i = 30;

    Thread.Sleep(i);

   }

   finally

   {

    Thread.Sleep(i);

   }

   return b;

  }

Better, it'scoalesced the writes (_7_ and _9_)to b into a single write (_7_);butfor some reason itstill forces the assignment of _7_ to _b_ before the try block. There's nothing that could see _b_ until the return, so it should be able to optimize it a bit further to this:

  

  public int Method( )

  {

   int i = 10;

   try

   {

    i = 20;

    i = 30;

    Thread.Sleep(i);

   }

   finally

   {

    Thread.Sleep(i);

   }

   return 7;

  }

So, while my previous statement wasn'tentirely accurate, I think what the JIT can optimize isneither better nor worse than "no optimizations are performed in try blocks", just different.You should still pay close attention to what you're doing in and around try blocks.

Also, an apples-to-oranges comparison; but methods with try/catch/finally blocks won't be inlined.

Having described what the JIT appears to be doing, and the implication that optimizations to variables used before and after will result in only coalesce-ations prior to the try block (i.e. we've observed that it won't optimize away a variable declared before a try block that is not used within the try or the finally); you should not rely on those side-effects. As far a I'm concerned the JIT is free to perform that last optimization I described, and probably many others.

[1]: http://msmvps.com/blogs/peterritchie/archive/2007/06/22/performance-implications-of-try-catch-finally.aspx


